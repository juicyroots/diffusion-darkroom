<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>Diffusion Darkroom
    
  </title>
  <link rel="icon" type="image/png" href="ddr.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  
  <!-- ============================================
       USER SETTINGS - Edit config.json at project root
       ============================================ -->
  <script src="/app-config.js"></script>
  <script>
    const DDR_WEB_CONFIG = (
      window.__DDR_APP_CONFIG__ &&
      typeof window.__DDR_APP_CONFIG__ === 'object' &&
      window.__DDR_APP_CONFIG__.web &&
      typeof window.__DDR_APP_CONFIG__.web === 'object'
    ) ? window.__DDR_APP_CONFIG__.web : {};

    const DEFAULT_MODEL_FILTERS = [
      { label: 'Flux', containsText: 'flux' },
      { label: 'Qwen', containsText: 'qwen' },
      { label: 'ZIT', containsText: 'z_image' },
      { label: 'Wan', containsText: 'wan' },
      { label: 'XL', containsText: 'xl' },
      { label: 'Pony', containsText: 'pony' }
    ];

    const MODEL_FILTERS = Array.isArray(DDR_WEB_CONFIG.modelFilters) && DDR_WEB_CONFIG.modelFilters.length > 0
      ? DDR_WEB_CONFIG.modelFilters
      : DEFAULT_MODEL_FILTERS;

    const DEFAULT_IMAGE_SIZE_SETTINGS = {
      min: 300,
      max: 1800,
      default: 900,
      step: 0.1
    };

    const IMAGE_SIZE_SETTINGS = {
      ...DEFAULT_IMAGE_SIZE_SETTINGS,
      ...(DDR_WEB_CONFIG.imageSize && typeof DDR_WEB_CONFIG.imageSize === 'object' ? DDR_WEB_CONFIG.imageSize : {})
    };

    const DEFAULT_PAGING_SETTINGS = {
      options: [50, 100, 250, 500],
      default: 100
    };

    const PAGING_SETTINGS = {
      ...DEFAULT_PAGING_SETTINGS,
      ...(DDR_WEB_CONFIG.paging && typeof DDR_WEB_CONFIG.paging === 'object' ? DDR_WEB_CONFIG.paging : {})
    };

    const DEFAULT_ZOOM_SETTINGS = {
      default: 2.5
    };

    const ZOOM_SETTINGS = {
      ...DEFAULT_ZOOM_SETTINGS,
      ...(DDR_WEB_CONFIG.zoom && typeof DDR_WEB_CONFIG.zoom === 'object' ? DDR_WEB_CONFIG.zoom : {})
    };

    const DEBUG_MODE = DDR_WEB_CONFIG.debugMode === true;
  </script>
  
  <style>
    :root {
      --ddr-fast-fade: 0.18s;
      --ddr-fast-ease: cubic-bezier(0.22, 0.06, 0.2, 1);
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      min-height: 100vh;
      font-family: 'Roboto', sans-serif;
      background: #000;
      box-sizing: border-box;
      overflow-x: hidden;
    }
    .gallery {
      width: 100%;
      min-height: 100vh;
      padding: 25px 10px 84px 10px;
      margin-top: 0;
      box-sizing: border-box;
      background: #000;
      position: relative;
      transition: padding-top 0.3s ease, margin-top 0.3s ease;
      text-align: center;
    }
    .img-container,
    .image-wrapper,
    .image-wrapper img,
    .filename-label,
    .image-buttons,
    .star-button,
    .delete-button,
    .rating-stars,
    .rating-star,
    .model-filter-btn,
    .sort-btn,
    .sort-option-btn,
    .pagination-page-size-item,
    .top-nav,
    .bottom-nav,
    .bottom-nav-page-size-standalone {
      transition-duration: var(--ddr-fast-fade) !important;
      transition-timing-function: var(--ddr-fast-ease) !important;
    }

    @media (prefers-reduced-motion: reduce) {
      .img-container,
      .image-wrapper,
      .image-wrapper img,
      .filename-label,
      .image-buttons,
      .star-button,
      .delete-button,
      .rating-stars,
      .rating-star,
      .model-filter-btn,
      .sort-btn,
      .sort-option-btn,
      .pagination-page-size-item,
      .top-nav,
      .bottom-nav,
      .bottom-nav-page-size-standalone {
        transition: none !important;
      }
    }
    .gallery.top-bar-visible {
      margin-top: 90px;
      padding-top: 10px;
    }
    body.startup-mode .gallery.top-bar-visible {
      margin-top: 0;
      padding-top: 25px;
    }
    .gallery.scrolling {
      cursor: none !important;
    }
    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 10000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    .loading-screen.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }
    .loading-screen-content {
      text-align: center;
      color: rgba(255, 255, 255, 0.9);
    }
    .loading-screen-title {
      font-size: 24px;
      font-weight: 500;
      margin-bottom: 10px;
      font-family: 'Roboto', sans-serif;
    }
    .loading-screen-message {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.7);
      font-family: 'Roboto', sans-serif;
    }
    .loading-screen-count {
      font-size: 15px;
      color: rgba(158, 197, 219, 0.95);
      font-family: 'Roboto', sans-serif;
      margin-top: 8px;
      letter-spacing: 0.3px;
    }
    .loading-screen-progress {
      width: 300px;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 20px;
    }
    .loading-screen-progress-fill {
      height: 100%;
      background: rgba(158, 197, 219, 1);
      transition: width 0.3s ease;
      width: 0%;
    }
    .gallery-column {
      display: inline-block;
      vertical-align: top;
      width: 600px;
      margin-right: 8px;
    }
    .no-images-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: gray;
      font-size: 14pt;
      text-align: center;
    }
    .img-container {
      display: block;
      position: relative;
      margin-bottom: 7px;
      background: transparent;
      border-radius: 5px;
      cursor: pointer;
      break-inside: avoid-column;
      /* Prevent layout shifts during loading */
      contain: layout style;
      transform-origin: center top;
    }
    .img-container.masonry-reflow {
      will-change: transform;
    }
    .img-container.removing {
      overflow: hidden;
      opacity: 0;
      transform: scale(0.985);
      margin-bottom: 0 !important;
      pointer-events: none;
      transition: height 0.22s var(--ddr-fast-ease), margin-bottom 0.22s var(--ddr-fast-ease), opacity 0.18s var(--ddr-fast-ease), transform 0.18s var(--ddr-fast-ease) !important;
    }
    .img-container.deleted {
      cursor: default;
      opacity: 0.4;
      pointer-events: none;
    }
    .img-container.deleted .image-wrapper {
      position: relative;
    }
    .img-container.deleted .image-wrapper {
      background: #2a2a2a; /* Dark gray background */
    }
    .img-container.deleted .image-wrapper::after {
      content: 'Deleted';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 12pt;
      font-weight: 500;
      z-index: 10;
      pointer-events: none;
      white-space: nowrap;
    }
    .img-container.deleted img {
      display: none; /* Hide the image completely to prevent broken image icon */
    }
    .img-container.deleted .star-button,
    .img-container.deleted .delete-button,
    .img-container.deleted .image-buttons {
      display: none;
    }
    .image-wrapper {
      position: relative;
      display: block;
      max-width: 600px;
      width: 100%;
      /* Reserve space to prevent layout shift */
      min-height: 200px;
      background: rgba(30, 30, 30, 0.5);
      /* Prevent layout shifts during image loading */
      contain: layout style paint;
      /* Smooth height transitions */
      transition: min-height 0.2s ease-out;
    }
    .image-wrapper img {
      width: 100%;
      max-width: 600px;
      display: block;
      height: auto;
      border-radius: 4px;
      background: #2a2a2a;
      border: 1px solid #515151;
      box-shadow: 0 2px 8px rgba(0,0,0,0.18);
      object-fit: contain;
      position: relative;
      z-index: 1;
      opacity: 0;
      transition: opacity 0.2s ease-in;
      will-change: opacity;
      /* Prevent layout shifts */
      contain: layout style paint;
    }
    .image-wrapper img.loaded {
      opacity: 1;
    }
    .image-placeholder {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, rgba(30,30,30,0.5) 0%, rgba(40,40,40,0.5) 50%, rgba(30,30,30,0.5) 100%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
      pointer-events: none; /* Allow clicks to pass through to image/container */
      border-radius: 4px;
      z-index: 0;
    }
    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }
    .filename-label {
      position: absolute;
      left: 1px;
      right: 1px;
      bottom: 1px;
      font-size: 8pt;
      color: #fff;
      background: rgba(0, 0, 0, 0.4);
      padding: 4px 4px 2px 5px;
      border-radius: 0 0 5px 5px;
      pointer-events: none;
      font-family: 'Roboto', sans-serif;
      text-overflow: ellipsis;
      white-space: nowrap;
      overflow: hidden;
      z-index: 1;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .img-container:hover .filename-label {
      opacity: 1;
    }
    .image-buttons {
      position: absolute;
      top: 7px;
      left: 7px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 3;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .img-container:hover .image-buttons {
      opacity: 1;
    }
    .image-button {
      position: relative;
      width: 22px;
      height: 22px;
      background: rgba(0, 0, 0, 0.2);
      border: none;
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.9;
      transition: opacity 0.2s, background 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      border:1px solid #4f4f4f;
      padding: 0;
    }
    .image-button:hover {
      opacity: 1;
      background: rgba(0, 0, 0, 0.85);
    }
    .image-button.copied {
      background: rgba(60, 138, 255, 0.8);
      opacity: 1;
    }
    .image-button svg {
      width: 14px;
      height: 14px;
      fill: #fff;
    }
    .image-button::after {
      content: attr(data-label);
      position: absolute;
      top: 50%;
      left: calc(100% + 8px);
      transform: translateY(-50%);
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      font-size: 11px;
      white-space: nowrap;
      border-radius: 4px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      font-family: 'Roboto', sans-serif;
      z-index: 10;
      min-width: max-content;
    }
    .image-button:hover::after {
      opacity: 1;
    }
    .star-button {
      position: absolute;
      top: 12px;
      right: 7px;
      width: 22px;
      height: 22px;
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid #4f4f4f;
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s ease, background 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      z-index: 3;
      padding: 0;
    }
    /* Always show star if favorited, only show on hover if not favorited */
    .star-button.favorited {
      opacity: 0.9;
    }
    .img-container:hover .star-button {
      opacity: 0.9;
    }
    .star-button:hover {
      opacity: 1;
      background: rgba(0, 0, 0, 0.85);
    }
    .star-button.favorited {
      /* Keep background and border gray - only fill changes */
      background: rgba(0, 0, 0, 0.2);
      border-color: #4f4f4f;
    }
    .star-button.favorited svg {
      fill: #ff4444;
    }
    .star-button svg {
      width: 14px;
      height: 14px;
      fill: #fff;
      transition: fill 0.2s;
    }
    .star-button::after {
      content: attr(data-label);
      position: absolute;
      top: 50%;
      right: calc(100% + 8px);
      transform: translateY(-50%);
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      font-size: 11px;
      white-space: nowrap;
      border-radius: 4px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      font-family: 'Roboto', sans-serif;
      z-index: 10;
      min-width: max-content;
    }
    .star-button:hover::after {
      opacity: 1;
    }
    .delete-button {
      position: absolute;
      bottom: 35px; /* Align with rating controls above filename label */
      right: 7px;
      width: 22px;
      height: 22px;
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid #4f4f4f;
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s ease, background 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      z-index: 3;
      padding: 0;
    }
    .delete-button.favorited {
      opacity: 0.9;
    }
    .img-container:hover .delete-button {
      opacity: 0.9;
    }
    .delete-button:hover {
      opacity: 1;
      background: rgba(220, 53, 69, 0.85);
      border-color: rgba(220, 53, 69, 0.8);
    }
    .delete-button.armed {
      opacity: 1;
      background: rgba(220, 53, 69, 0.88);
      border-color: rgba(220, 53, 69, 0.92);
    }
    .delete-button.armed svg {
      fill: #fff;
    }
    .delete-button svg {
      width: 14px;
      height: 14px;
      fill: #fff;
      transition: fill 0.2s;
    }
    /* Rating stars container - left bottom edge, above image label */
    .rating-stars {
      position: absolute;
      left: 7px;
      bottom: 35px; /* Above filename label (label height ~25px + 10px padding) */
      display: flex;
      flex-direction: column;
      gap: 2px;
      align-items: center;
      opacity: 0;
      transition: opacity 0.2s ease;
      z-index: 3;
      pointer-events: none;
    }
    .img-container:hover .rating-stars {
      opacity: 1;
      pointer-events: auto;
    }
    .rating-star {
      width: 16px;
      height: 16px;
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.72;
      transition: opacity 0.2s, transform 0.1s;
    }
    .rating-star:hover {
      opacity: 0.8;
      transform: scale(1.1);
    }
    .rating-star.active {
      opacity: 1;
    }
    .rating-star svg {
      width: 16px;
      height: 16px;
      fill: rgba(168, 178, 196, 0.88); /* Brighter gray for better thumbnail visibility */
      filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.45));
      transition: fill 0.2s;
    }
    .rating-star.active svg {
      fill: #ffd700; /* Gold when active */
    }
    .rating-star:hover svg {
      fill: #ffed4e;
    }
    /* Hover effect: highlight this star and all stars below it (lower ratings) */
    .rating-star:hover ~ .rating-star svg,
    .rating-star:hover svg {
      fill: #ffed4e;
    }
    .rating-star::after {
      content: attr(data-label);
      position: absolute;
      left: calc(100% + 8px);
      top: 50%;
      transform: translateY(-50%);
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      font-size: 11px;
      white-space: nowrap;
      border-radius: 4px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      font-family: 'Roboto', sans-serif;
      z-index: 10;
      min-width: max-content;
    }
    .rating-star:hover::after {
      opacity: 1;
    }
    /* Lightbox rating stars - left bottom edge */
    .lightbox-rating-stars {
      position: fixed;
      left: 18px;
      bottom: 50px; /* Above any bottom UI elements */
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: center;
      z-index: 100001;
      pointer-events: auto;
    }
    .lightbox-rating-star {
      width: 20px;
      height: 20px;
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.1s;
    }
    .lightbox-rating-star:hover {
      opacity: 0.8;
      transform: scale(1.15);
    }
    .lightbox-rating-star.active {
      opacity: 1;
    }
    .lightbox-rating-star svg {
      width: 20px;
      height: 20px;
      fill: rgba(128, 128, 128, 0.6); /* Semi-transparent gray when inactive */
      transition: fill 0.2s;
    }
    .lightbox-rating-star.active svg {
      fill: #ffd700; /* Gold when active */
    }
    .lightbox-rating-star:hover svg {
      fill: #ffed4e;
    }
    /* Hover effect: highlight this star and all stars below it (lower ratings) */
    .lightbox-rating-star:hover ~ .lightbox-rating-star svg,
    .lightbox-rating-star:hover svg {
      fill: #ffed4e;
    }
    .lightbox-rating-star::after {
      content: attr(data-label);
      position: absolute;
      left: calc(100% + 8px);
      top: 50%;
      transform: translateY(-50%);
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      font-size: 11px;
      white-space: nowrap;
      border-radius: 4px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      font-family: 'Roboto', sans-serif;
      z-index: 100002;
      min-width: max-content;
    }
    .lightbox-rating-star:hover::after {
      opacity: 1;
    }
    .delete-button::after {
      content: attr(data-label);
      position: absolute;
      top: 50%;
      right: calc(100% + 8px);
      transform: translateY(-50%);
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      font-size: 11px;
      white-space: nowrap;
      border-radius: 4px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      font-family: 'Roboto', sans-serif;
      z-index: 10;
      min-width: max-content;
    }
    .delete-button:hover::after {
      opacity: 1;
    }
    /* ---- Lightbox ---- */
    .lightbox-overlay {
      display: flex;
      position: fixed;
      z-index: 99999;
      left: 0; top: 0;
      right: 0; bottom: 0;
      width: 100%; height: 100vh;
      background: rgba(0,0,0,0.97);
      justify-content: center;
      align-items: center;
      cursor: pointer;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transition: opacity 0.2s var(--ddr-fast-ease), visibility 0.2s var(--ddr-fast-ease);
    }
    .lightbox-overlay.active {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }
    .lightbox-overlay.hide-cursor {
      cursor: none !important;
    }
    .lightbox-image-container {
      position: relative;
      width: 100%;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
    }
    .lightbox-img {
      max-width: 100vw;
      max-height: 100vh;
      width: auto;
      height: auto;
      border-radius: 5px;
      background: #2a2a2a;
      border: 1px solid #fff;
      object-fit: contain;
      box-shadow: 0 2px 32px #000;
      z-index: 10;
      pointer-events: auto;
      opacity: 0;
      transform: translateY(8px) scale(0.985);
      transition: transform 0.2s var(--ddr-fast-ease), opacity 0.2s var(--ddr-fast-ease);
    }
    .lightbox-overlay.active .lightbox-img {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    .lightbox-img.zoomed {
      transition: none;
      transform-origin: center center;
    }
    .lightbox-img.panning {
      cursor: none;
    }
    .lightbox-filename {
      font-size: 9pt;
      color: #fff;
      background: rgba(0,0,0,.3);
      position: absolute;
      left: 18px;
      bottom: 18px;
      padding: 2px 8px;
      border-radius: 3px;
      max-width: 80%;
      white-space: nowrap;
      letter-spacing: 0.03em;
      pointer-events: none;
      box-shadow: 0 0 2px #111;
      opacity: 0.65;
      z-index: 20;
    }
    .lightbox-star-button {
      position: fixed;
      top: 18px;
      right: 18px;
      width: 32px;
      height: 32px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.7;
      transition: opacity 0.2s ease, background 0.2s;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      z-index: 100001;
      padding: 0;
      pointer-events: auto; /* Override parent's pointer-events: none */
    }
    .lightbox-star-button:hover {
      opacity: 1;
      background: rgba(0, 0, 0, 0.6);
    }
    .lightbox-star-button.favorited {
      /* Keep background and border gray - only fill changes */
      background: rgba(0, 0, 0, 0.2);
      border-color: rgba(255, 255, 255, 0.2);
    }
    .lightbox-star-button.favorited svg {
      fill: #ff4444;
    }
    .lightbox-star-button svg {
      width: 18px;
      height: 18px;
      fill: #fff;
      transition: fill 0.2s;
      pointer-events: none; /* Prevent SVG from intercepting clicks */
    }
    /* ---- Lightbox Navigation Arrows ---- */
    .lightbox-nav-arrow {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(8px);
      border: 2px solid rgba(255, 255, 255, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100000;
      opacity: 0.6;
      transition: opacity 0.2s ease, background 0.2s ease, transform 0.2s ease;
      pointer-events: auto;
    }
    .lightbox-nav-arrow.visible {
      opacity: 0.6;
      pointer-events: auto;
    }
    .lightbox-nav-arrow.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .lightbox-nav-arrow:hover {
      background: rgba(255, 255, 255, 0.3);
      opacity: 1;
      transform: translateY(-50%) scale(1.1);
    }
    .lightbox-nav-arrow:active {
      transform: translateY(-50%) scale(0.95);
    }
    .lightbox-nav-arrow.left {
      left: 20px;
    }
    .lightbox-nav-arrow.right {
      right: 20px;
    }
    .lightbox-nav-arrow svg {
      width: 32px;
      height: 32px;
      fill: rgba(255, 255, 255, 0.9);
    }
    /* ---- Delete Confirmation Modal ---- */
    .delete-confirm-modal {
      display: none;
      position: fixed;
      left: 0; top: 0;
      right: 0; bottom: 0;
      width: 100%; height: 100vh;
      z-index: 999998;
      background: rgba(0, 0, 0, 0.85);
      justify-content: center;
      align-items: center;
      cursor: pointer;
      backdrop-filter: blur(4px);
    }
    .delete-confirm-modal.active {
      display: flex;
    }
    .delete-confirm-dialog {
      background: #1a1a1a;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 24px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      cursor: default;
      animation: modalFadeIn 0.2s ease-out;
    }
    @keyframes modalFadeIn {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
    .delete-confirm-dialog h3 {
      margin: 0 0 12px 0;
      font-size: 18px;
      font-weight: 500;
      color: #fff;
      font-family: 'Roboto', sans-serif;
    }
    .delete-confirm-dialog p {
      margin: 0 0 20px 0;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.7);
      line-height: 1.5;
      font-family: 'Roboto', sans-serif;
    }
    .delete-confirm-filename {
      margin: 12px 0;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.9);
      font-family: 'Roboto Mono', monospace;
      word-break: break-all;
      font-family: 'Roboto', sans-serif;
    }
    .delete-confirm-warning {
      margin: 16px 0;
      padding: 10px 12px;
      background: rgba(255, 68, 68, 0.1);
      border-left: 3px solid #ff4444;
      border-radius: 4px;
      font-size: 13px;
      color: rgba(255, 255, 255, 0.9);
      font-family: 'Roboto', sans-serif;
    }
    .delete-confirm-buttons {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 24px;
    }
    .delete-confirm-btn {
      padding: 10px 20px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 5px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: 'Roboto', sans-serif;
      min-width: 80px;
    }
    .delete-confirm-btn.cancel {
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.9);
    }
    .delete-confirm-btn.cancel:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.3);
    }
    .delete-confirm-btn.delete {
      background: rgba(255, 68, 68, 0.2);
      color: #ff4444;
      border-color: rgba(255, 68, 68, 0.4);
    }
    .delete-confirm-btn.delete:hover {
      background: rgba(255, 68, 68, 0.3);
      border-color: rgba(255, 68, 68, 0.6);
    }
    .delete-confirm-btn:active {
      transform: scale(0.98);
    }
    /* ---- Metadata Modal ---- */
    .meta-modal {
      display: none;
      position: fixed;
      left: 0; top: 0;
      right: 0; bottom: 0;
      width: 100%; height: 100vh;
      z-index: 999999;
      background: rgba(0,0,0,0.85);
      justify-content: center;
      align-items: center;
      cursor: pointer;
    }
    .meta-modal.active {
      display: flex;
    }
    .meta-table-container {
      background: #222;
      border-radius: 6px;
      box-shadow: 0 4px 32px #000;
      padding: 24px 32px;
      color: #fff;
      max-width: 70vw;
      max-height: 80vh;
      overflow: auto;
      position: relative;
      cursor: pointer;
      font-size: 15px;
      border: none;
    }
    .meta-table-container::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    .meta-table-container::-webkit-scrollbar-track {
      background: #111;
      border-radius: 4px;
    }
    .meta-table-container::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 4px;
    }
    .meta-table-container::-webkit-scrollbar-thumb:hover {
      background: #666;
    }
    table.meta-table {
      border-collapse: collapse;
      width: 100%;
      font-size: 15px;
      border: none;
    }
    table.meta-table td, table.meta-table th {
      border: none;
      padding: 6px 12px;
      vertical-align: top;
    }
    table.meta-table th {
      width: 20%;
      background: #222;
      color: #fff;
      text-align: left;
      white-space: nowrap;
      font-weight: normal;
      border-right: 1px solid #666;
    }
    table.meta-table tr {
      border-bottom: 1px solid #444;
    }
    table.meta-table td {
      width: 80%;
      word-break: break-word;
      overflow: hidden;
      position: relative;
      color: #9BA8B2; /* Light gun metal blue/gray */
    }
    .meta-value-wrapper {
      position: relative;
      padding-right: 50px;
      min-height: 20px;
    }
    .meta-copy-btn {
      position: absolute;
      top: 50%;
      right: 0;
      transform: translateY(-50%);
      font-size: 8pt;
      color: rgba(255, 255, 255, 0.6);
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      padding: 1px 4px;
      cursor: pointer;
      font-family: 'Roboto', sans-serif;
      transition: all 0.2s;
      line-height: 1.2;
      text-transform: lowercase;
    }
    .meta-copy-btn:hover {
      color: rgba(255, 255, 255, 0.9);
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
    }
    /* ---- Refactored Top Navigation ---- */
    .top-nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 86px;
      background: linear-gradient(90deg, rgba(14, 20, 30, 0.94), rgba(17, 26, 39, 0.97));
      backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
      display: grid;
      grid-template-rows: 52px 34px;
      z-index: 3000;
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.35);
      transform: translateY(-100%);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
      pointer-events: none;
      will-change: transform, opacity;
      overflow: visible;
    }
    body.startup-mode .top-nav {
      display: none;
    }
    .top-nav.visible {
      transform: translateY(0);
      opacity: 1;
      pointer-events: auto;
    }
    .top-nav-main {
      position: relative;
      height: 52px;
      padding: 0 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }
    .image-count {
      color: rgba(255, 255, 255, 0.5);
      font-size: 13px;
      font-family: 'Roboto', sans-serif;
      pointer-events: none;
      white-space: nowrap;
    }
    .image-count .count-number {
      font-weight: normal;
    }
    .search-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      width: 120px;
      max-width: 120px;
      flex-shrink: 0;
    }
    .search-input {
      width: 100%;
      height: 26px;
      padding: 0 26px 0 10px;
      background: #0c121a;
      border: 1px solid #273243;
      border-radius: 6px;
      color: #fff;
      font-size: 12px;
      font-family: 'Roboto', sans-serif;
      outline: none;
      transition: all 0.2s;
      box-sizing: border-box;
    }
    .search-input:focus {
      background: #101826;
      border-color: #4f78b8;
      box-shadow: 0 0 0 2px rgba(122, 168, 255, 0.18);
    }
    .search-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }
    .search-clear {
      position: absolute;
      right: 6px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: rgba(255, 255, 255, 0.7);
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      line-height: 1;
      padding: 0;
      transition: all 0.2s;
      z-index: 10;
      flex-shrink: 0;
    }
    .search-clear:hover {
      background: rgba(255, 255, 255, 0.3);
      color: rgba(255, 255, 255, 0.9);
    }
    .search-clear.visible {
      display: flex;
    }
    /* ---- Centered Search and Sort Container ---- */
    .search-sort-container {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 6;
    }
    /* ---- Compact Sort Control ---- */
    .sort-control {
      position: relative;
      flex-shrink: 0;
    }
    .sort-compact-btn {
      height: 26px;
      min-width: 132px;
      border-radius: 6px;
      background: #090f18;
      border: 1px solid #273243;
      color: #d8e2f0;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 0 8px;
      transition: all 0.2s;
      font-size: 11px;
      font-family: 'Roboto', sans-serif;
      white-space: nowrap;
    }
    .sort-compact-btn:hover {
      background: #253447;
      border-color: #4d6996;
    }
    .sort-compact-btn.active {
      background: rgba(109, 145, 189, 0.22);
      border-color: rgba(140, 178, 224, 0.58);
      box-shadow: inset 0 0 0 1px rgba(176, 208, 244, 0.22);
    }
    .sort-caret {
      color: rgba(255, 255, 255, 0.65);
      font-size: 10px;
      line-height: 1;
      transform: translateY(1px);
    }
    .sort-popover {
      position: absolute;
      top: calc(100% + 6px);
      left: 0;
      min-width: 200px;
      padding: 8px;
      border-radius: 8px;
      background: rgba(16, 18, 24, 0.98);
      border: 1px solid rgba(255, 255, 255, 0.16);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.45);
      z-index: 4000;
      display: none;
    }
    .sort-popover.open {
      display: block;
    }
    .sort-popover-title {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.55);
      margin: 0 0 6px;
      letter-spacing: 0.2px;
      text-transform: uppercase;
    }
    .sort-options-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-bottom: 8px;
    }
    .sort-dir-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
    }
    .sort-refresh-row {
      margin-top: 8px;
    }
    .sort-option-btn {
      height: 24px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(255, 255, 255, 0.82);
      cursor: pointer;
      font-size: 11px;
      font-family: 'Roboto', sans-serif;
      transition: all 0.2s;
      padding: 0 7px;
      text-align: left;
    }
    .sort-option-btn:hover {
      background: rgba(255, 255, 255, 0.14);
      border-color: rgba(255, 255, 255, 0.3);
    }
    .sort-option-btn.active {
      background: rgba(108, 149, 201, 0.34);
      border-color: rgba(151, 191, 238, 0.78);
      color: #f7fbff;
      box-shadow: inset 0 0 0 1px rgba(197, 224, 255, 0.22);
    }
    .sort-refresh-btn {
      width: 100%;
      text-align: center;
    }
    /* ---- Rating Filter Stars ---- */
    .rating-filter-stars {
      display: flex;
      align-items: center;
      gap: 3px;
      flex-shrink: 0;
      margin-left: 0;
      margin-right: 25px;
    }
    .rating-filter-star {
      width: 26px;
      height: 26px;
      background: #090f18;
      border: 1px solid #273243;
      border-radius: 6px;
      cursor: pointer;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 1;
      transition: background 0.2s, border-color 0.2s, transform 0.1s;
    }
    .rating-filter-star:hover {
      background: #253447;
      border-color: #4d6996;
      transform: translateY(-1px);
    }
    .rating-filter-star.active {
      background: #090f18;
      border-color: #273243;
    }
    .rating-filter-star svg {
      width: 13px;
      height: 13px;
      fill: rgba(142, 160, 184, 0.7);
      stroke: rgba(255, 255, 255, 0.3);
      stroke-width: 0.5px;
      transition: fill 0.2s, stroke 0.2s;
    }
    .rating-filter-star.active svg {
      fill: #77b4ff;
    }
    .rating-filter-star:hover svg {
      fill: #9fc8ff;
    }
    .rating-filter-star::after {
      content: attr(data-label);
      position: absolute;
      top: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      font-size: 11px;
      white-space: nowrap;
      border-radius: 4px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      font-family: 'Roboto', sans-serif;
      z-index: 10;
      min-width: max-content;
    }
    .rating-filter-star:hover::after {
      opacity: 1;
    }
    /* ---- Right Buttons (Favorites & Reload) ---- */
    .right-buttons {
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
      z-index: 6;
    }
    /* ---- Model Filter Buttons ---- */
    .model-filters {
      position: absolute;
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      align-items: center;
      gap: 4px;
      z-index: 6;
    }
    .model-filter-btn {
      height: 26px;
      min-width: 26px;
      padding: 0 6px;
      border-radius: 6px;
      background: #090f18;
      border: 1px solid #273243;
      color: #d8e2f0;
      cursor: pointer;
      font-family: 'Roboto', sans-serif;
      font-size: 11px;
      transition: all 0.2s;
    }
    .model-filter-btn:hover {
      background: #253447;
      border-color: #4d6996;
      color: #eef4ff;
    }
    .model-filter-btn.active {
      background: #2f4463;
      border-color: #4d6996;
      color: #fff;
    }
    .model-filter-btn:disabled {
      opacity: 0.6;
      cursor: wait;
    }
    .model-filter-btn {
      position: relative;
    }
    .model-filter-btn::after {
      content: attr(data-label);
      position: absolute;
      top: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      font-size: 11px;
      white-space: nowrap;
      border-radius: 4px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      font-family: 'Roboto', sans-serif;
      z-index: 10;
      min-width: max-content;
    }
    .model-filter-btn:hover::after {
      opacity: 1;
    }
    /* Model filter button indexing animation removed - status shown in bottom left progress indicator */
    .model-filters-status {
      font-size: 10px;
      color: #666;
      margin-left: 6px;
      white-space: nowrap;
      display: flex;
      align-items: center;
    }
    .sort-btn {
      width: 26px;
      height: 26px;
      border-radius: 6px;
      background: #090f18;
      border: 1px solid #273243;
      color: #d8e2f0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      transition: all 0.2s;
      font-size: 12px;
    }
    .sort-btn:hover {
      background: #253447;
      border-color: #4d6996;
      color: #eef4ff;
    }
    .sort-btn.active {
      background: #2f4463;
      border-color: #4d6996;
      color: #fff;
    }
    .sort-btn.favorites-active {
      background: #090f18;
      border-color: #273243;
    }
    .sort-btn.favorites-active svg {
      fill: #ff2a2a;
    }
    .sort-btn svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
    }
    #favoritesFilter {
      position: relative;
      margin-right: 25px;
    }
    #favoritesFilter::after {
      content: 'Toggle Favorites';
      position: absolute;
      top: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      font-size: 11px;
      white-space: nowrap;
      border-radius: 4px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      font-family: 'Roboto', sans-serif;
      z-index: 10;
      min-width: max-content;
    }
    #favoritesFilter:hover::after {
      opacity: 1;
    }
    /* ---- Reload Button ---- */
    .reload-btn {
      width: 26px;
      height: 26px;
      border-radius: 6px;
      background: #1a2331;
      border: 1px solid #273243;
      color: #d8e2f0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      transition: all 0.2s;
      flex-shrink: 0;
    }
    .reload-btn:hover {
      background: #253447;
      border-color: #4d6996;
      color: #eef4ff;
    }
    .reload-btn:active {
      transform: scale(0.95);
    }
    .reload-btn.loading {
      border: 1px solid rgba(255, 255, 255, 0.9);
      animation: pulse 1.5s ease-in-out infinite;
    }
    .reload-btn svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
    }
    .reload-btn.loading svg {
      animation: spin 1s linear infinite;
    }
    .folder-btn {
      width: 26px;
      height: 26px;
      border-radius: 6px;
      background: #1a2331;
      border: 1px solid #273243;
      color: #d8e2f0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      transition: all 0.2s;
      flex-shrink: 0;
    }
    .folder-btn:hover {
      background: #253447;
      border-color: #4d6996;
      color: #eef4ff;
    }
    .folder-btn svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
    }
    @keyframes pulse {
      0%, 100% {
        opacity: 1;
        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4);
      }
      50% {
        opacity: 0.8;
        box-shadow: 0 0 0 4px rgba(255, 255, 255, 0);
      }
    }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    /* ---- Size Control Slider ---- */
    .size-control {
      position: relative;
      display: flex;
      align-items: center;
      width: 100%;
      box-sizing: border-box;
      padding: 15px calc(42px + var(--ddr-scrollbar-inset, 0px)) 16px 14px;
      background: #03070f;
      z-index: 2;
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
      border-top: 1px solid rgba(165, 176, 196, 0.25);
      overflow: hidden;
    }
    .size-slider-container {
      position: relative;
      width: 100%;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      padding-right: 8px;
    }
    .size-slider-width-popup {
      position: absolute;
      top: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      font-size: 11px;
      white-space: nowrap;
      border-radius: 4px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      font-family: 'Roboto', sans-serif;
      z-index: 10;
      min-width: max-content;
    }
    .size-slider.dragging ~ .size-slider-width-popup,
    .size-control:has(.size-slider.dragging) .size-slider-width-popup {
      opacity: 1;
    }
    .size-slider {
      width: 100%;
      height: 4px;
      border-radius: 2px;
      background: linear-gradient(
        to right,
        #5e9fff 0 var(--ddr-slider-fill, 0%),
        #121a28 var(--ddr-slider-fill, 0%) 100%
      );
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
      transition: background 0.2s;
      border: none;
    }
    .size-slider::-webkit-slider-runnable-track {
      height: 4px;
      border-radius: 2px;
      background: linear-gradient(
        to right,
        #5e9fff 0 var(--ddr-slider-fill, 0%),
        #121a28 var(--ddr-slider-fill, 0%) 100%
      );
      border: none;
    }
    .size-slider::-moz-range-track {
      height: 4px;
      border-radius: 2px;
      background: linear-gradient(
        to right,
        #5e9fff 0 var(--ddr-slider-fill, 0%),
        #121a28 var(--ddr-slider-fill, 0%) 100%
      );
      border: none;
    }
    .size-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 28px;
      height: 16px;
      margin-top: -6px;
      border-radius: 8px;
      background: #5e9fff;
      border: 2px solid #9ebee5;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.45);
    }
    .size-slider::-webkit-slider-thumb:hover {
      background: #77afff;
      transform: scale(1.05);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.5);
    }
    .size-slider::-webkit-slider-thumb:active {
      background: #5e9fff;
      transform: scale(1.03);
    }
    .size-slider::-moz-range-thumb {
      width: 28px;
      height: 16px;
      border-radius: 8px;
      background: #5e9fff;
      border: 2px solid #9ebee5;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.45);
    }
    .size-slider::-moz-range-thumb:hover {
      background: #77afff;
      transform: scale(1.05);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.5);
    }
    .size-slider::-moz-range-thumb:active {
      background: #5e9fff;
      transform: scale(1.03);
    }
    .startup-landing {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 18px;
      background: #000;
      z-index: 1001;
    }
    .startup-landing.visible {
      display: flex;
    }
    .startup-title {
      color: rgba(54, 60, 70, 0.45);
      font-size: 80px;
      font-weight: 500;
      letter-spacing: 0.6px;
      text-transform: lowercase;
    }
    .startup-select-btn {
      height: 34px;
      border-radius: 8px;
      border: 1px solid #4d6996;
      background: #2f4463;
      color: #e8f0ff;
      padding: 0 16px;
      font-size: 13px;
      font-family: 'Roboto', sans-serif;
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s, transform 0.1s;
    }
    .startup-select-btn:hover {
      background: #3a5276;
      border-color: #5f7fb4;
    }
    .startup-select-btn:active {
      transform: translateY(1px);
    }
    /* ---- Loading Bar ---- */
    .loading-bar-container {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      font-family: 'Roboto', sans-serif;
      color: rgba(255, 255, 255, 0.7);
    }
    .loading-bar-wrapper {
      width: 120px;
      height: 12px;
      border: 1px solid #4a4a4a;
      border-radius: 4px;
      background: transparent;
      overflow: hidden;
      position: relative;
    }
    .loading-bar-fill {
      height: 100%;
      background: #9EC5DB;
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }
    .loading-percentage {
      font-size: 13px;
      color: rgba(255, 255, 255, 0.7);
      white-space: nowrap;
    }
    .loading-bar-container.hidden {
      display: none;
    }
    /* ---- Bottom Navigation ---- */
    .bottom-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      min-height: 40px;
      background: rgba(20, 20, 20, 0.95);
      backdrop-filter: blur(8px);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto minmax(0, 1fr);
      align-items: center;
      gap: 10px;
      padding: 4px 12px 6px;
      box-sizing: border-box;
      z-index: 1000;
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.3);
      transform: translateY(100%);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
      pointer-events: none;
    }
    .bottom-nav.visible {
      transform: translateY(0);
      opacity: 1;
      pointer-events: auto;
    }
    .bottom-nav.hidden {
      display: none;
    }
    .bottom-nav-left {
      display: flex;
      align-items: center;
      gap: 12px;
      min-width: 0;
      overflow: hidden;
    }
    .processing-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: #ff4444;
      flex-shrink: 0;
      display: none;
    }
    .processing-indicator.active {
      display: block;
    }
    .processing-status {
      font-size: 13px;
      color: rgba(255, 255, 255, 0.7);
      font-family: 'Roboto', sans-serif;
      white-space: nowrap;
      min-height: 16px;
      line-height: 16px;
    }
    .processing-status.active {
      color: rgba(158, 197, 219, 1);
    }
    .bottom-nav-center {
      display: flex;
      align-items: center;
      gap: 10px;
      justify-content: center;
      min-width: max-content;
      justify-self: center;
    }
    .bottom-nav-right {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-self: end;
      min-width: max-content;
    }
    .pagination-arrow {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.7);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      padding: 0;
      flex-shrink: 0;
    }
    .pagination-arrow:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
      color: rgba(255, 255, 255, 0.9);
    }
    .pagination-arrow:active {
      transform: scale(0.95);
    }
    .pagination-arrow svg {
      width: 18px;
      height: 18px;
      fill: currentColor;
    }
    .pagination-numbers {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 100%;
      overflow-x: auto;
    }
    .pagination-numbers::-webkit-scrollbar {
      display: none;
    }
    .pagination-numbers {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    .pagination-number {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: rgba(40, 40, 40, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.6);
      font-size: 11px;
      font-family: 'Roboto', sans-serif;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }
    .pagination-number:hover {
      background: rgba(60, 60, 60, 0.8);
      border-color: rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.8);
    }
    .pagination-number.active {
      background: #3f5364;
      border-color: rgba(255, 255, 255, 0.3);
      color: rgba(255, 255, 255, 0.9);
      font-weight: 500;
    }
    .pagination-page-size {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .pagination-page-size-item {
      position: relative;
      font-size: 13px;
      font-family: 'Roboto', sans-serif;
      color: rgba(255, 255, 255, 0.6);
      cursor: pointer;
      padding: 2px 6px;
      border-radius: 3px;
      transition: all 0.2s;
      user-select: none;
    }
    .pagination-page-size-item:hover {
      color: rgba(255, 255, 255, 0.8);
      background: rgba(255, 255, 255, 0.1);
    }
    .pagination-page-size-item.active {
      color: rgba(255, 255, 255, 0.9);
      background: #3f5364;
      font-weight: 500;
    }
    .pagination-page-size-item::after {
      content: attr(data-label);
      position: absolute;
      top: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      font-size: 11px;
      white-space: nowrap;
      border-radius: 4px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      font-family: 'Roboto', sans-serif;
      z-index: 10;
      min-width: max-content;
    }
    .pagination-page-size-item:hover::after {
      opacity: 1;
    }
    .pagination-page-size-separator {
      color: rgba(255, 255, 255, 0.3);
      font-size: 11px;
      margin: 0 2px;
    }
    .bottom-nav-page-size-standalone {
      position: fixed;
      bottom: 0;
      right: 0;
      min-height: 40px;
      background: rgba(20, 20, 20, 0.95);
      backdrop-filter: blur(8px);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding: 4px 12px 6px;
      box-sizing: border-box;
      z-index: 1000;
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.3);
      transform: translateY(100%);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
      pointer-events: none;
    }
    .bottom-nav-page-size-standalone.visible {
      transform: translateY(0);
      opacity: 1;
      pointer-events: auto;
    }
    .bottom-nav-page-size-standalone.hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="top-nav">
    <div class="top-nav-main">
      <div class="model-filters" id="modelFilters">
        <!-- Model filter buttons will be generated from MODEL_FILTERS settings -->
        <span class="model-filters-status"></span>
      </div>
      <div class="search-sort-container">
        <div class="search-wrapper">
          <input type="text" class="search-input" id="searchInput" />
          <button class="search-clear" id="searchClear" aria-label="Clear search"></button>
        </div>
        <div class="sort-control" id="sortControl">
          <button class="sort-compact-btn" id="sortControlBtn" title="Sorting options">
            <span id="sortControlLabel">Sort: Filename </span>
            <span class="sort-caret"></span>
          </button>
          <div class="sort-popover" id="sortPopover">
            <div class="sort-popover-title">Sort By</div>
            <div class="sort-options-grid">
              <button class="sort-option-btn" data-sort-field="filename">Filename</button>
              <button class="sort-option-btn" data-sort-field="date">Date</button>
              <button class="sort-option-btn" data-sort-field="stars">Stars</button>
              <button class="sort-option-btn" data-sort-field="favorites">Favorites</button>
            </div>
            <div class="sort-popover-title">Direction</div>
            <div class="sort-dir-row">
              <button class="sort-option-btn" data-sort-direction="asc">Ascending</button>
              <button class="sort-option-btn" data-sort-direction="desc">Descending</button>
            </div>
            <div class="sort-refresh-row">
              <button class="sort-option-btn sort-refresh-btn" id="sortRefreshBtn">Refresh Current Sort</button>
            </div>
          </div>
        </div>
      </div>
      <div class="right-buttons">
        <div class="rating-filter-stars" id="ratingFilterStars">
          <!-- Rating filter stars will be added here -->
        </div>
        <button class="sort-btn" id="favoritesFilter" title="Show favorites only">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
          </svg>
        </button>
        <button class="folder-btn" id="changeFolderBtn" title="Change Folder">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M10 4l2 2h8c1.1 0 2 .9 2 2v2h-2V8h-8.83l-2-2H4v12h7v2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2h6zm7 8l5 4-5 4v-3h-6v-2h6v-3z"/>
          </svg>
        </button>
        <button class="reload-btn" id="reloadBtn" title="Rescan folders and reload images">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
          </svg>
        </button>
      </div>
    </div>
    <div class="size-control">
      <div class="size-slider-container">
        <input type="range" class="size-slider" id="sizeSlider" 
               min="1.0" 
               max="6.0" 
               step="0.1" 
               value="1.0" 
               title="Image Size">
        <div class="size-slider-width-popup" id="sizeSliderWidthPopup"></div>
      </div>
    </div>
  </div>
  <div class="startup-landing" id="startupLanding">
    <div class="startup-title">diffusion darkroom</div>
    <button class="startup-select-btn" id="startupSelectFolder">Select Folder</button>
  </div>
  <div class="loading-screen" id="loadingScreen">
    <div class="loading-screen-content">
      <div class="loading-screen-title">Loading Darkroom</div>
      <div class="loading-screen-message" id="loadingScreenMessage">Preparing Layout...</div>
      <div class="loading-screen-progress">
        <div class="loading-screen-progress-fill" id="loadingScreenProgress"></div>
      </div>
      <div class="loading-screen-count" id="loadingScreenImageCount">0 Images</div>
    </div>
  </div>
  <div class="gallery" id="gallery"></div>
  <div class="bottom-nav hidden" id="bottomNav">
    <div class="bottom-nav-left">
      <div class="processing-indicator" id="processingIndicator"></div>
      <div class="loading-bar-container" id="loadingBarContainer">
        <div class="loading-bar-wrapper">
          <div class="loading-bar-fill" id="loadingBarFill"></div>
        </div>
        <div class="loading-percentage" id="loadingPercentage">0%</div>
      </div>
      <div class="processing-status" id="processingStatus"></div>
      <div class="image-count" id="imageCount" style="display: none;">Total Images: <span class="count-number">0</span></div>
    </div>
    <div class="bottom-nav-center">
      <button class="pagination-arrow" id="paginationPrev" aria-label="Previous page">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
        </svg>
      </button>
      <div class="pagination-numbers" id="paginationNumbers"></div>
      <button class="pagination-arrow" id="paginationNext" aria-label="Next page">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
        </svg>
      </button>
    </div>
    <div class="bottom-nav-right">
      <div class="pagination-page-size" id="paginationPageSize">
        <span class="pagination-page-size-item" data-size="50" data-label="50 Images Per Page">50</span>
        <span class="pagination-page-size-separator"></span>
        <span class="pagination-page-size-item active" data-size="100" data-label="100 Images Per Page">100</span>
        <span class="pagination-page-size-separator"></span>
        <span class="pagination-page-size-item" data-size="250" data-label="250 Images Per Page">250</span>
        <span class="pagination-page-size-separator"></span>
        <span class="pagination-page-size-item" data-size="500" data-label="500 Images Per Page">500</span>
      </div>
    </div>
  </div>
  <div class="bottom-nav-page-size-standalone hidden" id="bottomNavPageSizeStandalone">
    <div class="pagination-page-size">
      <span class="pagination-page-size-item" data-size="50" data-label="50 Images Per Page">50</span>
      <span class="pagination-page-size-separator"></span>
      <span class="pagination-page-size-item active" data-size="100" data-label="100 Images Per Page">100</span>
      <span class="pagination-page-size-separator"></span>
      <span class="pagination-page-size-item" data-size="250" data-label="250 Images Per Page">250</span>
      <span class="pagination-page-size-separator"></span>
      <span class="pagination-page-size-item" data-size="500" data-label="500 Images Per Page">500</span>
    </div>
  </div>
  <div class="lightbox-overlay" id="lightbox">
    <div class="lightbox-image-container" id="lightboxContainer">
      <img class="lightbox-img" id="lightboxImg" src="" alt="" />
      <span class="lightbox-filename" id="lightboxFilename"></span>
      <button class="lightbox-star-button" id="lightboxStarButton" title="Add to favorites">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
        </svg>
      </button>
      <div class="lightbox-rating-stars" id="lightboxRatingStars"></div>
    </div>
    <button class="lightbox-nav-arrow left" id="lightboxPrev" aria-label="Previous image">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
      </svg>
    </button>
    <button class="lightbox-nav-arrow right" id="lightboxNext" aria-label="Next image">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
      </svg>
    </button>
  </div>
  <div class="delete-confirm-modal" id="deleteConfirmModal">
    <div class="delete-confirm-dialog" id="deleteConfirmDialog">
      <h3>Delete Image</h3>
      <p>Are you sure you want to delete this image?</p>
      <div class="delete-confirm-filename" id="deleteConfirmFilename"></div>
      <div class="delete-confirm-warning">This action cannot be undone.</div>
      <div class="delete-confirm-buttons">
        <button class="delete-confirm-btn cancel" id="deleteConfirmCancel">Cancel</button>
        <button class="delete-confirm-btn delete" id="deleteConfirmDelete">Delete</button>
      </div>
    </div>
  </div>
  <div class="meta-modal" id="metaModal">
    <div class="meta-table-container" id="metaTableContainer">
      <div id="metaTableContent"></div>
    </div>
  </div>
  <script>
    // Production debug flag - set to false to disable debug logging
    // DEBUG_MODE is sourced from config.json (web.debugMode).
    
    // Debug logging helper
    function debugLog(...args) {
      if (DEBUG_MODE) {
        console.log(...args);
      }
    }
    
    // Calculate scrollbar width and adjust top nav
    function getScrollbarWidth() {
      const outer = document.createElement('div');
      outer.style.visibility = 'hidden';
      outer.style.overflow = 'scroll';
      outer.style.msOverflowStyle = 'scrollbar';
      outer.style.width = '100px';
      document.body.appendChild(outer);
      const inner = document.createElement('div');
      inner.style.width = '100%';
      outer.appendChild(inner);
      const scrollbarWidth = outer.offsetWidth - inner.offsetWidth;
      outer.parentNode.removeChild(outer);
      return scrollbarWidth;
    }
    
    // Apply scrollbar width offsets so fixed bars never sit under the browser scrollbar.
    function applyScrollbarInsets() {
      const measured = getScrollbarWidth();
      const viewportDelta = window.innerWidth - document.documentElement.clientWidth;
      const scrollbarWidth = Math.max(measured, viewportDelta, 0);
      const topNav = document.querySelector('.top-nav');
      const bottomNav = document.querySelector('.bottom-nav');
      const pageSizeStandalone = document.getElementById('bottomNavPageSizeStandalone');
      const rightInset = scrollbarWidth > 0 ? `${scrollbarWidth + 2}px` : '0px';
      document.documentElement.style.setProperty('--ddr-scrollbar-inset', rightInset);

      if (topNav) {
        topNav.style.right = rightInset;
      }
      if (bottomNav) {
        bottomNav.style.right = rightInset;
      }
      if (pageSizeStandalone) {
        pageSizeStandalone.style.right = rightInset;
      }
    }

    window.addEventListener('DOMContentLoaded', function() {
      applyScrollbarInsets();
      // Re-apply after layout settles and content height changes.
      setTimeout(applyScrollbarInsets, 50);
      setTimeout(applyScrollbarInsets, 250);
    });
    window.addEventListener('resize', applyScrollbarInsets);
    window.addEventListener('load', applyScrollbarInsets);
    
    // Rating helper functions
    function parseRatingFromFilename(filename) {
      // Extract rating from filename pattern: filename_##.ext
      // Returns rating (1-5) or 0 if no rating
      // Match _## pattern only when it's immediately before the extension (last _## before .ext)
      const pathParts = filename.split('/');
      const lastPart = pathParts[pathParts.length - 1];
      const match = lastPart.match(/_(0[1-5])(\.[^.]+)$/);
      if (match) {
        const rating = parseInt(match[1], 10);
        if (rating >= 1 && rating <= 5) {
          return rating;
        }
      }
      return 0;
    }
    
    function removeRatingFromFilename(filename) {
      // Remove _## rating pattern from filename
      // Pattern: path/to/filename_##.ext -> path/to/filename.ext
      // Match _## only when it's immediately before the extension (last _## before .ext)
      // Handle paths correctly by working on the last part (filename)
      const pathParts = filename.split('/');
      const lastPart = pathParts[pathParts.length - 1];
      
      // Match _## pattern before extension (must be 01-05)
      // Use greedy match to get everything before the last _## pattern
      const match = lastPart.match(/^(.+)_(0[1-5])(\.[^.]+)$/);
      if (match) {
        const name = match[1];
        const ext = match[3];
        pathParts[pathParts.length - 1] = name + ext;
        return pathParts.join('/');
      }
      return filename; // No rating pattern found, return as-is
    }
    
    function addRatingToFilename(filename, rating) {
      // Add rating to filename: filename.ext -> filename_0#.ext
      if (rating < 1 || rating > 5) {
        return filename; // Invalid rating, return unchanged
      }
      
      // Remove existing rating if present
      const withoutRating = removeRatingFromFilename(filename);
      
      // Find the last dot (extension)
      const lastDot = withoutRating.lastIndexOf('.');
      if (lastDot === -1) {
        // No extension, just append rating
        return withoutRating + '_0' + rating;
      }
      
      // Insert rating before extension
      const name = withoutRating.substring(0, lastDot);
      const ext = withoutRating.substring(lastDot);
      return name + '_0' + rating + ext;
    }
    
    function escapeFilename(filename) {
      // For file:// protocol, we need to preserve path separators
      // Only encode the filename parts, not the path structure
      const trimmed = filename.trim();
      // Split by path separators, encode each part, then rejoin
      const parts = trimmed.split(/[/\\]/);
      return parts.map(part => encodeURIComponent(part)).join('/');
    }
    function removeExtension(filename) {
      return filename.replace(/\.[^/.]+$/, '');
    }
    function getFilenameOnly(path) {
      // Extract just the filename from a path (handles both / and \)
      return path.split(/[/\\]/).pop();
    }
    function getPathSortKey(path) {
      // Keep filename sort deterministic across folders and OS separators.
      return String(path || '').replace(/\\/g, '/').toLowerCase();
    }
    async function copyTextRobust(text) {
      const value = String(text || '');
      if (!value) return false;
      try {
        if (navigator.clipboard && window.isSecureContext) {
          await navigator.clipboard.writeText(value);
          return true;
        }
      } catch (e) {}
      try {
        const textarea = document.createElement('textarea');
        textarea.value = value;
        textarea.setAttribute('readonly', '');
        textarea.style.position = 'fixed';
        textarea.style.left = '-9999px';
        textarea.style.top = '0';
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        const ok = document.execCommand('copy');
        document.body.removeChild(textarea);
        return !!ok;
      } catch (e) {
        return false;
      }
    }
    async function showLightbox(src, filename, index = -1) {
      // Resolve using the clicked filename itself; don't use stale lightbox datasets here.
      filename = resolveCurrentFilename(filename);
      src = escapeFilename(filename);

      // Store scroll position before opening lightbox
      scrollPositionBeforeLightbox = window.scrollY || window.pageYOffset || document.documentElement.scrollTop;
      
      const lightbox = document.getElementById('lightbox');
      const img = document.getElementById('lightboxImg');
      const label = document.getElementById('lightboxFilename');
      
      // Update current index (use filteredImageFiles for navigation)
      if (index >= 0) {
        // Find the index in filteredImageFiles
        currentLightboxIndex = filteredImageFiles.findIndex(f => f === filename);
        if (currentLightboxIndex === -1) {
          // Fallback to allImageFiles if not found in filtered
          currentLightboxIndex = allImageFiles.findIndex(f => f === filename);
        }
      } else {
        // Find index from filename if not provided
        currentLightboxIndex = filteredImageFiles.findIndex(f => f === filename);
        if (currentLightboxIndex === -1) {
          // Fallback to allImageFiles if not found in filtered
          currentLightboxIndex = allImageFiles.findIndex(f => f === filename);
        }
      }
      
      img.src = src;
      const baseFilename = removeExtension(getFilenameOnly(filename));
      label.textContent = baseFilename; // Will be updated when metadata loads
      lightbox.classList.remove('closing');
      requestAnimationFrame(() => {
        lightbox.classList.add('active');
      });
      
      // Update navigation arrows visibility
      updateNavArrows();
      
      // Reset zoom and pan state
      zoomActive = false;
      isPanning = false;
      currentZoomScale = 1;
      img.classList.remove('zoomed', 'panning');
      img.style.transform = '';
      img.style.transformOrigin = 'center center';
      
      // Update label with metadata
      try {
        const metadata = await getPngMetadata(src);
        const displayData = formatMetadataForDisplay(metadata);
        
        const parts = [baseFilename];
        if (displayData['Model']) parts.push(displayData['Model']);
        if (displayData['Sampler']) parts.push(displayData['Sampler']);
        if (displayData['Schedule Type']) parts.push(displayData['Schedule Type']);
        
        // Add size/dimensions at the end
        if (displayData['Size']) {
          parts.push(displayData['Size']);
        } else if (img.naturalWidth && img.naturalHeight) {
          // Fallback to actual image dimensions if Size not in metadata
          parts.push(`${img.naturalWidth}x${img.naturalHeight}`);
        }
        
        label.textContent = parts.join('  ');
      } catch (err) {
        // If metadata extraction fails, keep the base filename
        label.textContent = baseFilename;
        // Try to get dimensions from image
        if (img.naturalWidth && img.naturalHeight) {
          label.textContent = `${baseFilename}  ${img.naturalWidth}x${img.naturalHeight}`;
        }
      }
      
      img.onload = function() {
        resetImageSize();
      };
      
      // Update lightbox star button
      const lightboxStarButton = document.getElementById('lightboxStarButton');
      if (lightboxStarButton) {
        const isFavorited = filename.startsWith('Favorites/') || 
                           filename.startsWith('Favorites\\') ||
                           filename.includes('/Favorites/') || 
                           filename.includes('\\Favorites\\');
        if (isFavorited) {
          lightboxStarButton.classList.add('favorited');
          lightboxStarButton.setAttribute('title', 'Remove from favorites');
        } else {
          lightboxStarButton.classList.remove('favorited');
          lightboxStarButton.setAttribute('title', 'Add to favorites');
        }
        lightboxStarButton.dataset.filename = filename;
        lightboxStarButton.dataset.imageId = getImageIdForPath(filename) || '';
      }
      
      // Update lightbox rating stars
      const lightboxRatingContainer = document.getElementById('lightboxRatingStars');
      if (lightboxRatingContainer) {
        // Clear existing stars
        lightboxRatingContainer.innerHTML = '';
        lightboxRatingContainer.dataset.filename = filename;
        lightboxRatingContainer.dataset.imageId = getImageIdForPath(filename) || '';
        
        // Get current rating
        const currentRating = parseRatingFromFilename(filename);
        
        // Create 5 stars in reverse order (top = 5, bottom = 1)
        for (let i = 5; i >= 1; i--) {
          const star = document.createElement('button');
          star.className = 'lightbox-rating-star';
          if (i <= currentRating) {
            star.classList.add('active');
          }
          star.dataset.rating = i;
          star.setAttribute('aria-label', `Rate ${i} star${i > 1 ? 's' : ''}`);
          star.setAttribute('data-label', `${i} Star${i > 1 ? 's' : ''}`);
          star.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>';
          
          star.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const currentFilename = resolveCurrentFilename(
              lightboxRatingContainer.dataset.filename || filename,
              lightboxRatingContainer
            );
            const currentImageId = lightboxRatingContainer.dataset.imageId || getImageIdForPath(currentFilename);
            // Find the container for this image
            const containers = Array.from(document.querySelectorAll('.img-container'));
            const matchingContainer = containers.find(c => {
              if (currentImageId && c.dataset.imageId === currentImageId) return true;
              const cFilename = c.dataset.filename || c.dataset.currentFilename;
              return cFilename === currentFilename;
            });
            const thumbnailRatingContainer = matchingContainer?.querySelector('.rating-stars');
            setRating(currentFilename, i, thumbnailRatingContainer || lightboxRatingContainer, matchingContainer);
          });
          
          lightboxRatingContainer.appendChild(star);
        }
      }
    }
    
    function resetImageSize() {
      const img = document.getElementById('lightboxImg');
      if (!img || !img.src) return;
      
      // Calculate size to fill viewport (height or width, maintaining aspect ratio)
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const imgAspect = img.naturalWidth / img.naturalHeight;
      const viewportAspect = viewportWidth / viewportHeight;
      
      if (imgAspect > viewportAspect) {
        // Image is wider - fit to width
        img.style.width = viewportWidth + 'px';
        img.style.height = 'auto';
      } else {
        // Image is taller - fit to height
        img.style.width = 'auto';
        img.style.height = viewportHeight + 'px';
      }
    }
    function hideLightbox() {
      const lightboxEl = document.getElementById('lightbox');
      if (!lightboxEl || !lightboxEl.classList.contains('active')) {
        return;
      }
      const img = document.getElementById('lightboxImg');
      zoomActive = false;
      isPanning = false;
      currentZoomScale = 1;
      img.classList.remove('zoomed', 'panning');
      img.style.transform = '';
      img.style.transformOrigin = 'center center';
      img.style.width = '';
      img.style.height = '';
      lightboxEl.classList.add('closing');
      lightboxEl.classList.remove('active');
      lightboxEl.classList.remove('hide-cursor');
      currentLightboxIndex = -1;
      setTimeout(() => {
        img.src = '';
        lightboxEl.classList.remove('closing');
      }, 210);
      
      // Restore scroll position after closing lightbox
      if (scrollPositionBeforeLightbox > 0) {
        requestAnimationFrame(() => {
          window.scrollTo(0, scrollPositionBeforeLightbox);
          if (document.documentElement.scrollTop !== undefined) {
            document.documentElement.scrollTop = scrollPositionBeforeLightbox;
          }
          if (document.body.scrollTop !== undefined) {
            document.body.scrollTop = scrollPositionBeforeLightbox;
          }
        });
      }
      
      // Hide navigation arrows
      const prevBtn = document.getElementById('lightboxPrev');
      const nextBtn = document.getElementById('lightboxNext');
      prevBtn.classList.remove('visible');
      prevBtn.classList.add('hidden');
      nextBtn.classList.remove('visible');
      nextBtn.classList.add('hidden');
    }
    
    // Navigation functions
    function updateNavArrows() {
      // Show/hide arrows based on whether navigation is possible
      const prevBtn = document.getElementById('lightboxPrev');
      const nextBtn = document.getElementById('lightboxNext');
      
      // Show previous arrow if there's a previous image
      if (currentLightboxIndex > 0) {
        prevBtn.classList.add('visible');
        prevBtn.classList.remove('hidden');
      } else {
        prevBtn.classList.remove('visible');
        prevBtn.classList.add('hidden');
      }
      
      // Show next arrow if there's a next image (use filteredImageFiles)
      if (currentLightboxIndex >= 0 && currentLightboxIndex < filteredImageFiles.length - 1) {
        nextBtn.classList.add('visible');
        nextBtn.classList.remove('hidden');
      } else {
        nextBtn.classList.remove('visible');
        nextBtn.classList.add('hidden');
      }
    }
    
    function navigateLightbox(direction) {
      if (currentLightboxIndex < 0) {
        // Try to recover index from the currently displayed lightbox filename.
        const lightboxStarBtn = document.getElementById('lightboxStarButton');
        const currentFilename = resolveCurrentFilename(lightboxStarBtn?.dataset?.filename || '');
        if (currentFilename) {
          currentLightboxIndex = filteredImageFiles.findIndex(f => f === currentFilename);
          if (currentLightboxIndex === -1) {
            currentLightboxIndex = allImageFiles.findIndex(f => f === currentFilename);
          }
        }
        if (currentLightboxIndex < 0) {
          return;
        }
      }
      
      if (isNavigating) {
        return;
      }
      
      isNavigating = true; // Set flag to prevent other handlers from closing lightbox
      
      let newIndex;
      if (direction === 'prev') {
        newIndex = currentLightboxIndex - 1;
        if (newIndex < 0) {
          isNavigating = false;
          return;
        }
      } else if (direction === 'next') {
        newIndex = currentLightboxIndex + 1;
        if (newIndex >= filteredImageFiles.length) {
          isNavigating = false;
          return;
        }
      } else {
        isNavigating = false;
        return;
      }
      
      const filename = filteredImageFiles[newIndex];
      showLightbox(escapeFilename(filename), filename, newIndex);
      
      // Update lightbox star button and rating stars after navigation
      // Note: showLightbox already updates these, but we update here for consistency
      setTimeout(() => {
        const lightboxStarButton = document.getElementById('lightboxStarButton');
        if (lightboxStarButton && filename) {
          const isFavorited = filename.startsWith('Favorites/') || 
                             filename.startsWith('Favorites\\') ||
                             filename.includes('/Favorites/') || 
                             filename.includes('\\Favorites\\');
          if (isFavorited) {
            lightboxStarButton.classList.add('favorited');
            lightboxStarButton.setAttribute('title', 'Remove from favorites');
          } else {
            lightboxStarButton.classList.remove('favorited');
            lightboxStarButton.setAttribute('title', 'Add to favorites');
          }
          lightboxStarButton.dataset.filename = filename;
          lightboxStarButton.dataset.imageId = getImageIdForPath(filename) || '';
        }
        
        // Update lightbox rating stars
        const lightboxRatingContainer = document.getElementById('lightboxRatingStars');
        if (lightboxRatingContainer && filename) {
          const currentRating = parseRatingFromFilename(filename);
          updateRatingDisplay(lightboxRatingContainer, currentRating);
          lightboxRatingContainer.dataset.filename = filename;
          lightboxRatingContainer.dataset.imageId = getImageIdForPath(filename) || '';
        }
      }, 100);
      
      // Reset the navigation lock shortly after rendering starts.
      // Keeping this brief avoids "double-click required" behavior.
      setTimeout(() => {
        isNavigating = false;
      }, 60);
    }
    let allImageContainers = [];
    let allImageFiles = [];
    let galleryColumns = [];
    // Initialize from settings
    const baseColumnWidth = IMAGE_SIZE_SETTINGS.min;
    const maxColumnWidth = IMAGE_SIZE_SETTINGS.max;
    const defaultSizeMultiplier = IMAGE_SIZE_SETTINGS.default / IMAGE_SIZE_SETTINGS.min;
    let currentSizeMultiplier = defaultSizeMultiplier;
    let currentLightboxIndex = -1; // Track current image index in lightbox
    let isNavigating = false; // Flag to prevent closing during navigation
    let scrollPositionBeforeLightbox = 0; // Store scroll position before opening lightbox
    let sortState = {
      field: 'filename', // 'filename', 'date', 'stars', 'favorites'
      direction: 'asc' // 'asc', 'desc'
    };
    let showFavoritesOnly = false; // Track favorites filter state
    let activeModelFilter = null; // Track active model filter: 'flux', 'xl', 'pony', or null
    let activeRatingFilters = new Set(); // Track active rating filters: Set of numbers 1-5
    let favoriteOriginalPaths = new Map(); // Track original paths of favorited images: filename -> originalPath (in-memory cache)
    let imageIdToPath = new Map(); // imageId -> current path
    let pathToImageId = new Map(); // current path -> imageId
    let imageIdCounter = 1;
    let currentBaseFolder = '';
    const HISTORY_STORAGE_KEY = 'favoritesHistory'; // localStorage key for history
    
    // Load favorites history from localStorage
    function loadFavoritesHistory() {
      try {
        const historyJson = localStorage.getItem(HISTORY_STORAGE_KEY);
        if (historyJson) {
          const history = JSON.parse(historyJson);
          // Populate the in-memory map from localStorage
          Object.entries(history).forEach(([favoritesPath, originalPath]) => {
            favoriteOriginalPaths.set(favoritesPath, originalPath);
          });
          debugLog('Loaded favorites history:', Object.keys(history).length, 'entries');
          return true;
        }
      } catch (error) {
        console.error('Error loading favorites history:', error);
      }
      return false;
    }
    
    // Save favorites history to localStorage
    function saveFavoritesHistory() {
      try {
        // Convert Map to plain object for JSON storage
        const history = {};
        favoriteOriginalPaths.forEach((originalPath, favoritesPath) => {
          history[favoritesPath] = originalPath;
        });
        localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));
        return true;
      } catch (error) {
        console.error('Error saving favorites history:', error);
        return false;
      }
    }
    
    // Add an entry to history
    function addToHistory(favoritesPath, originalPath) {
      favoriteOriginalPaths.set(favoritesPath, originalPath);
      saveFavoritesHistory();
    }
    
    // Remove an entry from history
    function removeFromHistory(favoritesPath) {
      favoriteOriginalPaths.delete(favoritesPath);
      saveFavoritesHistory();
    }
    
    // Get original path from history, or return null if not found
    function getOriginalPathFromHistory(favoritesPath) {
      return favoriteOriginalPaths.get(favoritesPath) || null;
    }
    function normalizeImagePath(path) {
      return (path || '').replace(/\\/g, '/');
    }

    // Resolve latest path after file moves/renames.
    function resolveCurrentFilename(filename, ...elements) {
      let candidate = normalizeImagePath(filename);

      if (candidate && (allImageFiles.includes(candidate) || filteredImageFiles.includes(candidate))) {
        return candidate;
      }

      for (const el of elements) {
        if (!el || !el.dataset) continue;
        const imageId = el.dataset.imageId;
        if (imageId && imageIdToPath.has(imageId)) {
          return imageIdToPath.get(imageId);
        }
        const dataPath = normalizeImagePath(el.dataset.filename || el.dataset.currentFilename || '');
        if (!candidate && dataPath) {
          candidate = dataPath;
          break;
        }
      }

      if (candidate && (allImageFiles.includes(candidate) || filteredImageFiles.includes(candidate))) {
        return candidate;
      }

      const baseName = getFilenameOnly(candidate);
      if (baseName) {
        const resolved = allImageFiles.find(f => getFilenameOnly(f) === baseName) ||
                         filteredImageFiles.find(f => getFilenameOnly(f) === baseName);
        if (resolved) return resolved;
      }

      return candidate;
    }

    function restoreScrollPositionStable(targetY) {
      const y = Math.max(0, Number(targetY) || 0);
      const apply = () => {
        window.scrollTo(0, y);
        if (document.documentElement.scrollTop !== undefined) {
          document.documentElement.scrollTop = y;
        }
        if (document.body.scrollTop !== undefined) {
          document.body.scrollTop = y;
        }
      };
      apply();
      requestAnimationFrame(apply);
      setTimeout(apply, 40);
      setTimeout(apply, 120);
      setTimeout(apply, 260);
    }

    function getContainerIdentity(container) {
      if (!container) return '';
      return container.dataset.imageId || container.dataset.filename || container.dataset.currentFilename || '';
    }

    function captureContainerPositions(containers) {
      const positions = new Map();
      (containers || []).forEach((container) => {
        if (!container || !container.isConnected) return;
        const key = getContainerIdentity(container);
        if (!key) return;
        positions.set(key, container.getBoundingClientRect());
      });
      return positions;
    }

    function animateContainerRemoval(container) {
      if (!container) return Promise.resolve();
      const startHeight = Math.max(container.offsetHeight, 1);
      container.style.height = `${startHeight}px`;
      container.style.maxHeight = `${startHeight}px`;
      container.style.minHeight = '0px';
      void container.offsetHeight;
      container.classList.add('removing');
      container.style.height = '0px';
      container.style.maxHeight = '0px';
      container.style.marginBottom = '0px';
      return new Promise((resolve) => setTimeout(resolve, 220));
    }

    function animateMasonryReflowFrom(previousPositions) {
      if (!(previousPositions instanceof Map) || previousPositions.size === 0) return;
      const duration = 220;
      allImageContainers.forEach((container) => {
        if (!container || !container.isConnected) return;
        const key = getContainerIdentity(container);
        if (!key) return;
        const beforeRect = previousPositions.get(key);
        if (!beforeRect) return;
        const afterRect = container.getBoundingClientRect();
        const deltaX = beforeRect.left - afterRect.left;
        const deltaY = beforeRect.top - afterRect.top;
        if (Math.abs(deltaX) < 0.5 && Math.abs(deltaY) < 0.5) return;
        container.classList.add('masonry-reflow');
        container.style.transition = 'none';
        container.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
        requestAnimationFrame(() => {
          container.style.transition = `transform ${duration}ms var(--ddr-fast-ease)`;
          container.style.transform = 'translate(0, 0)';
        });
        setTimeout(() => {
          container.style.transition = '';
          container.style.transform = '';
          container.classList.remove('masonry-reflow');
        }, duration + 40);
      });
    }

    function ensureImageIdForPath(path) {
      const normalized = normalizeImagePath(path);
      if (!normalized) return null;
      if (pathToImageId.has(normalized)) {
        return pathToImageId.get(normalized);
      }
      const id = `img_${imageIdCounter++}`;
      pathToImageId.set(normalized, id);
      imageIdToPath.set(id, normalized);
      return id;
    }

    function getImageIdForPath(path) {
      const normalized = normalizeImagePath(path);
      return normalized ? pathToImageId.get(normalized) || null : null;
    }

    function updateImagePathById(oldPath, newPath) {
      const oldNorm = normalizeImagePath(oldPath);
      const newNorm = normalizeImagePath(newPath);
      if (!newNorm) return null;

      let id = oldNorm ? pathToImageId.get(oldNorm) : null;
      if (!id) id = ensureImageIdForPath(newNorm);
      if (!id) return null;

      if (oldNorm) pathToImageId.delete(oldNorm);
      pathToImageId.set(newNorm, id);
      imageIdToPath.set(id, newNorm);
      return id;
    }

    function rebuildImageIdentityMaps(imageList) {
      const previousPathToId = new Map(pathToImageId);
      const previousIdToPath = new Map(imageIdToPath);
      pathToImageId = new Map();
      imageIdToPath = new Map();

      imageList.forEach(path => {
        const normalized = normalizeImagePath(path);
        if (!normalized) return;
        const existingId = previousPathToId.get(normalized);
        if (existingId) {
          pathToImageId.set(normalized, existingId);
          imageIdToPath.set(existingId, normalized);
        } else {
          let reused = null;
          const baseName = getFilenameOnly(normalized);
          if (baseName) {
            for (const [id, oldPath] of previousIdToPath.entries()) {
              if (getFilenameOnly(oldPath) === baseName && !imageIdToPath.has(id)) {
                reused = id;
                break;
              }
            }
          }
          const id = reused || `img_${imageIdCounter++}`;
          pathToImageId.set(normalized, id);
          imageIdToPath.set(id, normalized);
        }
      });
    }

    function removeMissingImageFromState(filename) {
      const normalized = normalizeImagePath(filename);
      if (!normalized) return false;
      const staleId = pathToImageId.get(normalized);

      let removed = false;
      const indexInAll = allImageFiles.indexOf(normalized);
      if (indexInAll !== -1) {
        allImageFiles.splice(indexInAll, 1);
        removed = true;
      }

      const indexInFiltered = filteredImageFiles.indexOf(normalized);
      if (indexInFiltered !== -1) {
        filteredImageFiles.splice(indexInFiltered, 1);
        removed = true;
      }

      imageSearchIndex.delete(normalized);
      imageDimensionsCache.delete(normalized);
      imageDates.delete(normalized);
      imageMetadataCache.delete(normalized);
      pathToImageId.delete(normalized);
      if (staleId) imageIdToPath.delete(staleId);

      return removed;
    }
    let imageDates = new Map(); // Cache file dates
    let imageMetadataCache = new Map(); // Cache PNG metadata to avoid re-fetching
    let imageSearchIndex = new Map(); // Index for search: filename -> {model, prompt}
    let imageDimensionsCache = new Map(); // Cache image dimensions: filename -> {width, height}
    let metadataFetchInProgress = false; // Track if fetch is currently running
    
    // Function to log actions to the server
    function logToServer(action, details) {
      fetch('/log-action', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action, details, timestamp: new Date().toISOString() })
      }).catch(() => {}); // Ignore errors for logging
    }
    
    // Unified progress status management
    let currentProcessingState = null;
    let processingStatusQueue = [];
    
    function updateProcessingStatus(message, isActive = false) {
      const statusEl = document.getElementById('processingStatus');
      const indicatorEl = document.getElementById('processingIndicator');
      const bottomNav = document.getElementById('bottomNav');
      if (!statusEl || !indicatorEl || !bottomNav) return;
      
      // Update status text and indicator
      if (message && isActive) {
        statusEl.textContent = message;
        statusEl.classList.add('active');
        indicatorEl.classList.add('active');
        bottomNav.classList.remove('hidden'); // Ensure bottom nav is available
      } else if (message) {
        statusEl.textContent = message;
        statusEl.classList.remove('active');
        indicatorEl.classList.remove('active');
        bottomNav.classList.remove('hidden');
      } else {
        statusEl.textContent = '';
        statusEl.classList.remove('active');
        indicatorEl.classList.remove('active');
        // Don't add 'hidden' - let updateBarsVisibility control visibility
      }
      
      // Update bar visibility based on current state
      // Use requestAnimationFrame to prevent scroll jumps from layout shifts
      if (typeof window.updateBarsVisibility === 'function') {
        // Capture scroll position before bar visibility update
        const scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop;
        const scrollX = window.scrollX || window.pageXOffset || document.documentElement.scrollLeft;
        
        window.updateBarsVisibility();
        
        // Restore scroll position immediately after bar visibility update
        // This prevents browser auto-scroll from layout shifts when bars show/hide
        requestAnimationFrame(() => {
          window.scrollTo(scrollX, scrollY);
          document.documentElement.scrollTop = scrollY;
          document.documentElement.scrollLeft = scrollX;
          if (document.body.scrollTop !== undefined) {
            document.body.scrollTop = scrollY;
          }
          if (document.body.scrollLeft !== undefined) {
            document.body.scrollLeft = scrollX;
          }
        });
      }
    }
    
    function clearProcessingStatus() {
      // Simply clear status - updateBarsVisibility will handle hiding bars
      updateProcessingStatus('');
    }
    
    // Update model filter buttons to show indexing state (simplified - no animation)
    function updateModelFilterButtonsState(isIndexing, progress = null) {
      const btns = document.querySelectorAll('.model-filter-btn');
      const statusEl = document.querySelector('.model-filters-status');
      
      if (isIndexing) {
        btns.forEach(btn => btn.classList.add('indexing'));
        // Status now shown in bottom left progress indicator
        if (statusEl) {
          statusEl.textContent = '';
        }
      } else {
        btns.forEach(btn => btn.classList.remove('indexing'));
        if (statusEl) {
          statusEl.textContent = '';
        }
      }
    }
    
    // Function to fetch metadata for a target set (default: current page)
    async function fetchAllImageMetadata(isBackground = false, targetFiles = null) {
      const requestedFiles = Array.isArray(targetFiles) && targetFiles.length > 0
        ? targetFiles
        : getCurrentPageFiles();
      const uniqueRequestedFiles = [...new Set(requestedFiles)];
      
      if (metadataFetchInProgress) {
        debugLog('[Model Filter] Fetch already in progress, waiting...');
        // Wait for existing fetch to complete
        while (metadataFetchInProgress) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        return;
      }
      
      metadataFetchInProgress = true;
      
      try {
        const unindexedFiles = uniqueRequestedFiles.filter(f => !imageSearchIndex.has(f));
        const total = unindexedFiles.length;
        debugLog(`[Model Filter] ${isBackground ? 'Background indexing' : 'Fetching'} metadata for ${total} active-page images...`);
        logToServer('metadata_fetch_start', { count: total, background: isBackground });
        
        if (total === 0) {
          metadataFetchInProgress = false;
          updateModelFilterButtonsState(false);
          debugLog('[Model Filter] Active-page images already indexed');
          return;
        }
        
        // Show indexing state
        updateModelFilterButtonsState(true, 0);
        if (!isBackground) {
          updateProcessingStatus('Loading metadata...', true);
        }
        
        // Fetch metadata in batches to avoid overwhelming the browser
        const BATCH_SIZE = isBackground ? 10 : 20; // Smaller batches for background
        let processed = 0;
        let errors = 0;
        
        for (let i = 0; i < unindexedFiles.length; i += BATCH_SIZE) {
          const batch = unindexedFiles.slice(i, i + BATCH_SIZE);
          
          const results = await Promise.allSettled(batch.map(async (filename) => {
            if (imageSearchIndex.has(filename)) return { skipped: true };
            
            const url = escapeFilename(filename);
            const metadata = await getPngMetadata(url);
            const displayData = formatMetadataForDisplay(metadata);
            
            const model = (displayData['Model'] || '').toLowerCase();
            imageSearchIndex.set(filename, {
              model: model,
              prompt: (displayData['Prompt'] || '').toLowerCase()
            });
            
            return { filename, model };
          }));
          
          // Process results
          results.forEach((result, idx) => {
            if (result.status === 'fulfilled') {
              if (!result.value?.skipped) processed++;
            } else {
              errors++;
              const filename = batch[idx];
              // Store empty data for failed extractions
              if (!imageSearchIndex.has(filename)) {
                imageSearchIndex.set(filename, { model: '', prompt: '' });
              }
            }
          });
          
          // Update progress - use the same loading bar as image loading
          const progressPct = Math.round(((i + batch.length) / total) * 100);
          updateModelFilterButtonsState(true, progressPct);
          
          // Update loading bar for metadata processing
          const loadingBarFill = document.getElementById('loadingBarFill');
          const loadingBarContainer = document.getElementById('loadingBarContainer');
          const loadingPercentage = document.getElementById('loadingPercentage');
          if (loadingBarFill && loadingBarContainer) {
            loadingBarFill.style.width = progressPct + '%';
            loadingBarContainer.classList.remove('hidden');
            // Hide the percentage text during metadata processing (same as image loading)
            if (loadingPercentage) {
              loadingPercentage.style.display = 'none';
            }
          }
          
          // Update status text only (minimal change - text content doesn't affect layout)
          // DON'T call updateProcessingStatus - it calls updateBarsVisibility which causes layout shifts
          const statusEl = document.getElementById('processingStatus');
          if (statusEl) {
            if (!isBackground) {
              statusEl.textContent = `Processing Metadata: ${progressPct}%`;
              statusEl.classList.add('active');
            } else if (i === 0 || (i + BATCH_SIZE) % 50 === 0 || i + BATCH_SIZE >= total) {
              // Show background progress less frequently
              statusEl.textContent = `Processing Metadata: ${progressPct}%`;
              statusEl.classList.add('active');
            }
          }
          const indicatorEl = document.getElementById('processingIndicator');
          if (indicatorEl) {
            indicatorEl.classList.add('active');
          }
          
          // DON'T call updateBarsVisibility during metadata processing - it manipulates DOM
          // Bars will be updated when processing completes
          
          if ((i + BATCH_SIZE) % 100 === 0 || i + BATCH_SIZE >= total) {
            debugLog(`[Model Filter] Processed ${Math.min(i + BATCH_SIZE, total)}/${total} (${errors} errors)`);
          }
          
          // Yield to browser for background processing
          if (isBackground) {
            await new Promise(resolve => setTimeout(resolve, 10));
          }
        }
        
        updateModelFilterButtonsState(false);
        
        // Hide loading bar when metadata processing is complete (always hide, regardless of background)
        // MINIMAL DOM changes - defer to avoid layout shifts
        setTimeout(() => {
          const loadingBarContainer = document.getElementById('loadingBarContainer');
          const loadingPercentage = document.getElementById('loadingPercentage');
          if (loadingBarContainer) {
            loadingBarContainer.classList.add('hidden');
            // Restore percentage display for future use
            if (loadingPercentage) {
              loadingPercentage.style.display = '';
              loadingPercentage.textContent = '0%';
            }
          }
          
          // Clear processing status (minimal DOM changes)
          const statusEl = document.getElementById('processingStatus');
          const indicatorEl = document.getElementById('processingIndicator');
          if (statusEl) {
            statusEl.textContent = '';
            statusEl.classList.remove('active');
          }
          if (indicatorEl) {
            indicatorEl.classList.remove('active');
          }
          
          // Update bars visibility (deferred to avoid layout shift)
          setTimeout(() => {
            if (typeof window.updateBarsVisibility === 'function') {
              window.updateBarsVisibility();
            }
          }, 100);
        }, 100);
        debugLog(`[Model Filter] Complete: ${processed} indexed, ${errors} errors`);
        logToServer('metadata_fetch_complete', { indexed: processed, errors, background: isBackground });
        
      } catch (err) {
        console.error('[Model Filter] Fatal error during metadata fetch:', err);
        logToServer('metadata_fetch_error', { error: err.message });
        updateModelFilterButtonsState(false);
      } finally {
        metadataFetchInProgress = false;
      }
    }
    
    let initialPageLoaded = false; // Track if first page has finished loading
    let layoutCache = null; // Cache for layout calculations
    let resizeThrottle = null; // Throttle for resize events
    let searchDebounce = null; // Debounce for search input
    
    // Helper: Get image dimensions (cached or fetch)
    async function getImageDimensions(filename) {
      if (imageDimensionsCache.has(filename)) {
        return imageDimensionsCache.get(filename);
      }
      
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const dims = { width: img.naturalWidth, height: img.naturalHeight };
          imageDimensionsCache.set(filename, dims);
          resolve(dims);
        };
        img.onerror = () => {
          // Default dimensions if can't load (file doesn't exist - 404 is expected for missing files)
          // Silently handle - don't log errors for missing files as this is normal
          const dims = { width: 600, height: 600 };
          imageDimensionsCache.set(filename, dims);
          resolve(dims);
        };
        img.src = escapeFilename(filename);
      });
    }
    
    // Helper: Calculate placeholder height from dimensions
    function calculatePlaceholderHeight(dims, maxWidth) {
      if (!dims || !dims.width || !dims.height) return 200;
      const aspectRatio = dims.height / dims.width;
      return Math.max(150, Math.min(800, maxWidth * aspectRatio));
    }
    
    
    // Pagination state
    let currentPage = 1;
    let imagesPerPage = PAGING_SETTINGS.default;
    let filteredImageFiles = []; // Images after filtering
    function getCurrentPageFiles() {
      const startIndex = (currentPage - 1) * imagesPerPage;
      const endIndex = Math.min(startIndex + imagesPerPage, filteredImageFiles.length);
      return filteredImageFiles.slice(startIndex, endIndex);
    }
    
    // Favorite functionality
    function getFavoritesFolderPath(filename) {
      // Always put Favorites in the root of the gallery folder
      const pathParts = filename.split(/[/\\]/);
      const fileName = pathParts.pop();
      // Return just "Favorites/filename" (root level)
      return 'Favorites/' + fileName;
    }
    
    function getTodayDateFolder() {
      // Get today's date in yyyy-mm-dd format
      const today = new Date();
      const year = today.getFullYear();
      const month = String(today.getMonth() + 1).padStart(2, '0');
      const day = String(today.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }
    
    function getOriginalPathFromFavorites(favoritesPath) {
      // First check if we have it in history (localStorage)
      const historyPath = getOriginalPathFromHistory(favoritesPath);
      if (historyPath) {
        return historyPath;
      }
      
      // If no history exists, use today's date folder (yyyy-mm-dd) as fallback
      const pathParts = favoritesPath.split(/[/\\]/);
      const fileName = pathParts.pop();
      
      // Check if history exists in localStorage
      const hasHistory = localStorage.getItem(HISTORY_STORAGE_KEY) !== null;
      
      if (hasHistory) {
        // History exists but this entry is missing - use today's date folder
        // This handles images that were favorited before history tracking was added
        const todayFolder = getTodayDateFolder();
        return `${todayFolder}/${fileName}`;
        } else {
        // No history exists at all - use today's date folder as default
        const todayFolder = getTodayDateFolder();
        return `${todayFolder}/${fileName}`;
      }
    }
    
    async function toggleFavorite(filename, starButton) {
      const actionScrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
      try {
        const container = starButton ? starButton.closest('.img-container') : null;
        const lightboxStarButton = document.getElementById('lightboxStarButton');
        filename = resolveCurrentFilename(filename, starButton, container, lightboxStarButton);
        
        const isCurrentlyFavorited = filename.startsWith('Favorites/') || 
                                     filename.includes('/Favorites/');
        let newPath, oldPath;
        
        if (isCurrentlyFavorited) {
          // Remove from favorites - move back to original location
          // The file is currently at: filename (e.g., "Favorites/image.jpg")
          oldPath = filename;
          
          // Get original path from history (localStorage) or construct it
          const historyPath = getOriginalPathFromHistory(filename);
          if (historyPath) {
            newPath = historyPath.replace(/\\/g, '/');
            debugLog('Unfavoriting: Using history path', oldPath, '->', newPath);
          } else {
            newPath = getOriginalPathFromFavorites(filename).replace(/\\/g, '/');
            debugLog('Unfavoriting: Using fallback path', oldPath, '->', newPath);
          }
          // Remove from history
          removeFromHistory(filename);
        } else {
          // Add to favorites
          // The file is currently at: filename (e.g., "2025-11-17/image.jpg")
          oldPath = filename;
          newPath = getFavoritesFolderPath(filename).replace(/\\/g, '/');
          debugLog('Favoriting: Moving', oldPath, '->', newPath);
          // Store original path in history (localStorage)
          addToHistory(newPath, oldPath);
        }
        
        debugLog('Moving file:', { oldPath, newPath });
        
        // Use fetch to move the file (this is a server-side operation)
        // Note: This requires server support for file operations
        const response = await fetch('/move-file', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            oldPath: oldPath,
            newPath: newPath
          })
        });
        
        if (response.ok) {
          const imageId = updateImagePathById(oldPath, newPath);
          // Update the star button state immediately
          if (isCurrentlyFavorited) {
            starButton.classList.remove('favorited');
            starButton.setAttribute('data-label', 'Add to Favorites');
          } else {
            starButton.classList.add('favorited');
            starButton.setAttribute('data-label', 'Remove from Favorites');
          }
          
          // Also update lightbox star button if it exists and shows the same file
          if (lightboxStarButton && lightboxStarButton.dataset.filename === oldPath) {
            if (isCurrentlyFavorited) {
              lightboxStarButton.classList.remove('favorited');
              lightboxStarButton.setAttribute('title', 'Add to favorites');
            } else {
              lightboxStarButton.classList.add('favorited');
              lightboxStarButton.setAttribute('title', 'Remove from favorites');
            }
            lightboxStarButton.dataset.filename = newPath;
            if (imageId) lightboxStarButton.dataset.imageId = imageId;
          }
          
          // Update filename in arrays
          const oldIndex = allImageFiles.indexOf(oldPath);
          if (oldIndex !== -1) {
            allImageFiles[oldIndex] = newPath;
          }
          
          const filteredIndex = filteredImageFiles.indexOf(oldPath);
          if (filteredIndex !== -1) {
            filteredImageFiles[filteredIndex] = newPath;
          }
          
          // Update all filename references in the UI
          starButton.dataset.filename = newPath;
          if (imageId) starButton.dataset.imageId = imageId;
          const container = starButton.closest('.img-container');
          if (container) {
            container.dataset.filename = newPath;
            if (imageId) container.dataset.imageId = imageId;
            
            // Store the current filename in container for reference
            container.dataset.currentFilename = newPath;
            
            // Update img.src to new path so download/open work correctly
            // The file was moved on the server, so we need to update the URL
            const img = container.querySelector('.image-wrapper img');
            if (img) {
              // Update src to new path - browser will use cached version if available
              const newImageUrl = escapeFilename(newPath);
              // Only update if different to avoid unnecessary changes
              if (img.src !== newImageUrl && !img.src.includes(newPath)) {
                // Always update src to prevent 404 errors when unfavoriting
                img.src = newImageUrl;
              }
            }
            
            // Update download button - replace click handler to use new path
            const downloadBtn = container.querySelector('.image-button[data-label="Download"]');
            if (downloadBtn) {
              // Remove old listener and add new one
              const newDownloadHandler = function(e) {
                e.stopPropagation();
                const a = document.createElement('a');
                a.href = escapeFilename(newPath);
                a.download = getFilenameOnly(newPath);
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
              };
              // Clone button to remove old listeners, then re-add
              const newDownloadBtn = downloadBtn.cloneNode(true);
              newDownloadBtn.addEventListener('click', newDownloadHandler);
              downloadBtn.parentNode.replaceChild(newDownloadBtn, downloadBtn);
            }
            
            // Update open button - replace click handler to use new path
            const openButton = container.querySelector('.image-button[data-label="Open"]');
            if (openButton) {
              const newOpenHandler = function(e) {
                e.stopPropagation();
                window.open(escapeFilename(newPath), '_blank');
              };
              // Clone button to remove old listeners, then re-add
              const newOpenBtn = openButton.cloneNode(true);
              newOpenBtn.addEventListener('click', newOpenHandler);
              openButton.parentNode.replaceChild(newOpenBtn, openButton);
            }
            
            // Update delete button filename reference
            const deleteButton = container.querySelector('.delete-button');
            if (deleteButton) {
              deleteButton.dataset.filename = newPath;
              if (imageId) deleteButton.dataset.imageId = imageId;
            }
            
            // Update rating container filename reference
            const ratingContainer = container.querySelector('.rating-stars');
            if (ratingContainer) {
              ratingContainer.dataset.filename = newPath;
              if (imageId) ratingContainer.dataset.imageId = imageId;
            }
          }
          
          // Update lightbox image if it's showing this file
          const lightboxImg = document.getElementById('lightboxImg');
          if (lightboxImg && lightboxImg.src && lightboxImg.src.includes(escapeFilename(oldPath))) {
            const newImageUrl = escapeFilename(newPath);
            // Always update src to prevent 404 errors when unfavoriting
            lightboxImg.src = newImageUrl;
            // Update the lightbox filename display
            const lightboxFilename = document.getElementById('lightboxFilename');
            if (lightboxFilename) {
              const baseFilename = removeExtension(getFilenameOnly(newPath));
              lightboxFilename.textContent = baseFilename;
            }
          }
          
          // Don't reload - we've updated everything dynamically
        } else {
          // Get the error message from the server
          let errorMessage = 'Failed to update favorite.';
          try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorMessage;
          } catch (e) {
            const errorText = await response.text();
            errorMessage = errorText || errorMessage;
          }
          console.error('Failed to move file:', errorMessage);
          alert('Failed to update favorite: ' + errorMessage);
        }
      } catch (error) {
        console.error('Error toggling favorite:', error);
        alert('Error updating favorite: ' + error.message);
      } finally {
        restoreScrollPositionStable(actionScrollY);
      }
    }
    
    // Rating functions
    function updateRatingDisplay(ratingContainer, rating) {
      // Update visual state of stars (1-5, or 0 for no rating)
      // Works for both thumbnail (.rating-star) and lightbox (.lightbox-rating-star) stars
      // Stars are in reverse order: top = 5, bottom = 1
      if (!ratingContainer) return;
      
      const stars = Array.from(ratingContainer.querySelectorAll('.rating-star, .lightbox-rating-star'));
      // Stars are created in reverse order (5 to 1), so reverse array to get correct order
      stars.reverse();
      
      stars.forEach((star, index) => {
        const starValue = index + 1; // Now index 0 = star 1, index 4 = star 5
        const starRating = parseInt(star.dataset.rating, 10);
        if (starRating <= rating) {
          star.classList.add('active');
        } else {
          star.classList.remove('active');
        }
      });
    }
    
    async function setRating(filename, rating, ratingContainer, container) {
      const actionScrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
      try {
        filename = resolveCurrentFilename(filename, container, ratingContainer);
        
        // Get current filename (may have existing rating)
        const currentRating = parseRatingFromFilename(filename);
        
        // If clicking the same rating, remove it (toggle off)
        const newRating = (currentRating === rating) ? 0 : rating;
        
        // Generate new filename with rating
        // Always remove existing rating first, then add new one if needed
        let baseFilename = removeRatingFromFilename(filename);
        let newPath;
        if (newRating === 0) {
          // Remove rating - baseFilename already has rating removed
          newPath = baseFilename;
        } else {
          // Add new rating to base filename (without existing rating)
          newPath = addRatingToFilename(baseFilename, newRating);
        }
        
        const oldPath = filename;
        
        // If path hasn't changed, nothing to do
        if (oldPath === newPath) {
          debugLog('Rating unchanged, skipping rename:', { oldPath, newPath, currentRating, newRating });
          return;
        }
        
        debugLog('Setting rating:', { oldPath, newPath, currentRating, newRating, baseFilename });
        
        // Use fetch to rename the file (server-side operation)
        const response = await fetch('/move-file', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            oldPath: oldPath,
            newPath: newPath
          })
        });
        
        if (response.ok) {
          const imageId = updateImagePathById(oldPath, newPath);
          // Update rating display
          updateRatingDisplay(ratingContainer, newRating);
          ratingContainer.dataset.filename = newPath;
          if (imageId && ratingContainer) ratingContainer.dataset.imageId = imageId;
          
          // Update filename in arrays
          const oldIndex = allImageFiles.indexOf(oldPath);
          if (oldIndex !== -1) {
            allImageFiles[oldIndex] = newPath;
          }
          
          const filteredIndex = filteredImageFiles.indexOf(oldPath);
          if (filteredIndex !== -1) {
            filteredImageFiles[filteredIndex] = newPath;
          }
          
          // Update all filename references in the UI (similar to favorites)
          if (container) {
            container.dataset.filename = newPath;
            if (imageId) container.dataset.imageId = imageId;
            
            // Update img.src to new path
            const img = container.querySelector('.image-wrapper img');
            if (img) {
              const newImageUrl = escapeFilename(newPath);
              if (img.src !== newImageUrl && !img.src.includes(newPath)) {
                img.src = newImageUrl;
              }
            }
            
            // Update download button
            const downloadBtn = container.querySelector('.image-button[data-label="Download"]');
            if (downloadBtn) {
              downloadBtn.dataset.filename = newPath;
              const newDownloadBtn = downloadBtn.cloneNode(true);
              newDownloadBtn.dataset.filename = newPath;
              newDownloadBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                const a = document.createElement('a');
                a.href = escapeFilename(newPath);
                a.download = getFilenameOnly(newPath);
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
              });
              downloadBtn.parentNode.replaceChild(newDownloadBtn, downloadBtn);
            }
            
            // Update open button
            const openButton = container.querySelector('.image-button[data-label="Open"]');
            if (openButton) {
              openButton.dataset.filename = newPath;
              const newOpenBtn = openButton.cloneNode(true);
              newOpenBtn.dataset.filename = newPath;
              newOpenBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                window.open(escapeFilename(newPath), '_blank');
              });
              openButton.parentNode.replaceChild(newOpenBtn, openButton);
            }
            
            // Update star button
            const starButton = container.querySelector('.star-button');
            if (starButton) {
              starButton.dataset.filename = newPath;
              if (imageId) starButton.dataset.imageId = imageId;
            }
            
            // Update delete button
            const deleteButton = container.querySelector('.delete-button');
            if (deleteButton) {
              deleteButton.dataset.filename = newPath;
              if (imageId) deleteButton.dataset.imageId = imageId;
            }
          }
          
          // Update lightbox rating if it's showing this file
          const lightboxRatingContainer = document.getElementById('lightboxRatingStars');
          const lightboxImg = document.getElementById('lightboxImg');
          if (lightboxRatingContainer && lightboxImg && lightboxImg.src && lightboxImg.src.includes(escapeFilename(oldPath))) {
            updateRatingDisplay(lightboxRatingContainer, newRating);
            lightboxRatingContainer.dataset.filename = newPath;
            if (imageId) lightboxRatingContainer.dataset.imageId = imageId;
          }
          
          // Update lightbox image if it's showing this file
          if (lightboxImg && lightboxImg.src && lightboxImg.src.includes(escapeFilename(oldPath))) {
            const newImageUrl = escapeFilename(newPath);
            lightboxImg.src = newImageUrl;
            const lightboxStarButton = document.getElementById('lightboxStarButton');
            if (lightboxStarButton) {
              lightboxStarButton.dataset.filename = newPath;
              if (imageId) lightboxStarButton.dataset.imageId = imageId;
            }
          }
          
        } else {
          const errorData = await response.json().catch(() => ({ error: 'Failed to update rating' }));
          console.error('Failed to update rating:', errorData.error);
          alert('Failed to update rating: ' + (errorData.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Error setting rating:', error);
        alert('Error updating rating: ' + error.message);
      } finally {
        restoreScrollPositionStable(actionScrollY);
      }
    }
    
    // Show custom delete confirmation modal (returns Promise<boolean>)
    function showDeleteConfirmModal(filename) {
      return new Promise((resolve) => {
        const modal = document.getElementById('deleteConfirmModal');
        const dialog = document.getElementById('deleteConfirmDialog');
        const filenameEl = document.getElementById('deleteConfirmFilename');
        const cancelBtn = document.getElementById('deleteConfirmCancel');
        const deleteBtn = document.getElementById('deleteConfirmDelete');
        
        if (!modal || !dialog || !filenameEl || !cancelBtn || !deleteBtn) {
          // Fallback to browser confirm if modal elements not found
          resolve(confirm(`Are you sure you want to delete this image?\n\n${filename}\n\nThis action cannot be undone.`));
          return;
        }
        
        // Set filename (truncate if too long)
        const displayFilename = filename.length > 60 ? filename.substring(0, 57) + '...' : filename;
        filenameEl.textContent = displayFilename;
        filenameEl.title = filename; // Full filename in tooltip
        
        const modalScrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;

        // Show modal
        modal.classList.add('active');
        
        // Lock body scroll without resetting page position.
        document.body.style.position = 'fixed';
        document.body.style.top = `-${modalScrollY}px`;
        document.body.style.left = '0';
        document.body.style.right = '0';
        document.body.style.width = '100%';
        document.body.style.overflow = 'hidden';
        
        // Cleanup function
        const cleanup = () => {
          modal.classList.remove('active');
          const previousTop = document.body.style.top;
          const restoreY = previousTop ? Math.abs(parseInt(previousTop, 10) || 0) : modalScrollY;
          document.body.style.position = '';
          document.body.style.top = '';
          document.body.style.left = '';
          document.body.style.right = '';
          document.body.style.width = '';
          document.body.style.overflow = '';
          restoreScrollPositionStable(restoreY);
          // Remove event listeners
          cancelBtn.removeEventListener('click', handleCancel);
          deleteBtn.removeEventListener('click', handleDelete);
          modal.removeEventListener('click', handleBackdropClick);
          document.removeEventListener('keydown', handleEscape);
        };
        
        // Event handlers
        const handleCancel = (e) => {
          e.stopPropagation();
          cleanup();
          resolve(false);
        };
        
        const handleDelete = (e) => {
          e.stopPropagation();
          cleanup();
          resolve(true);
        };
        
        const handleBackdropClick = (e) => {
          // Only close if clicking the backdrop, not the dialog
          if (e.target === modal) {
            cleanup();
            resolve(false);
          }
        };
        
        const handleEscape = (e) => {
          if (e.key === 'Escape') {
            cleanup();
            resolve(false);
          }
        };
        
        // Attach event listeners
        cancelBtn.addEventListener('click', handleCancel);
        deleteBtn.addEventListener('click', handleDelete);
        modal.addEventListener('click', handleBackdropClick);
        document.addEventListener('keydown', handleEscape);
        
        // Focus the cancel button for keyboard navigation
        cancelBtn.focus();
      });
    }
    
    let armedDeleteButton = null;
    let armedDeleteTimeout = null;

    function clearArmedDeleteButton() {
      if (armedDeleteTimeout) {
        clearTimeout(armedDeleteTimeout);
        armedDeleteTimeout = null;
      }
      if (armedDeleteButton) {
        armedDeleteButton.classList.remove('armed');
        armedDeleteButton.setAttribute('data-label', 'Delete');
        armedDeleteButton = null;
      }
    }
    document.addEventListener('click', function(e) {
      const clickedDeleteButton = e.target && e.target.closest && e.target.closest('.delete-button');
      if (!clickedDeleteButton) {
        clearArmedDeleteButton();
      }
    });

    // Delete image function with smooth remove + masonry reflow.
    async function deleteImage(filename, container) {
      const actionScrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
      
      try {
        filename = resolveCurrentFilename(filename, container);

        container.style.pointerEvents = 'none';
        const buttons = container.querySelectorAll('button');
        buttons.forEach(btn => {
          btn.disabled = true;
          btn.style.pointerEvents = 'none';
          btn.style.opacity = '0.35';
        });

        const response = await fetch('/delete-file', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            filePath: filename
          })
        });
        
        if (response.ok) {
          const deletedImageId = getImageIdForPath(filename);

          const indexInAll = allImageFiles.indexOf(filename);
          if (indexInAll !== -1) {
            allImageFiles.splice(indexInAll, 1);
          }
          
          const indexInFiltered = filteredImageFiles.indexOf(filename);
          if (indexInFiltered !== -1) {
            filteredImageFiles.splice(indexInFiltered, 1);
          }
          
          imageSearchIndex.delete(filename);
          imageDimensionsCache.delete(filename);
          imageMetadataCache.delete(filename);
          imageDates.delete(filename);
          pathToImageId.delete(filename);
          if (deletedImageId) {
            imageIdToPath.delete(deletedImageId);
          }

          const lightbox = document.getElementById('lightbox');
          if (lightbox && lightbox.classList.contains('active')) {
            const lightboxImg = document.getElementById('lightboxImg');
            if (lightboxImg && lightboxImg.src && lightboxImg.src.includes(escapeFilename(filename))) {
              hideLightbox();
            }
          }

          // Capture current container positions, animate the deleted card out,
          // then relayout and animate surviving cards into place.
          const otherContainers = allImageContainers.filter(c => c && c !== container && c.isConnected);
          const previousPositions = captureContainerPositions(otherContainers);
          await animateContainerRemoval(container);

          if (container.parentNode) {
            container.parentNode.removeChild(container);
          }
          allImageContainers = allImageContainers.filter(c => c !== container);
          layoutCache = null;
          layoutMasonry();
          animateMasonryReflowFrom(previousPositions);

          updateImageCount();
          updatePaginationUI();
        } else {
          container.classList.remove('removing');
          container.style.pointerEvents = '';
          container.style.height = '';
          container.style.maxHeight = '';
          container.style.marginBottom = '';
          buttons.forEach(btn => {
            btn.disabled = false;
            btn.style.pointerEvents = '';
            btn.style.opacity = '';
          });
          
          let errorMessage = 'Failed to delete image.';
          try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorMessage;
          } catch (e) {
            const errorText = await response.text();
            errorMessage = errorText || errorMessage;
          }
          console.error('Failed to delete file:', errorMessage);
          alert('Failed to delete image: ' + errorMessage);
        }
      } catch (error) {
        container.classList.remove('removing');
        container.style.pointerEvents = '';
        container.style.height = '';
        container.style.maxHeight = '';
        container.style.marginBottom = '';
        const buttons = container.querySelectorAll('button');
        buttons.forEach(btn => {
          btn.disabled = false;
          btn.style.pointerEvents = '';
          btn.style.opacity = '';
        });
        
        console.error('Error deleting image:', error);
        alert('Error deleting image: ' + error.message);
      } finally {
        clearArmedDeleteButton();
        restoreScrollPositionStable(actionScrollY);
      }
    }
    
    function isFavorited(filename) {
      return filename.startsWith('Favorites/') || 
             filename.startsWith('Favorites\\') ||
             filename.includes('/Favorites/') || 
             filename.includes('\\Favorites\\');
    }

    function layoutMasonry() {
      const gallery = document.getElementById('gallery');
      if (!gallery) return;
      
      // Validate containers exist
      if (!allImageContainers || allImageContainers.length === 0) {
        return;
      }
      
      const galleryWidth = gallery.offsetWidth;
      if (galleryWidth === 0) {
        // Gallery not visible yet, retry after a short delay
        setTimeout(layoutMasonry, 100);
        return;
      }
      
      const columnWidth = baseColumnWidth * currentSizeMultiplier;
      const columnGap = 8;
      const numColumns = Math.max(1, Math.floor((galleryWidth + columnGap) / (columnWidth + columnGap)));
      
      // Use cached layout if dimensions haven't changed
      // Include container count and actual container references to detect changes
      const layoutKey = `${galleryWidth}-${columnWidth}-${numColumns}-${allImageContainers.length}`;
      // Check if layout cache is still valid (same key AND same container array reference)
      if (layoutCache && layoutCache.key === layoutKey && layoutCache.containers === allImageContainers) {
        return; // Skip if layout is the same
      }
      // Update cache with new layout key and container reference
      layoutCache = { key: layoutKey, containers: allImageContainers };
      
      // DON'T preserve scroll during layout - layout happens before user sees anything
      // Only preserve scroll if user is already viewing the page (not initial load)
      const shouldPreserveScroll = initialPageLoaded;
      let scrollY = 0;
      let scrollX = 0;
      
      if (shouldPreserveScroll) {
        // Capture scroll position before layout changes
        scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        scrollX = window.scrollX || window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
      }
      
      // Clear existing columns but preserve containers
      // Remove containers from columns first to avoid DOM issues
      // This is critical when sizes change - ensures clean slate
      allImageContainers.forEach(container => {
        if (container.parentNode) {
          container.parentNode.removeChild(container);
        }
      });
      
      // Completely clear gallery and reset column heights
      // First, explicitly reset any height styles on existing columns
      galleryColumns.forEach(col => {
        if (col.element && col.element.parentNode) {
          col.element.style.height = 'auto';
          col.element.style.minHeight = '0';
        }
      });
      
      gallery.innerHTML = '';
      galleryColumns = [];
      
      // Force a reflow to ensure DOM is cleared before rebuilding
      void gallery.offsetHeight;
      
      // Also reset gallery container height if it was set
      gallery.style.height = 'auto';
      gallery.style.minHeight = '0';
      
      // Create columns
      for (let i = 0; i < numColumns; i++) {
        const column = document.createElement('div');
        column.className = 'gallery-column';
        column.style.width = columnWidth + 'px';
        column.style.marginRight = (i < numColumns - 1) ? columnGap + 'px' : '0';
        // Explicitly reset height to ensure clean slate
        column.style.height = 'auto';
        column.style.minHeight = '0';
        gallery.appendChild(column);
        galleryColumns.push({
          element: column,
          height: 0
        });
      }
      
      // Distribute all containers into columns (all containers are visible for current page)
      // Optimized: batch DOM operations and minimize reflows
      const marginBottom = 7; // Match CSS margin-bottom
      
      for (let i = 0; i < allImageContainers.length; i++) {
        const container = allImageContainers[i];
        
        // Find the shortest column (optimized with early exit)
        let shortestIndex = 0;
        let shortestHeight = galleryColumns[0].height;
        for (let j = 1; j < galleryColumns.length; j++) {
          if (galleryColumns[j].height < shortestHeight) {
            shortestIndex = j;
            shortestHeight = galleryColumns[j].height;
          }
        }
        
        const shortestColumn = galleryColumns[shortestIndex];
        
        // Add container to shortest column
        shortestColumn.element.appendChild(container);
        
        // Force a single reflow to ensure layout is calculated
        const containerHeight = container.offsetHeight || container.getBoundingClientRect().height;
        const totalHeight = containerHeight + marginBottom;
        
        if (totalHeight > 0) {
          galleryColumns[shortestIndex].height += totalHeight;
        }
        
        // Ensure column element doesn't have a fixed height that would prevent shrinking
        shortestColumn.element.style.height = 'auto';
      }
      
      // RESTORE SCROLL POSITION after layout is complete (only if preserving)
      if (shouldPreserveScroll && scrollY > 0) {
        // Restore scroll position after layout completes
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            // Restore to captured position
            window.scrollTo(scrollX, scrollY);
            if (document.documentElement.scrollTop !== undefined) {
              document.documentElement.scrollTop = scrollY;
            }
            if (document.body.scrollTop !== undefined) {
              document.body.scrollTop = scrollY;
            }
          });
        });
      }
    }

    // Cache for total file size
    let totalFileSizeCache = null;
    let totalFileSizeCacheTime = 0;
    let totalFileSizeCacheKey = null; // Track which file list was cached
    const TOTAL_FILE_SIZE_CACHE_DURATION = 60000; // 1 minute
    
    async function calculateTotalFileSize() {
      // Create a cache key based on current filtered files
      const currentCacheKey = filteredImageFiles.length > 0 
        ? filteredImageFiles.slice(0, 10).join(',') + filteredImageFiles.length 
        : 'all';
      
      // Use cache if available, recent, and for the same file list
      const now = Date.now();
      if (totalFileSizeCache !== null && 
          (now - totalFileSizeCacheTime) < TOTAL_FILE_SIZE_CACHE_DURATION &&
          totalFileSizeCacheKey === currentCacheKey) {
        return totalFileSizeCache;
      }
      
      // Calculate total size by fetching HEAD requests for all images
      let totalBytes = 0;
      const filesToCheck = filteredImageFiles.length > 0 ? filteredImageFiles : allImageFiles;
      
      // Limit concurrent requests to avoid overwhelming the server
      const BATCH_SIZE = 10;
      for (let i = 0; i < filesToCheck.length; i += BATCH_SIZE) {
        const batch = filesToCheck.slice(i, i + BATCH_SIZE);
        const promises = batch.map(async (filename) => {
          try {
            const response = await fetch(escapeFilename(filename), { method: 'HEAD' });
            const contentLength = response.headers.get('Content-Length');
            if (contentLength) {
              return parseInt(contentLength, 10);
            }
          } catch (e) {
            // Ignore errors - file might not exist or server might not support HEAD
          }
          return 0;
        });
        
        const sizes = await Promise.allSettled(promises);
        sizes.forEach(result => {
          if (result.status === 'fulfilled') {
            totalBytes += result.value;
          }
        });
      }
      
      totalFileSizeCache = totalBytes;
      totalFileSizeCacheTime = now;
      totalFileSizeCacheKey = currentCacheKey;
      return totalBytes;
    }
    
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 GB';
      const gb = bytes / (1024 * 1024 * 1024);
      return gb.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' GB';
    }
    
    async function updateImageCount(skipSizeCalculation = true) {
      const imageCountEl = document.getElementById('imageCount');
      if (!imageCountEl) return;
      
      // Count total visible images (for pagination, this is filteredImageFiles length)
      const totalVisible = filteredImageFiles.length;
      
      // Calculate page range
      const startIndex = (currentPage - 1) * imagesPerPage;
      const endIndex = Math.min(startIndex + imagesPerPage, totalVisible);
      const startNum = totalVisible > 0 ? startIndex + 1 : 0;
      const endNum = endIndex;
      
      // Calculate total file size (skip during initial load to avoid blocking)
      let sizeText = '';
      if (!skipSizeCalculation) {
        try {
          // Defer size calculation to avoid blocking initial load
          setTimeout(async () => {
            try {
              const totalBytes = await calculateTotalFileSize();
              const formattedSize = formatFileSize(totalBytes);
              if (imageCountEl) {
                const currentText = imageCountEl.innerHTML;
                // Only update if element still exists and hasn't changed
                if (currentText.includes('of')) {
                  imageCountEl.innerHTML = currentText.replace(/\s*\([^)]*\)/, '') + ` (${formattedSize})`;
                }
              }
            } catch (e) {
              // If calculation fails, just show count without size
            }
          }, 1000); // Wait 1 second after initial load to calculate size
        } catch (e) {
          // If calculation fails, just show count without size
        }
      }
      
      imageCountEl.innerHTML = `<span class="count-number">${startNum}-${endNum}</span> of <span class="count-number">${totalVisible}</span>${sizeText}`;
    }
    
    function getTotalPages() {
      return Math.max(1, Math.ceil(filteredImageFiles.length / imagesPerPage));
    }
    
    function updatePaginationUI() {
      const bottomNav = document.getElementById('bottomNav');
      const paginationNumbers = document.getElementById('paginationNumbers');
      const paginationPrev = document.getElementById('paginationPrev');
      const paginationNext = document.getElementById('paginationNext');
      const pageSizeStandalone = document.getElementById('bottomNavPageSizeStandalone');
      if (!bottomNav || !paginationNumbers) return;
      
      const totalPages = getTotalPages();
      
      // Always show bottom nav (even with single page)
      bottomNav.classList.remove('hidden');
      // Don't add 'visible' class here - let mouse proximity handler manage it
      if (pageSizeStandalone) {
        pageSizeStandalone.classList.add('hidden');
      }
      
      // Show/hide pagination arrows and page numbers based on page count
      if (totalPages > 1) {
        // Show arrows and page numbers when there are multiple pages
        if (paginationPrev) {
          paginationPrev.style.display = 'flex';
        }
        if (paginationNext) {
          paginationNext.style.display = 'flex';
        }
        paginationNumbers.style.display = 'flex';
        
        // Clear existing page numbers
        paginationNumbers.innerHTML = '';
        
        // Create page number buttons
        for (let i = 1; i <= totalPages; i++) {
          const pageBtn = document.createElement('button');
          pageBtn.className = 'pagination-number';
          if (i === currentPage) {
            pageBtn.classList.add('active');
          }
          pageBtn.textContent = i;
          pageBtn.addEventListener('click', () => goToPage(i));
          paginationNumbers.appendChild(pageBtn);
        }
      } else {
        // Hide arrows and page numbers when there's only one page
        if (paginationPrev) {
          paginationPrev.style.display = 'none';
        }
        if (paginationNext) {
          paginationNext.style.display = 'none';
        }
        paginationNumbers.style.display = 'none';
        paginationNumbers.innerHTML = '';
      }
    }
    
    function goToPage(page, preserveScroll = false) {
      const totalPages = getTotalPages();
      if (page < 1 || page > totalPages) return;

      updateProcessingStatus(`Loading page ${page} of ${totalPages}...`, true);
      const loadingBarContainer = document.getElementById('loadingBarContainer');
      const loadingBarFill = document.getElementById('loadingBarFill');
      const loadingPercentage = document.getElementById('loadingPercentage');
      if (loadingBarContainer) loadingBarContainer.classList.remove('hidden');
      if (loadingBarFill) loadingBarFill.style.width = '2%';
      if (loadingPercentage) {
        loadingPercentage.style.display = '';
        loadingPercentage.textContent = '2%';
      }
      
      debugLog(`[Page] Going to page ${page}/${totalPages}`);
      logToServer('page_change', { page, totalPages, imagesPerPage });
      
      // Invalidate layout cache when changing pages
      layoutCache = null;
      
      // Only scroll to top if not preserving scroll position (e.g., explicit page navigation)
      // Use requestAnimationFrame to prevent scroll jumps during layout
      if (!preserveScroll) {
        requestAnimationFrame(() => {
      window.scrollTo(0, 0);
      document.documentElement.scrollTop = 0;
      document.body.scrollTop = 0;
        });
      }
      
      currentPage = page;
      updatePaginationUI();
      loadCurrentPage(preserveScroll);
      
      // Avoid duplicate forced scroll-to-top passes; one pass is smoother.
    }
    
    function goToPreviousPage() {
      const totalPages = getTotalPages();
      if (currentPage === 1) {
        goToPage(totalPages); // Wrap to last page
      } else {
        goToPage(currentPage - 1);
      }
    }
    
    function goToNextPage() {
      const totalPages = getTotalPages();
      if (currentPage === totalPages) {
        goToPage(1); // Wrap to first page
      } else {
        goToPage(currentPage + 1);
      }
    }
    
    function loadCurrentPage(preserveScroll = false) {
      const gallery = document.getElementById('gallery');
      if (!gallery) return;
      const pageLoadToken = ++currentPageLoadToken;
      metadataQueue = [];
      
      // Calculate which images to show for current page
      const startIndex = (currentPage - 1) * imagesPerPage;
      const pageFiles = getCurrentPageFiles();
      
      // Show loading bar for page loading
      const loadingBarContainer = document.getElementById('loadingBarContainer');
      const loadingBarFill = document.getElementById('loadingBarFill');
      const loadingPercentage = document.getElementById('loadingPercentage');
      const imageCountEl = document.getElementById('imageCount');
      const loadingScreenImageCount = document.getElementById('loadingScreenImageCount');
      if (!initialPageLoaded && loadingScreenImageCount) {
        loadingScreenImageCount.textContent = `${filteredImageFiles.length.toLocaleString()} Images`;
      }
      
      if (loadingBarContainer && pageFiles.length > 0) {
        loadingBarContainer.classList.remove('hidden');
        // Force bars to show during loading
        if (typeof window.updateBarsVisibility === 'function') {
          window.updateBarsVisibility();
        }
        if (imageCountEl) {
          imageCountEl.style.display = 'none';
        }
        // Initialize loading bar to 0%
        if (loadingBarFill) {
          loadingBarFill.style.width = '2%';
        }
        if (loadingPercentage) {
          loadingPercentage.style.display = '';
          loadingPercentage.textContent = '2%';
        }
      }
      
      // Track loading progress for this page
      let pageImagesLoaded = 0;
      let pageImagesErrored = 0;
      const totalPageImages = pageFiles.length;
      if (totalPageImages > 0) {
        updateProcessingStatus(`Preparing ${totalPageImages} images...`, true);
      }
      
      function updatePageLoadingProgress() {
        if (!loadingBarFill || !loadingPercentage) return;
        const total = pageImagesLoaded + pageImagesErrored;
        const percentage = totalPageImages > 0 ? Math.round((total / totalPageImages) * 100) : 0;
        
        // MINIMAL DOM changes - only update progress bar width (no layout shift)
        loadingBarFill.style.width = percentage + '%';
        // Hide the percentage text and use processing status instead to avoid duplication
        if (loadingPercentage) {
          loadingPercentage.style.display = 'none';
        }
        
        // Update loading screen progress bar (50% to 100% for image loading phase)
        // Update immediately for smooth continuous feedback
        if (loadingScreenProgress && isInitialLoad) {
          const imageLoadingProgress = 50 + (percentage / 100) * 50; // 50% to 100%
          loadingScreenProgress.style.width = imageLoadingProgress + '%';
        }
        
        // Update status text only (minimal change - text content doesn't affect layout)
        const statusEl = document.getElementById('processingStatus');
        if (statusEl) {
          statusEl.textContent = `Loading Images ${total} of ${totalPageImages}`;
          statusEl.classList.add('active');
        }
        const indicatorEl = document.getElementById('processingIndicator');
        if (indicatorEl) {
          indicatorEl.classList.add('active');
        }
        
        // DON'T call updateBarsVisibility during loading - it manipulates DOM and causes layout shifts
        // Bars will be updated when loading completes
        
        // When all images are loaded - MINIMAL changes only
        if (total >= totalPageImages && totalPageImages > 0) {
          // Defer all UI updates to avoid layout shifts
          // Layout is already complete - no need to recalculate
          setTimeout(() => {
            // Hide loading bar (minimal DOM change)
            if (loadingBarContainer) {
              loadingBarContainer.classList.add('hidden');
            }
            // Restore percentage display for future use
            if (loadingPercentage) {
              loadingPercentage.style.display = '';
              loadingPercentage.textContent = '0%';
            }
            // Show image count (deferred to avoid layout shift)
            if (imageCountEl) {
              imageCountEl.style.display = '';
            }
            
            // Clear processing status (minimal DOM changes - no updateBarsVisibility)
            const statusEl = document.getElementById('processingStatus');
            const indicatorEl = document.getElementById('processingIndicator');
            if (statusEl) {
              statusEl.textContent = '';
              statusEl.classList.remove('active');
            }
            if (indicatorEl) {
              indicatorEl.classList.remove('active');
            }
            
            // Update image count (deferred)
            setTimeout(() => {
              updateImageCount();
            }, 100);
            
            // Update bars visibility (deferred to avoid layout shift)
            setTimeout(() => {
              if (typeof window.updateBarsVisibility === 'function') {
                window.updateBarsVisibility();
              }
            }, 100);
            
            // NO layoutMasonry() call - layout is already complete and stable
            // Layout was calculated in PHASE 1 with correct placeholder sizes
            // Images load into existing placeholders without changing layout
              
              if (!initialPageLoaded) {
                initialPageLoaded = true;
              }
          }, 100); // Small delay to batch updates
        }
      }
      
      // Cleanup previous page
      
      // Clear gallery and containers completely
      // Reset any pending layout timeouts to prevent conflicts
      if (typeof window.finalLayoutTimeout !== 'undefined' && window.finalLayoutTimeout) {
        clearTimeout(window.finalLayoutTimeout);
        window.finalLayoutTimeout = null;
      }
      
      gallery.innerHTML = '';
      galleryColumns = [];
      allImageContainers = [];
      
      // PHASE 1: Load ALL dimensions first, then create complete layout
      const loadingScreen = document.getElementById('loadingScreen');
      const loadingScreenMessage = document.getElementById('loadingScreenMessage');
      const loadingScreenProgress = document.getElementById('loadingScreenProgress');
      const isInitialLoad = !initialPageLoaded;
      
      // Check if there are no images to load
      if (pageFiles.length === 0) {
        // Show "No Images To Load..." message on loading screen
        if (isInitialLoad && loadingScreen) {
          loadingScreen.classList.remove('hidden');
        }
        if (loadingScreenMessage) {
          loadingScreenMessage.textContent = 'No Images To Load...';
        }
        if (loadingScreenImageCount) {
          loadingScreenImageCount.textContent = '0 Images';
        }
        if (loadingScreenProgress) {
          loadingScreenProgress.style.width = '0%';
        }
        
        // Hide loading screen after a brief moment
        setTimeout(() => {
          if (loadingScreen) {
            loadingScreen.classList.add('hidden');
          }
          
          // Show "No Images Found" message in gallery
        const noImagesMsg = document.createElement('div');
        noImagesMsg.className = 'no-images-message';
        noImagesMsg.textContent = 'No Images Found';
        gallery.appendChild(noImagesMsg);
        }, 1000);
        
        // Hide loading bar and show image count
        if (loadingBarContainer) {
          loadingBarContainer.classList.add('hidden');
        }
        if (imageCountEl) {
          imageCountEl.style.display = '';
        }
        
        // Clear processing status
        clearProcessingStatus();
        return;
      }
      
      if (isInitialLoad) {
        // Show loading screen for initial load only
        if (loadingScreen) {
          loadingScreen.classList.remove('hidden');
        }
        if (loadingScreenMessage) {
          loadingScreenMessage.textContent = 'Calculating Size, Dimensions, and Layout...';
        }
        if (loadingScreenImageCount) {
          loadingScreenImageCount.textContent = `${filteredImageFiles.length.toLocaleString()} Images`;
        }
        if (loadingScreenProgress) {
          loadingScreenProgress.style.width = '0%';
        }
      }
      
      const maxWidth = baseColumnWidth * currentSizeMultiplier;
      
      // Build placeholders immediately from cached dimensions only.
      // Avoid blocking initial paint on additional dimension preloads.
      const results = pageFiles.map((filename) => ({
        filename,
        dims: imageDimensionsCache.get(filename) || null
      }));
      if (loadingScreenProgress && isInitialLoad) {
        loadingScreenProgress.style.width = '50%';
      }
      if (loadingBarFill) {
        loadingBarFill.style.width = '35%';
      }
      if (loadingPercentage) {
        loadingPercentage.style.display = '';
        loadingPercentage.textContent = '35%';
      }
      if (loadingScreenMessage && isInitialLoad) {
        loadingScreenMessage.textContent = 'Creating layout...';
      }
        
        // Now create all containers with CORRECT placeholder sizes (PHASE 1)
        const containerData = [];
        results.forEach(({ filename, dims }, pageIndex) => {
        // Create new container for this image
        const container = document.createElement('div');
        container.className = 'img-container';
          container.dataset.filename = filename;
          container.dataset.imageId = ensureImageIdForPath(filename) || '';

        const wrapper = document.createElement('div');
        wrapper.className = 'image-wrapper';
        wrapper.style.maxWidth = maxWidth + 'px';
        
          // Calculate CORRECT placeholder height from dimensions (no more updates needed)
          const placeholderHeight = dims ? calculatePlaceholderHeight(dims, maxWidth) : 200;
          wrapper.style.minHeight = placeholderHeight + 'px';
          wrapper.dataset.hasDimensions = 'true';
          wrapper.dataset.layoutComplete = 'true'; // Mark that layout is complete
        
        // Add placeholder shimmer
        const placeholder = document.createElement('div');
        placeholder.className = 'image-placeholder';
        wrapper.appendChild(placeholder);

        const img = document.createElement('img');
        img.style.maxWidth = maxWidth + 'px';
        img.style.opacity = '0'; // Start hidden, will fade in when loaded
        img.decoding = 'async';
        img.loading = 'eager'; // Force eager loading - no lazy loading
        // No lazy loading - we load all images immediately with priority from top to bottom
        
        const baseFilename = removeExtension(getFilenameOnly(filename));
        const label = document.createElement('span');
        label.className = 'filename-label';
        label.textContent = baseFilename;

        // Queue metadata extraction
        let imageLoadHandled = false; // Prevent double-counting
        let loadTimeoutId = null; // Store timeout ID for cleanup
        
        const handleImageLoad = () => {
          if (imageLoadHandled) return; // Prevent double-counting
          imageLoadHandled = true;
          
          // Clear any pending timeout
          if (loadTimeoutId) {
            clearTimeout(loadTimeoutId);
            loadTimeoutId = null;
          }
          
          pageImagesLoaded++;
          updatePageLoadingProgress();
          
          // Smoothly transition from placeholder to image
          // CSS already handles opacity transition, just add loaded class
          // Remove placeholder with fade out
          if (placeholder.parentNode) {
            placeholder.style.opacity = '0';
            placeholder.style.transition = 'opacity 0.15s ease-out';
            setTimeout(() => {
          if (placeholder.parentNode) {
            placeholder.parentNode.removeChild(placeholder);
          }
            }, 150);
          }
          
          // Fade in image using CSS transition (already defined)
          // Explicitly set opacity to 1 to ensure image shows
          img.style.opacity = '1';
          img.classList.add('loaded');
          
          // NO LAYOUT CHANGES - layout is already complete
          // Don't update wrapper height - it's already set correctly from dimensions
          // Any height adjustment would cause layout shift and scroll jump
          wrapper.dataset.loaded = 'true';
          
          // Queue metadata extraction (but don't process until all images loaded)
          metadataQueue.push({ img, label, baseFilename, copyPromptBtn, container, filename, pageLoadToken });
          // Don't call processMetadataQueue() here - wait until all images are loaded
        };
        
        const handleImageError = function() {
          if (imageLoadHandled) return; // Prevent double-counting
          imageLoadHandled = true;
          
          // Clear any pending timeout
          if (loadTimeoutId) {
            clearTimeout(loadTimeoutId);
            loadTimeoutId = null;
          }
          
          pageImagesErrored++;
          updatePageLoadingProgress();
          
          // If image failed (404/missing), remove stale references and avoid black/error panels.
          if (img.src && img.complete && img.naturalWidth === 0) {
            const removed = removeMissingImageFromState(filename);
            container.classList.add('deleted');
            container.dataset.deleted = 'true';
            const imageWrapper = container.querySelector('.image-wrapper');
            if (imageWrapper) {
              imageWrapper.style.minHeight = '60px';
            }
            if (img) {
              img.style.display = 'none';
            }
            const buttons = container.querySelectorAll('button');
            buttons.forEach(btn => {
              btn.disabled = true;
              btn.style.pointerEvents = 'none';
              btn.style.opacity = '0';
            });
            if (removed) {
              setTimeout(() => {
                updateImageCount(true);
                updatePaginationUI();
              }, 0);
            }
          }
        };

        // Create button container
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'image-buttons';

        // 1st button: Copy Prompt
        const copyPromptBtn = document.createElement('button');
        copyPromptBtn.className = 'image-button';
        copyPromptBtn.setAttribute('data-label', 'Copy Prompt');
        copyPromptBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>';
        copyPromptBtn.style.display = 'none';
        copyPromptBtn.addEventListener('click', async function(e) {
          e.preventDefault();
          e.stopPropagation();
          let prompt = (this.dataset.prompt || '').trim();
          if (!prompt) {
            try {
              const currentFilename = resolveCurrentFilename(container?.dataset?.filename || filename, container, this);
              const metadata = await getPngMetadata(escapeFilename(currentFilename));
              const displayData = formatMetadataForDisplay(metadata);
              prompt = (displayData['Prompt'] || '').trim();
              if (prompt) {
                this.dataset.prompt = prompt;
                if (container) {
                  container.dataset.prompt = prompt.toLowerCase();
                }
                this.style.display = 'flex';
              }
            } catch (err) {}
          }
          if (!prompt) {
            alert('Prompt is not available for this image.');
            return;
          }
          const copied = await copyTextRobust(prompt);
          if (copied) {
            this.classList.add('copied');
            setTimeout(() => {
              this.classList.remove('copied');
            }, 2000);
          } else {
            alert('Copy failed. Please try again.');
          }
        });

        // 2nd button: Download
        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'image-button';
        downloadBtn.setAttribute('data-label', 'Download');
        downloadBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2v9.67z"/></svg>';
        downloadBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          const a = document.createElement('a');
          a.href = img.src;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        });

        // 3rd button: Open in new window
        const openButton = document.createElement('button');
        openButton.className = 'image-button';
        openButton.setAttribute('data-label', 'Open');
        openButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 19H6c-.55 0-1-.45-1-1V6c0-.55.45-1 1-1h5c.55 0 1-.45 1-1s-.45-1-1-1H6c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-5c0-.55-.45-1-1-1s-1 .45-1 1v5c0 .55-.45 1-1 1zM14 4c0 .55.45 1 1 1h2.59l-9.13 9.13c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0L19 6.41V9c0 .55.45 1 1 1s1-.45 1-1V4c0-.55-.45-1-1-1h-5c-.55 0-1 .45-1 1z"/></svg>';
        openButton.addEventListener('click', function(e) {
          e.stopPropagation();
          window.open(img.src, '_blank');
        });

        buttonContainer.appendChild(copyPromptBtn);
        buttonContainer.appendChild(downloadBtn);
        buttonContainer.appendChild(openButton);

        // Set up load and error handlers (images will load AFTER layout is complete)
        // Store handlers for later attachment
        img.dataset.handleLoad = 'true';
        img.dataset.handleError = 'true';
        
        // DO NOT set img.src here - will be set after layout is complete (PHASE 2)
        // DO NOT attach event listeners here - will be attached when src is set
        
        // Add a timeout fallback only for truly stuck images (60 seconds)
        loadTimeoutId = setTimeout(() => {
          if (!imageLoadHandled && img.src) {
            // Only mark as error if image is actually in error state
            if (img.complete && img.naturalWidth === 0) {
              if (DEBUG_MODE) console.warn('Image load timeout (60s):', filename);
              img.removeEventListener('load', handleImageLoad);
              img.removeEventListener('error', handleImageError);
              handleImageError();
            }
            // If still loading, don't mark as error - just clear timeout
            else if (!img.complete) {
              // Image still loading after 60s - clear timeout but don't mark as error
              // It will eventually load or error naturally
            }
          }
        }, 60000); // 60 seconds for very large images

        // Create star button (upper right corner)
        const starButton = document.createElement('button');
        starButton.className = 'star-button';
        starButton.setAttribute('data-label', 'Add to Favorites');
        starButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>';
        starButton.dataset.filename = filename;
        starButton.dataset.imageId = container.dataset.imageId || '';
        
        // Check if image is in Favorites folder (check for Favorites at start or anywhere in path)
        const isFavorited = filename.startsWith('Favorites/') || 
                           filename.startsWith('Favorites\\') ||
                           filename.includes('/Favorites/') || 
                           filename.includes('\\Favorites\\');
        if (isFavorited) {
          starButton.classList.add('favorited');
          starButton.setAttribute('data-label', 'Remove from Favorites');
        }
        
        starButton.addEventListener('click', function(e) {
          e.preventDefault(); // Prevent any default button behavior
          e.stopPropagation(); // Prevent event bubbling to parent elements
          e.stopImmediatePropagation(); // Prevent other handlers on the same element
          // Use the dataset filename which should reflect the current path
          // This is important if the file was moved in a previous session
          const currentFilename = this.dataset.filename || filename;
          toggleFavorite(currentFilename, starButton);
        });

        // Create delete button (underneath star button)
        const deleteButton = document.createElement('button');
        deleteButton.className = 'delete-button';
        deleteButton.setAttribute('data-label', 'Delete');
        deleteButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>';
        deleteButton.dataset.filename = filename;
        deleteButton.dataset.imageId = container.dataset.imageId || '';
        
        deleteButton.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          
          if (armedDeleteButton !== this) {
            clearArmedDeleteButton();
            armedDeleteButton = this;
            this.classList.add('armed');
            this.setAttribute('data-label', 'Click again to delete');
            armedDeleteTimeout = setTimeout(() => {
              clearArmedDeleteButton();
            }, 4000);
            return;
          }

          const currentFilename = this.dataset.filename || filename;
          deleteImage(currentFilename, container);
        });

        wrapper.appendChild(img);
        wrapper.appendChild(label);
        wrapper.appendChild(buttonContainer);
        // Create rating stars container
        const ratingContainer = document.createElement('div');
        ratingContainer.className = 'rating-stars';
        ratingContainer.dataset.filename = filename;
        ratingContainer.dataset.imageId = container.dataset.imageId || '';
        
        // Create 5 stars in reverse order (top = 5, bottom = 1)
        for (let i = 5; i >= 1; i--) {
          const star = document.createElement('button');
          star.className = 'rating-star';
          star.dataset.rating = i;
          star.setAttribute('aria-label', `Rate ${i} star${i > 1 ? 's' : ''}`);
          star.setAttribute('data-label', `${i} Star${i > 1 ? 's' : ''}`);
          star.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>';
          
          star.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            const currentFilename = ratingContainer.dataset.filename || filename;
            setRating(currentFilename, i, ratingContainer, container);
          });
          
          ratingContainer.appendChild(star);
        }
        
        // Set initial rating state
        const currentRating = parseRatingFromFilename(filename);
        updateRatingDisplay(ratingContainer, currentRating);

        wrapper.appendChild(starButton);
        wrapper.appendChild(deleteButton);
        wrapper.appendChild(ratingContainer);
        container.appendChild(wrapper);

        // Attach click handler to container, wrapper, and img to ensure clicks work
        // Attach click handler to container, wrapper, and img to ensure clicks work
        // Capture pageIndex and startIndex in closure to avoid scope issues
        const openLightbox = (function(capturedPageIndex, capturedStartIndex, capturedFilename) {
          return function(e) {
            // Don't open lightbox if clicking on buttons
            if (e.target.closest('.image-button, .star-button, .delete-button, .image-buttons, .rating-stars, .rating-star')) {
              return;
            }
            // Don't open if clicking on label
            if (e.target.classList.contains('filename-label')) {
              return;
            }
            // Don't open if we just scrolled (gallery drag-scroll)
            if (window.galleryHasScrolled) {
              return;
            }
            // Get current filename from container (may have been updated if file was moved)
            const currentContainer = e.target.closest('.img-container');
            const currentFilename = currentContainer?.dataset.filename || currentContainer?.dataset.currentFilename || capturedFilename;
            let index = filteredImageFiles.findIndex(f => f === currentFilename);
            if (index < 0) {
              index = allImageFiles.findIndex(f => f === currentFilename);
            }
            // Use current filename to construct URL - this ensures moved files work correctly
            const imageUrl = escapeFilename(currentFilename);
            showLightbox(imageUrl, currentFilename, index);
          e.stopPropagation();
          };
        })(pageIndex, startIndex, filename);
        
        // Attach once at container level to avoid duplicate/racing handlers.
        container.addEventListener('click', openLightbox);

          // Store container data for later (including handlers)
          containerData.push({ container, img, placeholder, filename, copyPromptBtn, label, baseFilename, handleImageLoad, handleImageError });
        });
        
        // PHASE 1 COMPLETE: All containers created with correct sizes
        // Now do ONE layout calculation - this is the ONLY layout call
        allImageContainers = containerData.map(d => d.container);
      layoutCache = null;
        layoutMasonry();
        
        // Update progress
        if (loadingScreenProgress && isInitialLoad) {
          loadingScreenProgress.style.width = '100%';
        }
        if (loadingScreenMessage && isInitialLoad) {
          loadingScreenMessage.textContent = 'Ready!';
        }
        
        // PHASE 2: Force load all images for the active page in background using fetch()
        // This keeps page transitions fast without preloading the whole library.
        requestAnimationFrame(() => {
            // Now containers are definitely in DOM - start loading images
            // Track when all images are loaded to trigger metadata
            let imagesLoadedCount = 0;
            let imagesErroredCount = 0;
            const totalImagesToLoad = containerData.filter(d => d.img && d.filename).length;
            
            const checkAllImagesLoaded = () => {
              if (imagesLoadedCount + imagesErroredCount >= totalImagesToLoad && totalImagesToLoad > 0) {
                // All images loaded - NOW start metadata processing
                processMetadataQueue();
              }
            };
            
          // FORCE LOAD: preload active-page images in background, then set blob URLs
          // Avoids global preloading for large libraries.
          containerData.forEach(({ img, filename, placeholder, handleImageLoad, handleImageError }) => {
            if (!img || !filename) return;
            
            const imageUrl = escapeFilename(filename);
            
            // Find the actual DOM img element (containers are in DOM after layoutMasonry)
            const container = containerData.find(d => d.filename === filename)?.container;
            let domImg = img;
            if (container) {
              const foundImg = container.querySelector('img');
              if (foundImg) {
                domImg = foundImg;
              }
            }
            
            // Skip if not in DOM
            if (!domImg.parentNode) {
              if (DEBUG_MODE) console.error('Image not in DOM:', filename);
              return;
            }
            
            // Simple load handler - calls original handler which updates progress
            const loadHandler = () => {
              if (domImg.classList && domImg.classList.contains('loaded')) return;
              
              // Call original handler FIRST - this updates pageImagesLoaded and progress bar
              if (handleImageLoad) {
                try {
                  handleImageLoad();
                } catch (e) {
                  console.error('Error in handleImageLoad for', filename, ':', e);
                }
              }
              
              // Also update placeholder and opacity
              if (placeholder && placeholder.parentNode) {
                placeholder.style.opacity = '0';
                setTimeout(() => {
                  if (placeholder.parentNode) {
                    placeholder.parentNode.removeChild(placeholder);
                  }
                }, 150);
              }
              
              if (domImg.classList) {
                domImg.classList.add('loaded');
              }
              domImg.style.opacity = '1';
              
              imagesLoadedCount++;
              checkAllImagesLoaded();
            };
            
            // Simple error handler - calls original handler which updates progress
            const errorHandler = () => {
              if (domImg.classList && (domImg.classList.contains('loaded') || domImg.classList.contains('error-handled'))) return;
              
              if (domImg.classList) {
                domImg.classList.add('error-handled');
              }
              
              // Call original handler FIRST - this updates pageImagesErrored and progress bar
              if (handleImageError) {
                try {
                  handleImageError();
                } catch (e) {
                  console.error('Error in handleImageError for', filename, ':', e);
                }
              }
              
              imagesErroredCount++;
              checkAllImagesLoaded();
            };
            
            // Attach listeners BEFORE setting src
            domImg.addEventListener('load', loadHandler, { once: true });
            domImg.addEventListener('error', errorHandler, { once: true });
            
            // Single-pass load: set src once on the DOM image.
            // Avoid extra duplicate preloading work for large pages.
            domImg.loading = 'eager';
            domImg.src = imageUrl;
            
            // Check if already loaded (cached)
            if (domImg.complete && domImg.naturalWidth > 0) {
              setTimeout(() => {
                if (!domImg.classList.contains('loaded')) {
                  loadHandler();
                }
              }, 0);
            }
          });
        
        // Simple retry mechanism: Check every 10 seconds for unloaded images
        // Clear any existing interval first (in case loadCurrentPage is called multiple times)
        if (window.retryCheckInterval) {
          clearInterval(window.retryCheckInterval);
          window.retryCheckInterval = null;
        }
        let retryCheckInterval = null;
        
        const checkAndLoadUnloadedImages = () => {
          // Find all images that still have placeholders (not loaded)
          const unloadedImages = containerData.filter(({ img, filename }) => {
            if (!img || !filename) return false;
            const container = containerData.find(d => d.filename === filename)?.container;
            if (!container) return false;
            const placeholder = container.querySelector('.image-placeholder');
            const hasPlaceholder = placeholder && placeholder.parentNode;
            const isLoaded = img.classList.contains('loaded') || img.classList.contains('error-handled');
            return hasPlaceholder && !isLoaded;
          });
          
          if (unloadedImages.length === 0) {
            // All images loaded - stop checking
            if (retryCheckInterval) {
              clearInterval(retryCheckInterval);
              retryCheckInterval = null;
              window.retryCheckInterval = null;
            }
            if (DEBUG_MODE) console.log('All images loaded, stopping retry checks');
            return;
          }
          
          if (DEBUG_MODE) console.log(`[Retry Check] Found ${unloadedImages.length} unloaded images, forcing load...`);
          
          // Force load unloaded images
          unloadedImages.forEach(({ img, filename, placeholder, handleImageLoad, handleImageError }) => {
            const container = containerData.find(d => d.filename === filename)?.container;
            if (!container) return;
            
            // Find the actual DOM img element
            let domImg = img;
            const foundImg = container.querySelector('img');
            if (foundImg) {
              domImg = foundImg;
            }
            
            // Skip if not in DOM
            if (!domImg.parentNode) return;
            
            // Check if image is actually complete but handler wasn't called
            if (domImg.complete && domImg.naturalWidth > 0 && domImg.naturalHeight > 0) {
              // Image loaded but handler wasn't called - trigger it now
              if (handleImageLoad) {
                try {
                  handleImageLoad();
                } catch (e) {
                  console.error('Error in handleImageLoad for', filename, ':', e);
                }
              }
              
              if (placeholder && placeholder.parentNode) {
                placeholder.style.opacity = '0';
                setTimeout(() => {
                  if (placeholder.parentNode) {
                    placeholder.parentNode.removeChild(placeholder);
                  }
                }, 150);
              }
              
              if (domImg.classList) {
                domImg.classList.add('loaded');
              }
              domImg.style.opacity = '1';
            } else if (!domImg.src || domImg.src.length === 0) {
              // Image src was never set - set it now and force load
              const imageUrl = escapeFilename(filename);
              
              // Simple load handler
              const retryLoadHandler = () => {
                if (domImg.classList && domImg.classList.contains('loaded')) return;
                
                if (handleImageLoad) {
                  try {
                    handleImageLoad();
                  } catch (e) {
                    console.error('Error in handleImageLoad for', filename, ':', e);
                  }
                }
                
                if (placeholder && placeholder.parentNode) {
                  placeholder.style.opacity = '0';
                  setTimeout(() => {
                    if (placeholder.parentNode) {
                      placeholder.parentNode.removeChild(placeholder);
                    }
                  }, 150);
                }
                
                if (domImg.classList) {
                  domImg.classList.add('loaded');
                }
                domImg.style.opacity = '1';
              };
              
              const retryErrorHandler = () => {
                if (domImg.classList && (domImg.classList.contains('loaded') || domImg.classList.contains('error-handled'))) return;
                
                if (domImg.classList) {
                  domImg.classList.add('error-handled');
                }
                
                if (handleImageError) {
                  try {
                    handleImageError();
                  } catch (e) {
                    console.error('Error in handleImageError for', filename, ':', e);
                  }
                }
              };
              
              // Attach listeners and set src
              domImg.addEventListener('load', retryLoadHandler, { once: true });
              domImg.addEventListener('error', retryErrorHandler, { once: true });
              domImg.loading = 'eager';
              domImg.src = imageUrl;
              
              if (DEBUG_MODE) console.log('Forcing load for unloaded image:', filename);
            } else if (domImg.src && !domImg.complete) {
              // Image src is set but not complete - force reload
              const imageUrl = domImg.src;
              domImg.src = '';
              setTimeout(() => {
                domImg.src = imageUrl;
                if (DEBUG_MODE) console.log('Force reloading image:', filename);
              }, 0);
            }
          });
        };
        
        // Start checking 10 seconds after initial load
        setTimeout(() => {
          retryCheckInterval = setInterval(checkAndLoadUnloadedImages, 10000); // Check every 10 seconds
          window.retryCheckInterval = retryCheckInterval; // Store globally to allow cleanup
          if (DEBUG_MODE) console.log('Started retry check interval (every 10 seconds)');
        }, 10000);
        
        // PHASE 2: Hide loading screen after images start loading
        if (isInitialLoad) {
          // Ensure scroll is at top before hiding loading screen
          window.scrollTo(0, 0);
          document.documentElement.scrollTop = 0;
          document.body.scrollTop = 0;
          
          setTimeout(() => {
            if (loadingScreen) {
              loadingScreen.classList.add('hidden');
            }
            initialPageLoaded = true;
            
            // Ensure scroll stays at top after loading screen hides
            requestAnimationFrame(() => {
              window.scrollTo(0, 0);
              document.documentElement.scrollTop = 0;
              document.body.scrollTop = 0;
            });
          }, 300);
        }
      });
  }

    function filterImages(searchQuery, preserveScrollY = null) {
      const searchInput = document.getElementById('searchInput');
      const currentQuery = searchQuery || (searchInput ? searchInput.value : '');
      
      // Show processing status if filtering (not just initial load)
      if (currentQuery.length >= 2 || activeModelFilter || showFavoritesOnly || activeRatingFilters.size > 0) {
        updateProcessingStatus('Filtering images...', true);
      }
      
      // Reset to page 1 when filtering (unless preserving scroll)
      if (preserveScrollY === null) {
      currentPage = 1;
      }
      
      let filtered = [];
      
      // First apply favorites filter if enabled
      if (showFavoritesOnly) {
        filtered = allImageFiles.filter(filename => isFavorited(filename));
      } else {
        filtered = [...allImageFiles];
      }
      
      // Apply model filter if active
      if (activeModelFilter) {
        // Get the contains text from the active button
        const activeButton = document.querySelector(`.model-filter-btn[data-model="${activeModelFilter}"]`);
        const containsText = activeButton ? (activeButton.getAttribute('data-contains') || activeModelFilter).toLowerCase() : activeModelFilter.toLowerCase();
        
        filtered = filtered.filter(filename => {
          // Check global metadata index
          const metadata = imageSearchIndex.get(filename);
          if (metadata && metadata.model) {
            return metadata.model.toLowerCase().includes(containsText);
          }
          // Check container data for images not yet indexed
          const container = allImageContainers.find(c => c.dataset.filename === filename);
          if (container && container.dataset.modelName) {
            return container.dataset.modelName.toLowerCase().includes(containsText);
          }
          // If no metadata available yet, exclude from filtered results
          return false;
        });
      }
      
      // Apply rating filters if any are active
      if (activeRatingFilters.size > 0) {
        filtered = filtered.filter(filename => {
          const rating = parseRatingFromFilename(filename);
          return activeRatingFilters.has(rating);
        });
      }
      
      if (currentQuery.length < 2) {
        // Show all images (or favorites if filter is on) if search is less than 2 characters
        filteredImageFiles = filtered;
      } else {
        const query = currentQuery.toLowerCase();
        const filteredSet = new Set(); // Use Set for O(1) lookups instead of array includes
        
        // Filter based on filenames (optimized with Set) - use filtered array
        filtered.forEach((filename) => {
          const filenameOnly = getFilenameOnly(filename).toLowerCase();
          if (filenameOnly.includes(query)) {
            filteredSet.add(filename);
          }
        });
        
        // Search through global metadata index (works for all images, not just current page)
        imageSearchIndex.forEach((metadata, filename) => {
          // Only include if it's in our filtered list
          if (filtered.includes(filename) && (metadata.model.includes(query) || metadata.prompt.includes(query))) {
            filteredSet.add(filename);
          }
        });
        
        // Also check currently loaded containers (for images that just loaded but not yet indexed)
        allImageContainers.forEach((container) => {
          const modelName = (container.dataset.modelName || '').toLowerCase();
          const prompt = (container.dataset.prompt || '').toLowerCase();
          
          // Check if query matches model name or prompt
          if (modelName.includes(query) || prompt.includes(query)) {
            // Use stored filename from dataset for faster lookup
            const filename = container.dataset.filename;
            if (filename && filtered.includes(filename)) {
              filteredSet.add(filename);
            } else {
              // Fallback: Extract filename from img src
              const img = container.querySelector('img');
              if (img && img.src) {
                const srcPath = decodeURIComponent(img.src);
                const foundFilename = filtered.find(f => srcPath.includes(f));
                if (foundFilename) {
                  filteredSet.add(foundFilename);
                }
              }
            }
          }
        });
        
        filteredImageFiles = Array.from(filteredSet);
      }
      
      // Invalidate layout cache and clear columns when filtering
      layoutCache = null;
      galleryColumns = [];
      
      // Clear any pending layout timeouts
      if (window.imageLoadLayoutTimeout) {
        clearTimeout(window.imageLoadLayoutTimeout);
        window.imageLoadLayoutTimeout = null;
      }
      if (window.finalLayoutTimeout) {
        clearTimeout(window.finalLayoutTimeout);
        window.finalLayoutTimeout = null;
      }
      
      // Update pagination UI
      updatePaginationUI();
      
      // Update image count
      updateImageCount();
      
      // Log filter results
      if (currentQuery.length >= 2 || activeModelFilter || showFavoritesOnly || activeRatingFilters.size > 0) {
        const ratingFiltersStr = activeRatingFilters.size > 0 ? Array.from(activeRatingFilters).sort().join(',') : 'none';
        debugLog(`[Filter] Results: ${filteredImageFiles.length} images (search: "${currentQuery}", model: ${activeModelFilter || 'none'}, favorites: ${showFavoritesOnly}, ratings: ${ratingFiltersStr})`);
        logToServer('filter_applied', { 
          resultCount: filteredImageFiles.length, 
          searchQuery: currentQuery.length >= 2 ? currentQuery : '',
          modelFilter: activeModelFilter,
          favoritesOnly: showFavoritesOnly,
          ratingFilters: Array.from(activeRatingFilters)
        });
      }
      
      // Load current page (will create containers for filtered images)
      // Preserve scroll position if provided, otherwise scroll to top
      if (preserveScrollY !== null) {
        loadCurrentPage(true);
        // Restore scroll after layout
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            window.scrollTo(0, preserveScrollY);
            document.documentElement.scrollTop = preserveScrollY;
            document.body.scrollTop = preserveScrollY;
            clearProcessingStatus();
          });
        });
      } else {
        loadCurrentPage(false);
        // Clear processing status after a brief delay
        setTimeout(() => clearProcessingStatus(), 500);
      }
    }

    // Metadata extraction queue with concurrency limit
    let metadataQueue = [];
    let activeMetadataExtractions = 0;
    let currentPageLoadToken = 0;
    const MAX_CONCURRENT_METADATA = 5; // Limit concurrent metadata fetches
    
    function processMetadataQueue() {
      if (metadataQueue.length === 0 || activeMetadataExtractions >= MAX_CONCURRENT_METADATA) {
        return;
      }
      
      const { img, label, baseFilename, copyPromptBtn, container, filename, pageLoadToken } = metadataQueue.shift();
      if (pageLoadToken !== currentPageLoadToken || !container || !container.isConnected) {
        if (metadataQueue.length > 0) {
          setTimeout(processMetadataQueue, 0);
        }
        return;
      }
      activeMetadataExtractions++;
      
      getPngMetadata(img.src)
        .then(metadata => {
          if (pageLoadToken !== currentPageLoadToken || !container || !container.isConnected) {
            return;
          }
          const displayData = formatMetadataForDisplay(metadata);
          const parts = [baseFilename];
          if (displayData['Model']) parts.push(displayData['Model']);
          if (displayData['Sampler']) parts.push(displayData['Sampler']);
          if (displayData['Schedule Type']) parts.push(displayData['Schedule Type']);
          
          // Add size/dimensions at the end
          if (displayData['Size']) {
            parts.push(displayData['Size']);
          } else if (img.naturalWidth && img.naturalHeight) {
            // Fallback to actual image dimensions if Size not in metadata
            parts.push(`${img.naturalWidth}x${img.naturalHeight}`);
          }
          
          label.textContent = parts.join('  ');
          
          // Store model name in container for search
          if (container && displayData['Model']) {
            container.dataset.modelName = displayData['Model'];
          }
          
          // Store prompt in container for search
          if (container && displayData['Prompt']) {
            container.dataset.prompt = displayData['Prompt'].toLowerCase();
          }
          
          // Store prompt for copy button
          if (displayData['Prompt'] && copyPromptBtn) {
            copyPromptBtn.dataset.prompt = displayData['Prompt'];
            copyPromptBtn.style.display = 'flex';
          }
          
          // Store in global search index (for searching across all pages)
          if (filename) {
            imageSearchIndex.set(filename, {
              model: (displayData['Model'] || '').toLowerCase(),
              prompt: (displayData['Prompt'] || '').toLowerCase()
            });
          }
          
          // Don't auto-refresh search during metadata extraction - it causes too many reloads
          // The search will work on the next manual search or when user types
        })
        .catch(err => {
          if (pageLoadToken !== currentPageLoadToken || !container || !container.isConnected) {
            return;
          }
          // If metadata extraction fails, keep the base filename
          label.textContent = baseFilename;
          // Try to get dimensions from image
          if (img.naturalWidth && img.naturalHeight) {
            label.textContent = `${baseFilename}  ${img.naturalWidth}x${img.naturalHeight}`;
          }
        })
        .finally(() => {
          activeMetadataExtractions--;
          // Process next item in queue
          if (metadataQueue.length > 0) {
            setTimeout(processMetadataQueue, 0);
          }
        });
    }

    // Embedded image list - injected by inject_image_list.py
    // IMAGE_LIST_PLACEHOLDER
    const embeddedImageList = [
  "darkroom.png",
  "2026-02-22/00008-69661699-swapped.png",
  "2026-02-22/00009-2917851208-swapped.png",
  "2026-02-22/00010-2543964626-swapped.png",
  "2026-02-22/00011-3256863061-swapped.png",
  "2026-02-22/00012-3709939684-swapped.png",
  "2026-02-22/00013-2916097743-swapped.png",
  "2026-02-22/00014-3651048087-swapped.png",
  "2026-02-22/00015-3696098032-swapped.png",
  "2026-02-22/00016-3201447583-swapped.png",
  "2026-02-22/00017-3050293556-swapped.png",
  "2026-02-22/00018-3815224121-swapped.png",
  "2026-02-22/00019-805302664-swapped.png",
  "2026-02-22/00020-1880200199-swapped.png",
  "2026-02-22/00021-443479391-swapped.png",
  "2026-02-22/00022-3328320936-swapped.png",
  "2026-02-22/00023-1947783737-swapped.png",
  "2026-02-22/00024-3763736570-swapped.png",
  "2026-02-22/00025-3763736570-swapped.png",
  "2026-02-22/00026-658943760-swapped.png",
  "2026-02-22/00027-3763736570-swapped.png",
  "2026-02-22/00028-3763736570-swapped.png",
  "2026-02-22/00029-3763736570-swapped.png",
  "2026-02-22/00030-3763736570-swapped.png",
  "2026-02-22/00031-3763736570-swapped.png",
  "2026-02-22/00032-3763736570-swapped.png",
  "2026-02-22/00033-3763736570-swapped.png",
  "2026-02-22/00034-3763736570-swapped.png",
  "2026-02-22/00035-3763736570-swapped.png",
  "2026-02-22/00036-3763736570-swapped.png",
  "2026-02-22/00037-3763736570-swapped.png",
  "2026-02-22/00038-3763736570-swapped.png",
  "2026-02-22/00039-3763736570-swapped.png",
  "2026-02-22/00040-3763736570-swapped.png",
  "2026-02-22/00041-3763736570-swapped.png",
  "2026-02-22/00042-3763736570-swapped.png",
  "2026-02-22/00043-3763736570-swapped.png",
  "2026-02-22/00044-1875760986-swapped.png",
  "2026-02-22/00045-3763736570-swapped.png",
  "2026-02-22/00046-3763736570-swapped.png",
  "2026-02-22/00047-3763736570-swapped.png",
  "2026-02-22/00048-3763736570-swapped.png",
  "2026-02-22/00049-3763736570-swapped.png",
  "2026-02-22/00050-3763736570-swapped.png",
  "2026-02-22/00051-3763736570-swapped.png",
  "2026-02-22/00052-3763736570-swapped.png",
  "2026-02-22/00053-3763736570-swapped.png",
  "2026-02-22/00054-3763736570-swapped.png",
  "2026-02-22/00055-3763736570-swapped.png",
  "2026-02-22/00056-3763736570-swapped.png",
  "2026-02-22/00057-3763736570-swapped.png",
  "2026-02-22/00058-3763736570-swapped.png",
  "2026-02-22/00059-3763736570-swapped.png",
  "2026-02-22/00060-3763736570-swapped.png",
  "2026-02-22/00061-3763736570-swapped.png",
  "2026-02-22/00062-3763736570-swapped.png",
  "2026-02-22/00063-3038563366-swapped.png",
  "2026-02-22/00064-3763736570-swapped.png",
  "2026-02-22/00065-3763736570-swapped.png",
  "2026-02-22/00066-3763736570-swapped.png",
  "2026-02-22/00067-3763736570-swapped.png",
  "2026-02-22/00068-3763736570-swapped.png",
  "2026-02-22/00069-3763736570-swapped.png",
  "2026-02-22/00070-3763736570-swapped.png",
  "2026-02-22/00071-3763736570-swapped.png",
  "2026-02-22/00072-3763736570-swapped.png",
  "2026-02-22/00073-3763736570-swapped.png",
  "2026-02-22/00074-3763736570-swapped.png",
  "2026-02-22/00075-3763736570-swapped.png",
  "2026-02-22/00076-3763736570-swapped.png",
  "2026-02-22/00077-3763736570-swapped.png",
  "2026-02-22/00078-3763736570-swapped.png",
  "2026-02-22/00079-3763736570-swapped.png",
  "2026-02-22/00080-3763736570-swapped.png",
  "2026-02-22/00081-3763736570-swapped.png",
  "2026-02-22/00082-1366647251-swapped.png",
  "2026-02-22/00083-3763736570-swapped.png",
  "2026-02-22/00084-3763736570-swapped.png",
  "2026-02-22/00085-3763736570-swapped.png",
  "2026-02-22/00086-3763736570-swapped.png",
  "2026-02-22/00087-3763736570-swapped.png",
  "2026-02-22/00088-3763736570-swapped.png",
  "2026-02-22/00089-3763736570-swapped.png",
  "2026-02-22/00090-3763736570-swapped.png",
  "2026-02-22/00091-3763736570-swapped.png",
  "2026-02-22/00092-3763736570-swapped.png",
  "2026-02-22/00093-3763736570-swapped.png",
  "2026-02-22/00094-3173778759-swapped.png",
  "2026-02-22/00095-3763736570-swapped.png",
  "2026-02-22/00096-3763736570-swapped.png",
  "2026-02-22/00097-3763736570-swapped.png",
  "2026-02-22/00098-3763736570-swapped.png",
  "2026-02-22/00099-3763736570-swapped.png",
  "2026-02-22/00100-3763736570-swapped.png",
  "2026-02-22/00101-3763736570-swapped.png",
  "2026-02-22/00102-3763736570-swapped.png",
  "2026-02-22/00103-3763736570-swapped.png",
  "2026-02-22/00104-3763736570-swapped.png",
  "2026-02-22/00105-3763736570-swapped.png",
  "2026-02-22/00106-3763736570-swapped.png",
  "2026-02-22/00107-3763736570-swapped.png",
  "2026-02-22/00108-3763736570-swapped.png",
  "2026-02-22/00109-2613712102-swapped.png",
  "2026-02-22/00110-3763736570-swapped.png",
  "2026-02-22/00111-3763736570-swapped.png",
  "2026-02-22/00112-3763736570-swapped.png",
  "2026-02-22/00113-3763736570-swapped.png",
  "2026-02-22/00114-3763736570-swapped.png",
  "2026-02-22/00115-3763736570-swapped.png",
  "2026-02-22/00116-3763736570-swapped.png",
  "2026-02-22/00117-3763736570-swapped.png",
  "2026-02-22/00118-3763736570-swapped.png",
  "2026-02-22/00119-3763736570-swapped.png",
  "2026-02-22/00120-3890109576-swapped.png",
  "2026-02-22/00121-3763736570-swapped.png",
  "2026-02-22/00122-3763736570-swapped.png",
  "2026-02-22/00123-3763736570-swapped.png",
  "2026-02-22/00124-3763736570-swapped.png",
  "2026-02-22/00125-3763736570-swapped.png",
  "2026-02-22/00126-3763736570-swapped.png",
  "2026-02-22/00127-3763736570-swapped.png",
  "2026-02-22/00128-3763736570-swapped.png",
  "2026-02-22/00129-3763736570-swapped.png",
  "2026-02-22/00130-3763736570-swapped.png",
  "2026-02-22/00131-3763736570-swapped.png",
  "2026-02-22/00132-3763736570-swapped.png",
  "2026-02-22/00133-3763736570-swapped.png",
  "2026-02-22/00134-3763736570-swapped.png",
  "2026-02-22/00135-3763736570-swapped.png",
  "2026-02-22/00136-3115837679-swapped.png",
  "2026-02-22/00137-3763736570-swapped.png",
  "2026-02-22/00138-3763736570-swapped.png",
  "2026-02-22/00139-3763736570-swapped.png",
  "2026-02-22/00140-3763736570-swapped.png",
  "2026-02-22/00141-3763736570-swapped.png",
  "2026-02-22/00142-3763736570-swapped.png",
  "2026-02-22/00143-3763736570-swapped.png",
  "2026-02-22/00144-3763736570-swapped.png",
  "2026-02-22/00145-3763736570-swapped.png",
  "2026-02-22/00146-3763736570-swapped.png",
  "2026-02-22/00147-3763736570-swapped.png",
  "2026-02-22/00148-3763736570-swapped.png",
  "2026-02-22/00149-3763736570-swapped.png",
  "2026-02-22/00150-3763736570-swapped.png",
  "2026-02-22/00151-3763736570-swapped.png",
  "2026-02-22/00152-3763736570-swapped.png",
  "2026-02-22/00153-3763736570-swapped.png",
  "2026-02-22/00154-3763736570-swapped.png",
  "2026-02-22/00155-3763736570-swapped.png",
  "2026-02-22/00156-306574494-swapped.png",
  "2026-02-22/00157-3763736570-swapped.png",
  "2026-02-22/00158-3763736570-swapped.png",
  "2026-02-22/00159-3763736570-swapped.png",
  "2026-02-22/00160-3763736570-swapped.png",
  "2026-02-22/00161-3763736570-swapped.png",
  "2026-02-22/00162-3763736570-swapped.png",
  "2026-02-22/00163-3763736570-swapped.png",
  "2026-02-22/00164-3763736570-swapped.png",
  "2026-02-22/00165-3763736570-swapped.png",
  "2026-02-22/00166-3763736570-swapped.png",
  "2026-02-22/00167-3258527815-swapped.png",
  "2026-02-22/00168-3763736570-swapped.png",
  "2026-02-22/00169-3763736570-swapped.png",
  "2026-02-22/00170-3763736570-swapped.png",
  "2026-02-22/00171-3763736570-swapped.png",
  "2026-02-22/00172-3763736570-swapped.png",
  "2026-02-22/00173-3763736570-swapped.png",
  "2026-02-22/00174-3763736570-swapped.png",
  "2026-02-22/00175-3763736570-swapped.png",
  "2026-02-22/00176-3763736570-swapped.png",
  "2026-02-22/00177-3763736570-swapped.png",
  "2026-02-22/00178-3763736570-swapped.png",
  "2026-02-22/00179-3763736570-swapped.png",
  "2026-02-22/00180-3763736570-swapped.png",
  "2026-02-22/00181-3906987056-swapped.png",
  "2026-02-22/00182-3763736570-swapped.png",
  "2026-02-22/00183-3763736570-swapped.png",
  "2026-02-22/00184-3763736570-swapped.png",
  "2026-02-22/00185-3763736570-swapped.png",
  "2026-02-22/00186-3763736570-swapped.png",
  "2026-02-22/00187-3763736570-swapped.png",
  "2026-02-22/00188-3763736570-swapped.png",
  "2026-02-22/00189-3763736570-swapped.png",
  "2026-02-22/00190-3763736570-swapped.png",
  "2026-02-22/00191-3763736570-swapped.png",
  "2026-02-22/00192-3763736570-swapped.png",
  "2026-02-22/00193-3763736570-swapped.png",
  "2026-02-22/00194-3763736570-swapped.png",
  "2026-02-22/00195-3763736570-swapped.png",
  "2026-02-22/00196-3763736570-swapped.png",
  "2026-02-22/00197-3763736570-swapped.png",
  "2026-02-22/00198-3763736570-swapped.png",
  "2026-02-22/00199-3763736570-swapped.png",
  "2026-02-22/00200-3587280850-swapped.png",
  "2026-02-22/00201-3763736570-swapped.png",
  "2026-02-22/00202-3763736570-swapped.png",
  "2026-02-22/00203-3763736570-swapped.png",
  "2026-02-22/00204-3763736570-swapped.png",
  "2026-02-22/00205-3763736570-swapped.png",
  "2026-02-22/00206-3763736570-swapped.png",
  "2026-02-22/00207-3763736570-swapped.png",
  "2026-02-22/00208-3763736570-swapped.png",
  "2026-02-22/00209-3763736570-swapped.png",
  "2026-02-22/00210-3763736570-swapped.png",
  "2026-02-22/00211-3763736570-swapped.png",
  "2026-02-22/00212-3763736570-swapped.png",
  "2026-02-22/00213-3763736570-swapped.png",
  "2026-02-22/00214-3763736570-swapped.png",
  "2026-02-22/00215-3763736570-swapped.png",
  "2026-02-22/00216-3763736570-swapped.png",
  "2026-02-22/00217-3763736570-swapped.png",
  "2026-02-22/00218-3763736570-swapped.png",
  "2026-02-22/00219-3763736570-swapped.png",
  "2026-02-22/00220-3763736570-swapped.png",
  "2026-02-22/00221-2834811007-swapped.png",
  "2026-02-22/00222-3763736570-swapped.png",
  "2026-02-22/00223-3763736570-swapped.png",
  "2026-02-22/00224-3763736570-swapped.png",
  "2026-02-22/00225-3763736570-swapped.png",
  "2026-02-22/00226-3763736570-swapped.png",
  "2026-02-22/00227-3763736570-swapped.png",
  "2026-02-22/00228-3763736570-swapped.png",
  "2026-02-22/00229-3763736570-swapped.png",
  "2026-02-22/00230-3763736570-swapped.png",
  "2026-02-22/00231-3763736570-swapped.png",
  "2026-02-22/00232-3763736570-swapped.png",
  "2026-02-22/00233-3763736570-swapped.png",
  "2026-02-22/00234-3763736570-swapped.png",
  "2026-02-22/00235-2252301346-swapped.png",
  "2026-02-22/00236-3763736570-swapped.png",
  "2026-02-22/00237-3763736570-swapped.png",
  "2026-02-22/00238-3763736570-swapped.png",
  "2026-02-22/00239-3763736570-swapped.png",
  "2026-02-22/00240-3763736570-swapped.png",
  "2026-02-22/00241-3763736570-swapped.png",
  "2026-02-22/00242-3763736570-swapped.png",
  "2026-02-22/00243-3763736570-swapped.png",
  "2026-02-22/00244-3763736570-swapped.png",
  "2026-02-22/00245-3763736570-swapped.png",
  "2026-02-22/00246-3763736570-swapped.png",
  "2026-02-22/00247-3763736570-swapped.png",
  "2026-02-22/00248-3763736570-swapped.png",
  "2026-02-22/00249-15528634-swapped.png",
  "2026-02-22/00250-3763736570-swapped.png",
  "2026-02-22/00251-3763736570-swapped.png",
  "2026-02-22/00252-3763736570-swapped.png",
  "2026-02-22/00253-3763736570-swapped.png",
  "2026-02-22/00254-3763736570-swapped.png",
  "2026-02-22/00255-3763736570-swapped.png",
  "2026-02-22/00256-3763736570-swapped.png",
  "2026-02-22/00257-3763736570-swapped.png",
  "2026-02-22/00258-3763736570-swapped.png",
  "2026-02-22/00259-3763736570-swapped.png",
  "2026-02-22/00260-3763736570-swapped.png",
  "2026-02-22/00261-3763736570-swapped.png",
  "2026-02-22/00262-3763736570-swapped.png",
  "2026-02-22/00263-3763736570-swapped.png",
  "2026-02-22/00264-3763736570-swapped.png",
  "2026-02-22/00265-3763736570-swapped.png",
  "2026-02-22/00266-3763736570-swapped.png",
  "2026-02-22/00267-3763736570-swapped.png",
  "2026-02-22/00268-3763736570-swapped.png",
  "2026-02-22/00269-3763736570-swapped.png",
  "2026-02-22/00270-3763736570-swapped.png",
  "2026-02-22/00271-3763736570-swapped.png",
  "2026-02-22/00272-3763736570-swapped.png",
  "2026-02-22/00273-2377025470-swapped.png",
  "2026-02-22/00274-3763736570-swapped.png",
  "2026-02-22/00275-3763736570-swapped.png",
  "2026-02-22/00276-3763736570-swapped.png",
  "2026-02-22/00277-3763736570-swapped.png",
  "2026-02-22/00278-3763736570-swapped.png",
  "2026-02-22/00279-3763736570-swapped.png",
  "2026-02-22/00280-3763736570-swapped.png",
  "2026-02-22/00281-3763736570-swapped.png",
  "2026-02-22/00282-3763736570-swapped.png",
  "2026-02-22/00283-3763736570-swapped.png",
  "2026-02-22/00284-3763736570-swapped.png",
  "2026-02-22/00285-3763736570-swapped.png",
  "2026-02-22/00286-3763736570-swapped.png",
  "2026-02-22/00287-3763736570-swapped.png",
  "2026-02-22/00288-3763736570-swapped.png",
  "2026-02-22/00289-3763736570-swapped.png",
  "2026-02-22/00290-3763736570-swapped.png",
  "2026-02-22/00291-3763736570-swapped.png",
  "2026-02-22/00292-2981751941-swapped.png",
  "2026-02-22/00293-3763736570-swapped.png"
];
    
    // Function to clear all caches and reset state
    function clearAllCaches() {
      // Clear all in-memory caches
      if (typeof imageDates !== 'undefined') imageDates.clear();
      if (typeof imageMetadataCache !== 'undefined') imageMetadataCache.clear();
      if (typeof imageSearchIndex !== 'undefined') imageSearchIndex.clear();
      if (typeof imageDimensionsCache !== 'undefined') imageDimensionsCache.clear();
      if (typeof favoriteOriginalPaths !== 'undefined') favoriteOriginalPaths.clear();
      if (typeof imageIdToPath !== 'undefined') imageIdToPath.clear();
      if (typeof pathToImageId !== 'undefined') pathToImageId.clear();
      
      // Clear layout cache
      layoutCache = null;
      
      // Reset state flags
      if (typeof metadataFetchInProgress !== 'undefined') metadataFetchInProgress = false;
      if (typeof initialPageLoaded !== 'undefined') initialPageLoaded = false;
      
      // Clear any pending timeouts
      if (typeof window.finalLayoutTimeout !== 'undefined' && window.finalLayoutTimeout) {
        clearTimeout(window.finalLayoutTimeout);
        window.finalLayoutTimeout = null;
      }
      if (typeof window.imageLoadLayoutTimeout !== 'undefined' && window.imageLoadLayoutTimeout) {
        clearTimeout(window.imageLoadLayoutTimeout);
        window.imageLoadLayoutTimeout = null;
      }
      if (typeof resizeThrottle !== 'undefined' && resizeThrottle) {
        clearTimeout(resizeThrottle);
        resizeThrottle = null;
      }
      if (typeof searchDebounce !== 'undefined' && searchDebounce) {
        clearTimeout(searchDebounce);
        searchDebounce = null;
      }
      
      // Clear retry check interval if it exists
      if (typeof window.retryCheckInterval !== 'undefined' && window.retryCheckInterval) {
        clearInterval(window.retryCheckInterval);
        window.retryCheckInterval = null;
      }
      
      // Clear processing status
      clearProcessingStatus();
      
      debugLog('[Cache] All caches cleared');
    }

    function updateFolderUI(pathValue) {
      currentBaseFolder = pathValue || '';
      const changeFolderBtn = document.getElementById('changeFolderBtn');
      const formatTitlePath = (inputPath) => {
        if (!inputPath) return '';
        let result = inputPath;
        if (/^[A-Za-z]:[\\/]/.test(result)) {
          result = result.substring(2);
        }
        if (result && !result.startsWith('\\') && !result.startsWith('/')) {
          result = '\\' + result;
        }
        return result;
      };
      const titlePath = formatTitlePath(currentBaseFolder);
      if (changeFolderBtn) {
        changeFolderBtn.title = currentBaseFolder
          ? `Change Folder\n${currentBaseFolder}`
          : 'Change Folder';
      }
      document.title = currentBaseFolder
        ? `Diffusion Darkroom [ ${titlePath} ]`
        : 'Diffusion Darkroom';
      if (window.pywebview && window.pywebview.api && typeof window.pywebview.api.set_title === 'function') {
        window.pywebview.api.set_title(document.title).catch(() => {});
      }
    }

    function showIdleLandingText() {
      setStartupLandingVisible(true);
    }

    function setStartupLandingVisible(show) {
      const landing = document.getElementById('startupLanding');
      const loadingScreen = document.getElementById('loadingScreen');
      if (loadingScreen) {
        loadingScreen.classList.add('hidden');
      }
      if (show) {
        document.body.classList.add('startup-mode');
        updateFolderUI('');
      } else {
        document.body.classList.remove('startup-mode');
      }
      if (landing) {
        if (show) {
          landing.classList.add('visible');
        } else {
          landing.classList.remove('visible');
        }
      }
    }

    async function fetchCurrentBaseFolder() {
      const response = await fetch('/current-base-folder', {
        method: 'GET',
        cache: 'no-store',
        headers: {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        }
      });
      if (!response.ok) {
        throw new Error(`Failed to get current folder: ${response.status}`);
      }
      const data = await response.json();
      updateFolderUI(data.baseFolder || '');
      return data;
    }

    async function requestFolderSelection(openPicker = true) {
      const response = await fetch('/select-base-folder', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(openPicker ? {} : { folder: currentBaseFolder || '' })
      });
      if (!response.ok) {
        const err = await response.json().catch(() => ({}));
        throw new Error(err.error || `Folder selection failed (${response.status})`);
      }
      const data = await response.json();
      if (data.baseFolder) {
        updateFolderUI(data.baseFolder);
      }
      return data;
    }

    async function initializeFolderSelectionFlow() {
      try {
        // Read current server state for diagnostics/title sync, but do not auto-load.
        await fetchCurrentBaseFolder();
      } catch (err) {
        console.error('Failed to initialize folder selection:', err);
      }
      initializeGallery([]);
      showIdleLandingText();
    }
    
    // Function to initialize/reinitialize the gallery
    function initializeGallery(imageList) {
      // Clear all caches first to ensure fresh start
      clearAllCaches();
      // Load favorites history from localStorage on init
      loadFavoritesHistory();
      
      // Check for favorited images without history entries and create them
      // This handles images that were favorited before history tracking was added
      const todayFolder = getTodayDateFolder();
      let historyUpdated = false;
      
      imageList.forEach(filename => {
        const normalizedFilename = filename.replace(/\\/g, '/');
        const isFavorited = normalizedFilename.startsWith('Favorites/') || 
                           normalizedFilename.includes('/Favorites/');
        
        if (isFavorited) {
          // Check if this favorited image has a history entry
          const existingHistory = getOriginalPathFromHistory(normalizedFilename);
          if (!existingHistory) {
            // No history entry exists - create one with today's date folder
            const fileName = normalizedFilename.split(/[/\\]/).pop();
            const originalPath = `${todayFolder}/${fileName}`;
            addToHistory(normalizedFilename, originalPath);
            historyUpdated = true;
            debugLog('Created history entry for favorited image without history:', normalizedFilename, '->', originalPath);
          }
        }
      });
      
      if (historyUpdated) {
        debugLog('Updated favorites history for images without original path tracking');
      }
      
      allImageFiles = imageList.map(normalizeImagePath);
      rebuildImageIdentityMaps(allImageFiles);
      const gallery = document.getElementById('gallery');
      gallery.innerHTML = '';
      allImageContainers = [];
      galleryColumns = [];
      
      // Reset pagination
      currentPage = 1;
      
      // Reset filters and sort
      sortState = { field: 'filename', direction: 'asc' };
      showFavoritesOnly = false;
      activeModelFilter = null;
      
      // Clear search input
      const searchInput = document.getElementById('searchInput');
      if (searchInput) {
        searchInput.value = '';
      }
      
      // Reset sort button icons
      updateSortButtonIcons();
      
      // Initialize image count without full-library size scan during startup.
      updateImageCount(true);
      
      // Initialize pagination - don't create all images upfront
      const totalImages = allImageFiles.length;
      
      // Initialize filtered arrays (all images initially)
      filteredImageFiles = [...allImageFiles];
      
      // Initialize pagination UI
      updatePaginationUI();
      
      // Load first page (this will create images for first page only and show loading bar)
      // The loadCurrentPage function will handle showing/hiding the loading bar
      loadCurrentPage();
      
      // Update image count - skip size calculation during initial load to avoid blocking
      setTimeout(() => updateImageCount(true), 100);
    }
    
    // Function to reload images by calling the rescan API endpoint
    async function reloadImages() {
      const reloadBtn = document.getElementById('reloadBtn');
      if (!reloadBtn) return;
      
      // Show loading state
      reloadBtn.classList.add('loading');
      reloadBtn.disabled = true;
      
      // PRESERVE all user state before reloading
      const searchInput = document.getElementById('searchInput');
      const preservedSearchQuery = searchInput ? searchInput.value : '';
      const preservedShowFavoritesOnly = showFavoritesOnly;
      const preservedActiveModelFilter = activeModelFilter;
      const preservedActiveRatingFilters = new Set(activeRatingFilters); // Clone the Set
      const preservedSortState = { ...sortState }; // Clone the sort state
      const preservedCurrentPage = currentPage;
      const preservedImagesPerPage = imagesPerPage;
      const preservedSizeMultiplier = currentSizeMultiplier;
      
      // Clear all caches before reloading
      clearAllCaches();
      
      try {
        // Call the rescan endpoint to get updated image list with cache-busting
        const timestamp = new Date().getTime();
        const response = await fetch(`/rescan-images?t=${timestamp}`, {
          cache: 'no-store',
          method: 'GET',
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          }
        });
        
        if (!response.ok) {
          throw new Error(`Failed to rescan images: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data.error) {
          throw new Error(data.error);
        }
        if (data.baseFolder !== undefined) {
          updateFolderUI(data.baseFolder || '');
        }
        if (!data.baseFolder) {
          initializeGallery([]);
          setStartupLandingVisible(true);
          return;
        }
        
        if (!data.images || !Array.isArray(data.images)) {
          throw new Error('Invalid response format from server');
        }
        
        // Reinitialize gallery with new image list (this resets everything)
        initializeGallery(data.images);
        setStartupLandingVisible(false);
        
        // RESTORE preserved state
        // Restore search query
        if (searchInput && preservedSearchQuery) {
          searchInput.value = preservedSearchQuery;
        }
        
        // Restore filters
        showFavoritesOnly = preservedShowFavoritesOnly;
        activeModelFilter = preservedActiveModelFilter;
        activeRatingFilters = preservedActiveRatingFilters;
        
        // Restore sort state (validated)
        sortState = normalizeSortState(preservedSortState);
        
        // Restore pagination settings
        imagesPerPage = preservedImagesPerPage;
        currentSizeMultiplier = preservedSizeMultiplier;
        
        // Update UI elements to reflect restored state
        // Update favorites filter button
        const favoritesFilterBtn = document.getElementById('favoritesFilter');
        if (favoritesFilterBtn) {
          if (showFavoritesOnly) {
            favoritesFilterBtn.classList.add('favorites-active');
          } else {
            favoritesFilterBtn.classList.remove('favorites-active');
          }
        }
        
        // Update model filter buttons
        document.querySelectorAll('.model-filter-btn').forEach(btn => {
          if (btn.dataset.model === activeModelFilter) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
        
        // Update rating filter stars (clear all first, then set active ones)
        document.querySelectorAll('.rating-filter-star').forEach(star => {
          star.classList.remove('active');
        });
        activeRatingFilters.forEach(rating => {
          const ratingStar = document.querySelector(`.rating-filter-star[data-rating="${rating}"]`);
          if (ratingStar) {
            ratingStar.classList.add('active');
          }
        });
        
        // Update page size selector
        document.querySelectorAll('.pagination-page-size-item').forEach(item => {
          if (parseInt(item.getAttribute('data-size')) === imagesPerPage) {
            item.classList.add('active');
          } else {
            item.classList.remove('active');
          }
        });
        
        // Update size slider
        const sizeSlider = document.getElementById('sizeSlider');
        if (sizeSlider) {
          sizeSlider.value = preservedSizeMultiplier.toString();
        }
        
        // Update sort button icons
        updateSortButtonIcons();
        
        // Reapply preserved sort before filters/page restore
        await applyCurrentSortToAllImageFiles({
          showStatus: sortState.field === 'date',
          logAction: false,
        });
        if (sortState.field === 'date') {
          clearProcessingStatus();
        }
        
        // Reapply all filters (this updates filteredImageFiles)
        filterImages(preservedSearchQuery, null);
        
        // Adjust current page if needed (in case filtered results have fewer pages)
        const totalPages = getTotalPages();
        if (preservedCurrentPage > totalPages && totalPages > 0) {
          currentPage = totalPages;
        } else {
          currentPage = preservedCurrentPage;
        }
        
        // Update pagination UI with restored page
        updatePaginationUI();
        
        // Load the current page
        loadCurrentPage(false);
        
        // Update image count
        updateImageCount();
        
        // Update image sizes to reflect preserved size multiplier
        updateImageSizes();
        
        // Update the embedded image list in the HTML file to keep it in sync
        try {
          const updateResponse = await fetch('/update-embedded-list', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              images: data.images
            })
          });
          
          if (updateResponse.ok) {
            debugLog(`[Reload] Updated embedded image list in HTML file`);
          } else {
            debugLog(`[Reload] Failed to update embedded image list (non-critical)`);
          }
        } catch (updateError) {
          // Non-critical - if update fails, the app still works with API data
          debugLog(`[Reload] Could not update embedded image list: ${updateError.message}`);
        }
        
        debugLog(`[Reload] Reloaded ${data.count} images and restored user preferences`);
        logToServer('reload_complete', { count: data.count });
        
      } catch (error) {
        console.error('Error reloading images:', error);
        alert(`Failed to reload images: ${error.message}\n\nPlease make sure the Python server is running.`);
      } finally {
        // Remove loading state
        reloadBtn.classList.remove('loading');
        reloadBtn.disabled = false;
      }
    }
    
    // Clear caches on page unload to ensure fresh start on next load
    window.addEventListener('beforeunload', function() {
      clearAllCaches();
    });
    
    function isReloadNavigation() {
      try {
        const navEntries = performance.getEntriesByType && performance.getEntriesByType('navigation');
        if (navEntries && navEntries.length > 0 && navEntries[0] && navEntries[0].type) {
          return navEntries[0].type === 'reload';
        }
      } catch (e) {}
      try {
        // Legacy fallback
        if (performance && performance.navigation) {
          return performance.navigation.type === 1;
        }
      } catch (e) {}
      return false;
    }

    // Detect explicit browser refresh and trigger image rescan.
    // pageshow can fire in other lifecycle cases, so guard hard here.
    window.addEventListener('pageshow', function() {
      if (sessionStorage.getItem('darkroomInitialLoadComplete') !== 'true') return;
      if (!isReloadNavigation()) return;
      reloadImages();
    });
    
    // Note: Removed visibilitychange handler that was clearing caches on tab switch.
    // This was causing the app to refresh and lose scroll position when switching tabs.
    // Caches are already cleared on beforeunload and initial page load, which is sufficient.
    
    // Use embedded image list directly
    (function() {
      // Clear all caches on page load to ensure fresh start
      clearAllCaches();
      
      // Initialize UI from settings (must happen before gallery initialization)
      initializeModelFilters();
      initializeSizeSlider();
      initializePaging();
      
      // Re-attach model filter button event listeners after generating buttons
      function attachModelFilterListeners() {
        const modelFilterBtns = document.querySelectorAll('.model-filter-btn');
        debugLog(`[Model Filter] Found ${modelFilterBtns.length} buttons to attach listeners to`);
        
        if (modelFilterBtns.length === 0) {
          if (DEBUG_MODE) console.error('[Model Filter] No buttons found!');
          return;
        }
        
        modelFilterBtns.forEach((btn, index) => {
          // Remove any existing listeners by cloning
          const newBtn = btn.cloneNode(true);
          btn.parentNode.replaceChild(newBtn, btn);
          
          const model = newBtn.dataset.model;
          const containsText = newBtn.getAttribute('data-contains');
          
          debugLog(`[Model Filter] Attaching listener to button ${index}: ${model} (contains: ${containsText})`);
          
          newBtn.addEventListener('click', async function(e) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            const clickedModel = this.dataset.model;
            const clickedBtn = this;
            updateProcessingStatus(`Applying ${clickedModel} filter...`, true);
            
            debugLog(`[Model Filter] Button clicked: ${clickedModel}`);
            
            // Toggle: if already active, deactivate; otherwise activate this one
            if (activeModelFilter === clickedModel) {
              activeModelFilter = null;
              clickedBtn.classList.remove('active');
              debugLog(`[Model Filter] Deactivated ${clickedModel} filter`);
              logToServer('model_filter', { model: null, action: 'deactivate' });
              // Re-apply filter immediately when deactivating
              const searchInput = document.getElementById('searchInput');
              filterImages(searchInput ? searchInput.value : '');
            } else {
              // Deactivate all buttons first
              document.querySelectorAll('.model-filter-btn').forEach(b => b.classList.remove('active'));
              // Activate this button
              activeModelFilter = clickedModel;
              clickedBtn.classList.add('active');
              
              debugLog(`[Model Filter] Activating ${clickedModel} filter...`);
              logToServer('model_filter', { model: clickedModel, action: 'activate' });
              
              // Keep metadata indexing page-scoped for large libraries.
              try {
                clickedBtn.classList.add('indexing');
                updateModelFilterButtonsState(true, 0);
                
                debugLog(`[Model Filter] Applying ${clickedModel} filter...`);
                
                await fetchAllImageMetadata(false, getCurrentPageFiles());
                
                // Re-apply current search filter (which will also apply model filter)
                const searchInput = document.getElementById('searchInput');
                filterImages(searchInput ? searchInput.value : '');
                
                // Log results
                debugLog(`[Model Filter] Filter applied. Showing ${filteredImageFiles.length} images.`);
                logToServer('model_filter_result', { model: clickedModel, resultCount: filteredImageFiles.length });
              } catch (err) {
                console.error('[Model Filter] Error:', err);
              } finally {
                clickedBtn.classList.remove('indexing');
                updateModelFilterButtonsState(false);
              }
            }
          });
        });
        
        debugLog(`[Model Filter] Successfully attached listeners to ${modelFilterBtns.length} buttons`);
      }
      
      // Attach listeners after a brief delay to ensure DOM is ready
      setTimeout(() => {
        attachModelFilterListeners();
      }, 100);
      
      initializeFolderSelectionFlow();
      
      // Mark that initial load is complete (used to detect browser refresh)
      sessionStorage.setItem('darkroomInitialLoadComplete', 'true');

        // Set up pagination arrow handlers
        const paginationPrev = document.getElementById('paginationPrev');
        const paginationNext = document.getElementById('paginationNext');
        if (paginationPrev) {
          paginationPrev.addEventListener('click', goToPreviousPage);
        }
        if (paginationNext) {
          paginationNext.addEventListener('click', goToNextPage);
        }
        
        // Set up reload button
        const reloadBtn = document.getElementById('reloadBtn');
        if (reloadBtn) {
          reloadBtn.addEventListener('click', reloadImages);
        }
        const changeFolderBtn = document.getElementById('changeFolderBtn');
        if (changeFolderBtn) {
          changeFolderBtn.addEventListener('click', async () => {
            try {
              updateProcessingStatus('Opening folder picker...', true);
              const result = await requestFolderSelection(true);
              if (result.selected) {
                await reloadImages();
              }
            } catch (err) {
              console.error('Folder change failed:', err);
              alert(`Failed to change folder: ${err.message}`);
            } finally {
              clearProcessingStatus();
            }
          });
        }
        const startupSelectFolderBtn = document.getElementById('startupSelectFolder');
        if (startupSelectFolderBtn) {
          startupSelectFolderBtn.addEventListener('click', async () => {
            try {
              updateProcessingStatus('Opening folder picker...', true);
              const result = await requestFolderSelection(true);
              if (result.selected) {
                setStartupLandingVisible(false);
                await reloadImages();
              }
            } catch (err) {
              console.error('Startup folder selection failed:', err);
              alert(`Failed to select folder: ${err.message}`);
            } finally {
              clearProcessingStatus();
            }
          });
        }
        // Page size selectors are now set up in initializePaging() function
        // which is called earlier in the initialization sequence
        
        // Set up auto-hide/show for top and bottom bars based on mouse proximity
        const topNav = document.querySelector('.top-nav');
        const bottomNav = document.getElementById('bottomNav');
        const pageSizeStandalone = document.getElementById('bottomNavPageSizeStandalone');
        const PROXIMITY_THRESHOLD = 45; // pixels from top/bottom edge (reduced for smaller activation area)
        
        let mouseY = -1; // Initialize to -1 so we know it hasn't been set yet
        let showBarsTimeout = null;
        
        // SIMPLIFIED BAR VISIBILITY - Single source of truth
        // Rules:
        // 1. Show bottom bar if loading/processing
        // 2. Show top AND bottom bars if mouse near edges
        // 3. Otherwise hide both
        window.updateBarsVisibility = function() {
          if (typeof applyScrollbarInsets === 'function') {
            applyScrollbarInsets();
          }
          const windowHeight = window.innerHeight;
          const currentMouseY = mouseY < 0 ? windowHeight / 2 : mouseY;
          const nearTop = currentMouseY <= PROXIMITY_THRESHOLD;
          const nearBottom = currentMouseY >= (windowHeight - PROXIMITY_THRESHOLD);
          const isHoveringTopNav = !!(topNav && topNav.matches(':hover'));
          const isSliderInteractionActive = window.__ddrSliderInteractionActive === true;
          
          // Check if loading/processing is active
          const loadingBarContainer = document.getElementById('loadingBarContainer');
          const processingIndicator = document.getElementById('processingIndicator');
          const isCurrentlyLoading = loadingBarContainer && !loadingBarContainer.classList.contains('hidden');
          const isProcessing = processingIndicator && processingIndicator.classList.contains('active');
          const isLoadingOrProcessing = isCurrentlyLoading || isProcessing;
          
          // Determine visibility
          const showTopBar = nearTop || isLoadingOrProcessing || isHoveringTopNav || isSliderInteractionActive;
          const showBottomBar = nearBottom || isLoadingOrProcessing;
          
          // Apply visibility
          if (topNav) {
            if (showTopBar) {
              topNav.classList.add('visible');
            } else {
              topNav.classList.remove('visible');
            }
          }
          
          if (bottomNav && !bottomNav.classList.contains('hidden')) {
            if (showBottomBar) {
              bottomNav.classList.add('visible');
            } else {
              bottomNav.classList.remove('visible');
            }
          }
          
          if (pageSizeStandalone && !pageSizeStandalone.classList.contains('hidden')) {
            if (showBottomBar) {
              pageSizeStandalone.classList.add('visible');
            } else {
              pageSizeStandalone.classList.remove('visible');
            }
          }
          
          // Update gallery spacing
          const gallery = document.getElementById('gallery');
          if (gallery) {
            if (showTopBar) {
              gallery.classList.add('top-bar-visible');
            } else {
              gallery.classList.remove('top-bar-visible');
            }
          }
        }
        
        // Track mouse position - update visibility on every mouse move
        let lastMouseY = -1;
        document.addEventListener('mousemove', function(e) {
          mouseY = e.clientY;
          // Always update visibility on mouse move to ensure bars show/hide correctly
          // Only skip if position hasn't changed significantly (optimization)
          if (Math.abs(mouseY - lastMouseY) > 5 || lastMouseY < 0) {
            lastMouseY = mouseY;
            updateBarsVisibility();
          }
          
          // Clear any existing timeout
          if (showBarsTimeout) {
            clearTimeout(showBarsTimeout);
          }
        });
        
        
        // Hide bars when mouse leaves window (with delay)
        document.addEventListener('mouseleave', function() {
          showBarsTimeout = setTimeout(() => {
            // Set mouseY to middle so bars hide
            mouseY = window.innerHeight / 2;
            updateBarsVisibility();
          }, 1000); // Hide after 1 second of mouse leaving
        });
        
        // Show bars when mouse enters window
        document.addEventListener('mouseenter', function() {
          if (showBarsTimeout) {
            clearTimeout(showBarsTimeout);
            showBarsTimeout = null;
          }
          // Only update visibility, don't force show
          updateBarsVisibility();
        });
        
        // Initial check on page load - ensure bars start hidden
        // Set mouseY to middle of screen so bars don't show by default
          if (mouseY < 0) {
            mouseY = window.innerHeight / 2;
          }
        // Call updateBarsVisibility to set initial state (bars hidden since mouse in middle)
          updateBarsVisibility();
        
        // Set up search input listener
        const searchInput = document.getElementById('searchInput');
        const searchClear = document.getElementById('searchClear');
        
        function updateClearButton() {
          if (searchInput.value.length > 0) {
            searchClear.classList.add('visible');
          } else {
            searchClear.classList.remove('visible');
          }
        }
        
        searchInput.addEventListener('input', function(e) {
          const query = e.target.value;
          updateClearButton();
          
          // Debounce search filtering for better performance
          if (searchDebounce) {
            clearTimeout(searchDebounce);
          }
          searchDebounce = setTimeout(() => {
            filterImages(query);
            searchDebounce = null;
          }, 150);
        });
        
        // Clear button click handler
        searchClear.addEventListener('click', function(e) {
          e.preventDefault();
          searchInput.value = '';
          filterImages('');
          updateClearButton();
          searchInput.focus();
        });
        
        // Handle window resize with throttling
        // Preserve scroll position during resize-triggered layout updates
        window.addEventListener('resize', function() {
          if (resizeThrottle) {
            clearTimeout(resizeThrottle);
          }
          resizeThrottle = setTimeout(() => {
            layoutCache = null; // Invalidate cache on resize
            // Use non-blocking layout update to allow scrolling during resize
            if (window.requestIdleCallback) {
              window.requestIdleCallback(() => {
            layoutMasonry();
              }, { timeout: 1000 });
            } else {
              requestAnimationFrame(() => {
                layoutMasonry();
              });
            }
            resizeThrottle = null;
          }, 150);
        });
    })();

    // Size control handlers
    function updateImageSizes() {
      // Preserve scroll position
      const scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop;
      
      // Show processing status
      updateProcessingStatus('Resizing images...', true);
      
      // Cancel any pending layout operations to prevent conflicts
      if (typeof window.finalLayoutTimeout !== 'undefined' && window.finalLayoutTimeout) {
        clearTimeout(window.finalLayoutTimeout);
        window.finalLayoutTimeout = null;
      }
      
      const newMaxWidth = baseColumnWidth * currentSizeMultiplier;
      
      // Update all image sizes and recalculate wrapper heights
      // Single loop to minimize DOM queries and operations
      allImageContainers.forEach(container => {
        const wrapper = container.querySelector('.image-wrapper');
        const img = container.querySelector('img');
        
        if (wrapper) {
          wrapper.style.maxWidth = newMaxWidth + 'px';
          // Reset minHeight to allow recalculation
          wrapper.style.minHeight = 'auto';
        }
        
        if (img) {
          img.style.maxWidth = newMaxWidth + 'px';
          
          // Recalculate wrapper height based on actual image dimensions
          // This is critical when shrinking - ensures wrapper shrinks with image
          if (img.complete && img.naturalWidth > 0 && img.naturalHeight > 0) {
            const aspectRatio = img.naturalHeight / img.naturalWidth;
            const newHeight = newMaxWidth * aspectRatio;
            if (wrapper) {
              wrapper.style.minHeight = newHeight + 'px';
            }
          }
        }
      });
      
      // Invalidate layout cache on size change
      layoutCache = null;
      
      // Force layout recalculation with a delay to allow browser to recalculate image dimensions
      // This is especially important when going from larger to smaller sizes
      // Need more time for browser to recalculate when shrinking
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          // Additional delay to ensure dimensions are fully recalculated
          // Longer delay when shrinking to allow browser to properly resize images
          setTimeout(() => {
            // Double-check containers still exist before layout
            if (allImageContainers && allImageContainers.length > 0) {
              // Verify and fix wrapper heights in a single pass
              const expectedMultiplier = baseColumnWidth * currentSizeMultiplier;
              let needsRecalc = false;
              
              for (let i = 0; i < allImageContainers.length; i++) {
                const container = allImageContainers[i];
                const wrapper = container.querySelector('.image-wrapper');
                const img = container.querySelector('img');
                
                // Double-check wrapper height is correct
                if (wrapper && img && img.complete && img.naturalWidth > 0) {
                  const aspectRatio = img.naturalHeight / img.naturalWidth;
                  const expectedHeight = expectedMultiplier * aspectRatio;
                  const currentMinHeight = parseFloat(wrapper.style.minHeight) || 0;
                  
                  // If height is significantly off, recalculate
                  if (Math.abs(currentMinHeight - expectedHeight) > 10) {
                    wrapper.style.minHeight = expectedHeight + 'px';
                    needsRecalc = true;
                  }
                }
              }
              
              // Only force reflow if we made changes
              if (needsRecalc) {
                allImageContainers[0] && void allImageContainers[0].offsetHeight;
              }
              
              // layoutMasonry() now preserves scroll position internally
              // Use non-blocking update to allow scrolling during resize
              if (window.requestIdleCallback) {
                window.requestIdleCallback(() => {
              layoutMasonry();
                  clearProcessingStatus();
                }, { timeout: 1000 });
              } else {
                requestAnimationFrame(() => {
                  layoutMasonry();
                  clearProcessingStatus();
                });
              }
            } else {
              clearProcessingStatus();
            }
          }, 100); // Increased delay to ensure browser has fully recalculated dimensions
        });
      });
    }

    // Size slider functionality with smooth updates
    // Initialize from settings - generate model filter buttons
    function initializeModelFilters() {
      const modelFiltersContainer = document.getElementById('modelFilters');
      if (!modelFiltersContainer) return;
      
      // Clear existing buttons (except status)
      const statusEl = modelFiltersContainer.querySelector('.model-filters-status');
      modelFiltersContainer.innerHTML = '';
      if (statusEl) {
        modelFiltersContainer.appendChild(statusEl);
      }
      
      // Generate buttons from settings
      MODEL_FILTERS.forEach(filter => {
        const btn = document.createElement('button');
        btn.className = 'model-filter-btn';
        btn.setAttribute('data-model', filter.containsText.toLowerCase());
        btn.setAttribute('data-contains', filter.containsText);
        btn.setAttribute('data-label', `Toggle ${filter.label}`);
        btn.textContent = filter.label;
        modelFiltersContainer.insertBefore(btn, statusEl);
      });
    }
    
    // Initialize size slider from settings
    function initializeSizeSlider() {
      const sizeSlider = document.getElementById('sizeSlider');
      if (!sizeSlider) return;
      
      const minMultiplier = IMAGE_SIZE_SETTINGS.min / IMAGE_SIZE_SETTINGS.min; // Always 1.0
      const maxMultiplier = IMAGE_SIZE_SETTINGS.max / IMAGE_SIZE_SETTINGS.min;
      const defaultMultiplier = IMAGE_SIZE_SETTINGS.default / IMAGE_SIZE_SETTINGS.min;
      
      sizeSlider.min = minMultiplier.toString();
      sizeSlider.max = maxMultiplier.toString();
      sizeSlider.step = IMAGE_SIZE_SETTINGS.step.toString();
      sizeSlider.value = defaultMultiplier.toString();
      
      // Update current multiplier
      currentSizeMultiplier = defaultMultiplier;
    }
    
    // Initialize paging from settings
    function initializePaging() {
      // Set up page size selectors directly (don't regenerate - use existing HTML)
      const paginationPageSize = document.getElementById('paginationPageSize');
      const paginationPageSizeStandalone = document.getElementById('bottomNavPageSizeStandalone');
      
      // Set up event listeners for the main pagination page size selector
      if (paginationPageSize) {
        const pageSizeItems = paginationPageSize.querySelectorAll('.pagination-page-size-item');
        pageSizeItems.forEach(item => {
          // Remove any existing listeners by cloning
          const newItem = item.cloneNode(true);
          // Add data-label attribute for hover popup
          const sizeValue = newItem.getAttribute('data-size');
          newItem.setAttribute('data-label', `${sizeValue} Images Per Page`);
          item.parentNode.replaceChild(newItem, item);
          
          // Add click listener
          newItem.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const newSize = parseInt(this.getAttribute('data-size'));
            debugLog(`[Page Size] Clicked on size: ${newSize}, current: ${imagesPerPage}`);
            if (newSize !== imagesPerPage) {
              // Preserve scroll position
              const scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop;
              
              // Show processing status
              updateProcessingStatus('Changing page size...', true);
              
              debugLog(`[Page Size] Changed to ${newSize} images per page`);
              logToServer('page_size_change', { size: newSize });
              imagesPerPage = newSize;
              
              // Update active state in both containers
              document.querySelectorAll('.pagination-page-size-item').forEach(i => {
                if (parseInt(i.getAttribute('data-size')) === newSize) {
                  i.classList.add('active');
                } else {
                  i.classList.remove('active');
                }
              });
              
              // Invalidate layout cache before reloading
              layoutCache = null;
              // Reset to page 1
              currentPage = 1;
              // Update pagination UI first (this updates page count)
              updatePaginationUI();
              // Then reload images with new page size
              loadCurrentPage(false);
              
              // Restore scroll position after layout
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  window.scrollTo(0, scrollY);
                  document.documentElement.scrollTop = scrollY;
                  document.body.scrollTop = scrollY;
                  clearProcessingStatus();
                });
              });
          }
        });
      });
      }
      
      // Set up event listeners for the standalone page size selector
      if (paginationPageSizeStandalone) {
        const standalonePageSize = paginationPageSizeStandalone.querySelector('.pagination-page-size');
        if (standalonePageSize) {
          const pageSizeItems = standalonePageSize.querySelectorAll('.pagination-page-size-item');
          pageSizeItems.forEach(item => {
            // Remove any existing listeners by cloning
            const newItem = item.cloneNode(true);
            // Add data-label attribute for hover popup
            const sizeValue = newItem.getAttribute('data-size');
            newItem.setAttribute('data-label', `${sizeValue} Images Per Page`);
            item.parentNode.replaceChild(newItem, item);
            
            // Add click listener (same handler as above)
            newItem.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              const newSize = parseInt(this.getAttribute('data-size'));
              debugLog(`[Page Size] Clicked on size: ${newSize}, current: ${imagesPerPage}`);
              if (newSize !== imagesPerPage) {
                // Preserve scroll position
                const scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop;
                
                // Show processing status
                updateProcessingStatus('Changing page size...', true);
                
                debugLog(`[Page Size] Changed to ${newSize} images per page`);
                logToServer('page_size_change', { size: newSize });
                imagesPerPage = newSize;
                
                // Update active state in both containers
                document.querySelectorAll('.pagination-page-size-item').forEach(i => {
                  if (parseInt(i.getAttribute('data-size')) === newSize) {
                    i.classList.add('active');
                  } else {
                    i.classList.remove('active');
                  }
                });
                
                // Invalidate layout cache before reloading
                layoutCache = null;
                // Reset to page 1
                currentPage = 1;
                // Update pagination UI first (this updates page count)
                updatePaginationUI();
                // Then reload images with new page size
                loadCurrentPage(false);
                
                // Restore scroll position after layout
                requestAnimationFrame(() => {
                  requestAnimationFrame(() => {
                    window.scrollTo(0, scrollY);
                    document.documentElement.scrollTop = scrollY;
                    document.body.scrollTop = scrollY;
                    clearProcessingStatus();
                  });
                });
              }
            });
          });
        }
      }
    }
    
    // Initialize everything from settings
    initializeModelFilters();
    initializeSizeSlider();
    initializePaging();
    
    const sizeSlider = document.getElementById('sizeSlider');
    let sizeUpdatePending = false;
    let sizeUpdateRafId = null;
    
    if (sizeSlider) {
      function updateSizeSliderVisualFill() {
        const minValue = parseFloat(sizeSlider.min || '0');
        const maxValue = parseFloat(sizeSlider.max || '1');
        const currentValue = parseFloat(sizeSlider.value || '0');
        const range = maxValue - minValue;
        const ratio = range > 0 ? (currentValue - minValue) / range : 0;
        const percent = Math.max(0, Math.min(100, ratio * 100));
        sizeSlider.style.setProperty('--ddr-slider-fill', `${percent}%`);
      }

      // Smooth size update using requestAnimationFrame
      function scheduleSizeUpdate() {
        if (sizeUpdatePending) return;
        sizeUpdatePending = true;
        
        if (sizeUpdateRafId) {
          cancelAnimationFrame(sizeUpdateRafId);
        }
        
        sizeUpdateRafId = requestAnimationFrame(() => {
          updateImageSizes();
          sizeUpdatePending = false;
          sizeUpdateRafId = null;
        });
      }
      
      // Update width popup
      const widthPopup = document.getElementById('sizeSliderWidthPopup');
      function updateWidthPopup() {
        if (widthPopup) {
          const pixelWidth = Math.round(baseColumnWidth * currentSizeMultiplier);
          widthPopup.textContent = pixelWidth + 'px';
        }
      }
      
      // Track dragging state
      let isDragging = false;
      
      // Handle slider mousedown (start dragging)
      sizeSlider.addEventListener('mousedown', function() {
        isDragging = true;
        window.__ddrSliderInteractionActive = true;
        this.classList.add('dragging');
        updateWidthPopup();
        if (typeof window.updateBarsVisibility === 'function') {
          window.updateBarsVisibility();
        }
      });
      
      // Handle slider mouseup (stop dragging)
      sizeSlider.addEventListener('mouseup', function() {
        isDragging = false;
        window.__ddrSliderInteractionActive = false;
        this.classList.remove('dragging');
        if (typeof window.updateBarsVisibility === 'function') {
          window.updateBarsVisibility();
        }
      });
      
      // Handle slider mouseleave (stop dragging if mouse leaves)
      sizeSlider.addEventListener('mouseleave', function(e) {
        if (e.buttons === 1) return;
        isDragging = false;
        window.__ddrSliderInteractionActive = false;
        this.classList.remove('dragging');
      });
      
      // Handle slider input (real-time updates with throttling)
      sizeSlider.addEventListener('input', function() {
        currentSizeMultiplier = parseFloat(this.value);
        updateSizeSliderVisualFill();
        if (isDragging) {
          updateWidthPopup();
        }
        // Schedule smooth update
        scheduleSizeUpdate();
      });
      
      // Handle slider change (when released)
      sizeSlider.addEventListener('change', function() {
        currentSizeMultiplier = parseFloat(this.value);
        updateSizeSliderVisualFill();
        isDragging = false;
        window.__ddrSliderInteractionActive = false;
        this.classList.remove('dragging');
        // Ensure final update is applied
        if (sizeUpdateRafId) {
          cancelAnimationFrame(sizeUpdateRafId);
        }
        updateImageSizes();
        debugLog(`[Size] Changed to ${currentSizeMultiplier}x (${Math.round(baseColumnWidth * currentSizeMultiplier)}px)`);
        logToServer('size_change', { multiplier: currentSizeMultiplier, width: Math.round(baseColumnWidth * currentSizeMultiplier) });
      });
      document.addEventListener('mouseup', function() {
        if (!isDragging) return;
        isDragging = false;
        window.__ddrSliderInteractionActive = false;
        sizeSlider.classList.remove('dragging');
        if (typeof window.updateBarsVisibility === 'function') {
          window.updateBarsVisibility();
        }
      });

      updateSizeSliderVisualFill();
      updateWidthPopup();
    }

    function stepImageSizeByPixels(pixelDelta) {
      if (!sizeSlider) return;
      const minPx = IMAGE_SIZE_SETTINGS.min;
      const maxPx = IMAGE_SIZE_SETTINGS.max;
      const currentPx = Math.round(baseColumnWidth * currentSizeMultiplier);
      const nextPx = Math.max(minPx, Math.min(maxPx, currentPx + pixelDelta));
      if (nextPx === currentPx) return;

      currentSizeMultiplier = nextPx / baseColumnWidth;
      sizeSlider.value = String(currentSizeMultiplier);
      sizeSlider.dispatchEvent(new Event('change', { bubbles: true }));
    }

    // Sort functionality
    async function getFileDate(filename) {
      if (imageDates.has(filename)) {
        return imageDates.get(filename);
      }
      
      try {
        // Use fetch with HEAD request (works with http:// protocol)
        const response = await fetch(escapeFilename(filename), { method: 'HEAD' });
        const lastModified = response.headers.get('Last-Modified');
        if (lastModified) {
          const date = new Date(lastModified);
          imageDates.set(filename, date);
          return date;
        }
      } catch (err) {
        // Fallback on error
      }
      
      // Fallback to current date if we can't get the file date
      const date = new Date();
      imageDates.set(filename, date);
      return date;
    }

    function getSortFieldLabel(field) {
      if (field === 'date') return 'Date';
      if (field === 'stars') return 'Stars';
      if (field === 'favorites') return 'Favorites';
      return 'Filename';
    }

    function getSortDirectionToken(field, direction) {
      if (field === 'favorites') {
        return direction === 'desc' ? 'Last' : 'First';
      }
      return direction === 'desc' ? '\u2193' : '\u2191';
    }

    function getSortStatusMessage() {
      if (sortState.field === 'date') return 'Sorting by date...';
      if (sortState.field === 'stars') return 'Sorting by stars...';
      if (sortState.field === 'favorites') return 'Sorting by favorites...';
      return 'Sorting by filename...';
    }

    function normalizeSortState(state) {
      const normalized = (state && typeof state === 'object') ? { ...state } : {};
      const validFields = ['filename', 'date', 'stars', 'favorites'];
      const validDirections = ['asc', 'desc'];
      if (!validFields.includes(normalized.field)) {
        normalized.field = 'filename';
      }
      if (!validDirections.includes(normalized.direction)) {
        normalized.direction = 'asc';
      }
      return normalized;
    }

    function updateSortButtonIcons() {
      const sortControlBtn = document.getElementById('sortControlBtn');
      const sortControlLabel = document.getElementById('sortControlLabel');
      if (!sortControlBtn || !sortControlLabel) return;

      const field = sortState.field || 'filename';
      const direction = sortState.direction === 'desc' ? 'desc' : 'asc';
      const label = `Sort: ${getSortFieldLabel(field)} ${getSortDirectionToken(field, direction)}`;
      sortControlLabel.textContent = label;
      sortControlBtn.classList.add('active');
      sortControlBtn.setAttribute('title', label);

      document.querySelectorAll('[data-sort-field]').forEach((option) => {
        if (option.dataset.sortField === field) {
          option.classList.add('active');
        } else {
          option.classList.remove('active');
        }
      });

      document.querySelectorAll('[data-sort-direction]').forEach((option) => {
        if (option.dataset.sortDirection === direction) {
          option.classList.add('active');
        } else {
          option.classList.remove('active');
        }
      });

      const ascBtn = document.querySelector('[data-sort-direction="asc"]');
      const descBtn = document.querySelector('[data-sort-direction="desc"]');
      if (ascBtn && descBtn) {
        if (field === 'favorites') {
          ascBtn.textContent = 'Favorites First';
          descBtn.textContent = 'Favorites Last';
        } else {
          ascBtn.textContent = 'Ascending';
          descBtn.textContent = 'Descending';
        }
      }
    }

    async function applyCurrentSortToAllImageFiles(options = {}) {
      const showStatus = options.showStatus === true;
      const shouldLog = options.logAction !== false;
      const field = sortState.field || 'filename';
      const direction = sortState.direction === 'desc' ? 'desc' : 'asc';
      const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });

      if (showStatus) {
        updateProcessingStatus(getSortStatusMessage(), true);
      }
      if (shouldLog) {
        logToServer('sort', { by: field, direction });
      }
      debugLog(`[Sort] Sorting by ${field}: ${direction}`);

      if (field === 'date') {
        const BATCH_SIZE = 20;
        const indices = allImageFiles.map((filename, index) => ({ index, filename }));

        for (let i = 0; i < indices.length; i += BATCH_SIZE) {
          const batch = indices.slice(i, i + BATCH_SIZE);
          await Promise.all(batch.map(async (item) => {
            item.date = await getFileDate(item.filename);
          }));

          if (i + BATCH_SIZE < indices.length) {
            await new Promise(resolve => {
              if ('requestIdleCallback' in window) {
                requestIdleCallback(resolve, { timeout: 100 });
              } else {
                setTimeout(resolve, 0);
              }
            });
          }
        }

        indices.sort((a, b) => {
          const delta = a.date.getTime() - b.date.getTime();
          if (delta !== 0) return direction === 'asc' ? delta : -delta;
          return collator.compare(getPathSortKey(a.filename), getPathSortKey(b.filename));
        });

        allImageFiles = indices.map(item => item.filename);
        return;
      }

      const sorted = [...allImageFiles].sort((a, b) => {
        let result = 0;

        if (field === 'stars') {
          const aRating = parseRatingFromFilename(a);
          const bRating = parseRatingFromFilename(b);
          result = aRating - bRating;
        } else if (field === 'favorites') {
          const aFav = isFavorited(a) ? 1 : 0;
          const bFav = isFavorited(b) ? 1 : 0;
          result = bFav - aFav; // ascending = favorites first
        } else {
          result = collator.compare(
            getPathSortKey(a),
            getPathSortKey(b)
          );
        }

        if (result === 0) {
          result = collator.compare(
            getFilenameOnly(a).toLowerCase(),
            getFilenameOnly(b).toLowerCase()
          );
        }

        return direction === 'asc' ? result : -result;
      });

      allImageFiles = sorted;
    }

    async function applySortAndRefreshUI(options = {}) {
      const preserveScroll = options.preserveScroll !== false;
      const showStatus = options.showStatus !== false;
      const shouldLog = options.logAction !== false;
      const scrollY = preserveScroll
        ? (window.scrollY || window.pageYOffset || document.documentElement.scrollTop)
        : null;

      await applyCurrentSortToAllImageFiles({ showStatus, logAction: shouldLog });

      const searchInput = document.getElementById('searchInput');
      const searchQuery = searchInput ? searchInput.value : '';
      filterImages(searchQuery, scrollY);
      updateSortButtonIcons();

      if (showStatus) {
        setTimeout(() => clearProcessingStatus(), 500);
      }
    }

    function closeSortPopover() {
      const popover = document.getElementById('sortPopover');
      if (popover) popover.classList.remove('open');
    }

    function setupSortControls() {
      const sortControl = document.getElementById('sortControl');
      const sortControlBtn = document.getElementById('sortControlBtn');
      const sortPopover = document.getElementById('sortPopover');
      const sortRefreshBtn = document.getElementById('sortRefreshBtn');
      if (!sortControl || !sortControlBtn || !sortPopover) return;

      sortControlBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        sortPopover.classList.toggle('open');
      });

      sortPopover.querySelectorAll('[data-sort-field]').forEach((option) => {
        option.addEventListener('click', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          const newField = option.dataset.sortField;
          if (!newField) return;

          if (sortState.field !== newField) {
            sortState.field = newField;
            sortState.direction = 'asc';
          }

          closeSortPopover();
          await applySortAndRefreshUI({ preserveScroll: true, showStatus: true, logAction: true });
        });
      });

      sortPopover.querySelectorAll('[data-sort-direction]').forEach((option) => {
        option.addEventListener('click', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          const newDirection = option.dataset.sortDirection;
          if (!newDirection || (newDirection !== 'asc' && newDirection !== 'desc')) return;

          sortState.direction = newDirection;
          if (!sortState.field) {
            sortState.field = 'filename';
          }

          closeSortPopover();
          await applySortAndRefreshUI({ preserveScroll: true, showStatus: true, logAction: true });
        });
      });

      if (sortRefreshBtn) {
        sortRefreshBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          closeSortPopover();
          await applySortAndRefreshUI({ preserveScroll: true, showStatus: true, logAction: true });
        });
      }

      document.addEventListener('click', (e) => {
        if (!sortControl.contains(e.target)) {
          closeSortPopover();
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          closeSortPopover();
        }
      });

      updateSortButtonIcons();
    }

    setupSortControls();
    
    // Favorites filter button
    const favoritesFilterBtn = document.getElementById('favoritesFilter');
    if (favoritesFilterBtn) {
      favoritesFilterBtn.addEventListener('click', function() {
        updateProcessingStatus('Applying favorites filter...', true);
        showFavoritesOnly = !showFavoritesOnly;
        debugLog(`[Filter] Favorites filter: ${showFavoritesOnly ? 'on' : 'off'}`);
        logToServer('favorites_filter', { enabled: showFavoritesOnly });
        if (showFavoritesOnly) {
          this.classList.add('favorites-active');
        } else {
          this.classList.remove('favorites-active');
        }
        
        // Clear layout cache and columns to force fresh rebuild
        layoutCache = null;
        galleryColumns = [];
        
        // Re-apply current search filter (which will also apply favorites filter)
        const searchInput = document.getElementById('searchInput');
        filterImages(searchInput ? searchInput.value : '');
      });
    }
    
    // Rating filter stars
    function setupRatingFilterStars() {
      const ratingFilterContainer = document.getElementById('ratingFilterStars');
      if (!ratingFilterContainer) return;
      
      // Clear existing stars
      ratingFilterContainer.innerHTML = '';
      
      // Create 5 stars (1-5, left to right)
      for (let i = 1; i <= 5; i++) {
        const star = document.createElement('button');
        star.className = 'rating-filter-star';
        star.dataset.rating = i;
        star.setAttribute('aria-label', `Filter by ${i} star${i > 1 ? 's' : ''}`);
        star.setAttribute('data-label', `Toggle ${i} Star${i > 1 ? 's' : ''}`);
        star.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>';
        
        star.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          updateProcessingStatus('Applying rating filter...', true);
          const rating = parseInt(this.dataset.rating, 10);
          
          // Toggle rating filter
          if (activeRatingFilters.has(rating)) {
            activeRatingFilters.delete(rating);
            this.classList.remove('active');
            debugLog(`[Filter] Rating ${rating} filter: off`);
          } else {
            activeRatingFilters.add(rating);
            this.classList.add('active');
            debugLog(`[Filter] Rating ${rating} filter: on`);
          }
          
          logToServer('rating_filter', { rating: rating, enabled: activeRatingFilters.has(rating) });
          
          // Clear layout cache and columns to force fresh rebuild
          layoutCache = null;
          galleryColumns = [];
          
          // Re-apply current search filter (which will also apply rating filters)
          const searchInput = document.getElementById('searchInput');
          filterImages(searchInput ? searchInput.value : '');
        });
        
        ratingFilterContainer.appendChild(star);
      }
    }
    
    // Initialize rating filter stars
    setupRatingFilterStars();
    
    // Model filter buttons are set up in initialization function above
    
    // Lightbox star button - use capture phase to handle before lightbox click
    const lightboxStarButton = document.getElementById('lightboxStarButton');
    if (lightboxStarButton) {
      // Add handler in capture phase to catch it before lightbox handler
      lightboxStarButton.addEventListener('click', async function(e) {
        e.stopPropagation();
        e.preventDefault();
        e.stopImmediatePropagation();
        
        const filename = resolveCurrentFilename(this.dataset.filename, this);
        if (!filename) {
          if (DEBUG_MODE) console.warn('Lightbox star button: no filename');
          return;
        }
        
        debugLog('Lightbox star clicked for:', filename);
        
        // Find the corresponding gallery star button
        const imageId = this.dataset.imageId || getImageIdForPath(filename);
        const galleryStarButton = imageId
          ? document.querySelector(`.star-button[data-image-id="${imageId}"]`)
          : document.querySelector(`.star-button[data-filename="${filename}"]`);
        // Use the lightbox button itself if no gallery button found
        const buttonToUpdate = galleryStarButton || this;
        
        try {
          // Use the dataset filename which should reflect the current path
          await toggleFavorite(filename, buttonToUpdate);
          // Note: toggleFavorite will update both buttons dynamically
        } catch (error) {
          console.error('Error toggling favorite from lightbox:', error);
          alert('Error updating favorite: ' + error.message);
        }
      }, true); // Use capture phase
    }

    // --- Click-and-Hold Zoom with Panning ---
    let zoomActive = false;
    let isPanning = false;
    let mouseDownTime = 0;
    let mouseDownTimer = null;
    let initialClickX = 0;
    let initialClickY = 0;
    let panStartX = 0;
    let panStartY = 0;
    let panOffsetX = 0;
    let panOffsetY = 0;
    let currentZoomScale = 1; // Track current zoom scale
    const HOLD_THRESHOLD = 200; // milliseconds to trigger zoom
    const MIN_ZOOM = 1; // Minimum zoom (100%)
    const MAX_ZOOM = 5; // Maximum zoom (500%)
    const ZOOM_STEP = 0.1; // Zoom increment per wheel step
    
    const lightbox = document.getElementById('lightbox');
    const lightboxImg = document.getElementById('lightboxImg');
    
    // Handle mouse down - start click-and-hold detection
    lightboxImg.addEventListener('mousedown', function(e) {
      if (!lightbox.classList.contains('active')) return;
      
      // Ignore right-clicks (button 2) - let contextmenu handle it
      if (e.button === 2) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      mouseDownTime = Date.now();
      initialClickX = e.clientX;
      initialClickY = e.clientY;
      panStartX = e.clientX;
      panStartY = e.clientY;
      
      // If already zoomed, start panning immediately
      if (zoomActive) {
        isPanning = true;
        lightboxImg.classList.add('panning');
        lightbox.classList.add('hide-cursor');
        return;
      }
      
      // Otherwise, start timer for click-and-hold zoom
      mouseDownTimer = setTimeout(function() {
        if (!zoomActive) {
          zoomActive = true;
          isPanning = true;
          lightboxImg.classList.add('zoomed', 'panning');
          lightbox.classList.add('hide-cursor');
          
          // Zoom to 200% centered on initial click position
          // Recalculate rect to ensure accuracy
          const rect = lightboxImg.getBoundingClientRect();
          const imgX = initialClickX - rect.left;
          const imgY = initialClickY - rect.top;
          const originX = Math.max(0, Math.min(100, (imgX / rect.width) * 100));
          const originY = Math.max(0, Math.min(100, (imgY / rect.height) * 100));
          
          lightboxImg.style.transformOrigin = `${originX}% ${originY}%`;
          currentZoomScale = ZOOM_SETTINGS.default;
          lightboxImg.style.transform = `scale(${currentZoomScale})`;
          
          // Initialize pan offset
          panOffsetX = 0;
          panOffsetY = 0;
          panStartX = initialClickX;
          panStartY = initialClickY;
        }
      }, HOLD_THRESHOLD);
    });
    
    // Handle mouse move - pan when zoomed
    lightboxImg.addEventListener('mousemove', function(e) {
      if (!zoomActive || !isPanning) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      const deltaX = e.clientX - panStartX;
      const deltaY = e.clientY - panStartY;
      
      // Accumulate pan offset
      panOffsetX += deltaX;
      panOffsetY += deltaY;
      
      // Apply transform with pan using current zoom scale
      lightboxImg.style.transform = `scale(${currentZoomScale}) translate(${panOffsetX}px, ${panOffsetY}px)`;
      
      panStartX = e.clientX;
      panStartY = e.clientY;
    });
    
    // Handle mouse up - end panning or trigger click-to-close
    lightboxImg.addEventListener('mouseup', function(e) {
      // Ignore right-clicks (button 2)
      if (e.button === 2) return;
      
      // Don't close if clicking on navigation arrows
      if (e.target.closest('.lightbox-nav-arrow')) {
        return;
      }
      
      e.stopPropagation();
      
      if (mouseDownTimer) {
        clearTimeout(mouseDownTimer);
        mouseDownTimer = null;
      }
      
      const clickDuration = Date.now() - mouseDownTime;
      
      if (isPanning && zoomActive) {
        // End panning and unzoom - return to full size
        isPanning = false;
        zoomActive = false;
        currentZoomScale = 1;
        lightboxImg.classList.remove('panning', 'zoomed');
        lightbox.classList.remove('hide-cursor');
        lightboxImg.style.transform = '';
        lightboxImg.style.transformOrigin = 'center center';
        panOffsetX = 0;
        panOffsetY = 0;
        resetImageSize();
      } else if (clickDuration < HOLD_THRESHOLD && !isNavigating) {
        // Quick click - close lightbox (works for both zoomed and unzoomed)
        // But only if we're not in the middle of rapid navigation
        hideLightbox();
      }
    });
    
    // Handle mouse leave - end panning and unzoom if zoomed
    lightboxImg.addEventListener('mouseleave', function() {
      if (mouseDownTimer) {
        clearTimeout(mouseDownTimer);
        mouseDownTimer = null;
      }
      if (isPanning && zoomActive) {
        // End panning and unzoom - return to full size
        isPanning = false;
        zoomActive = false;
        currentZoomScale = 1;
        lightboxImg.classList.remove('panning', 'zoomed');
        lightbox.classList.remove('hide-cursor');
        lightboxImg.style.transform = '';
        lightboxImg.style.transformOrigin = 'center center';
        panOffsetX = 0;
        panOffsetY = 0;
        resetImageSize();
      } else if (isPanning) {
        isPanning = false;
        lightboxImg.classList.remove('panning');
        lightbox.classList.remove('hide-cursor');
      }
    });
    
    // Click on overlay (not image) to close
    lightbox.addEventListener('click', function(e) {
      // Don't close if navigating, clicking on navigation arrows, or star button
      // Check both the target and if the click originated from within these elements
      const clickedStarButton = e.target.closest('.lightbox-star-button') || 
                                 e.target.classList.contains('lightbox-star-button') ||
                                 e.target.closest('#lightboxStarButton');
      const clickedNavArrow = e.target.closest('.lightbox-nav-arrow');
      
      if (isNavigating || clickedNavArrow || clickedStarButton) {
        e.stopPropagation();
        return;
      }
      
      // Only close if clicking directly on the overlay itself
      // Don't close if clicking on the image container (it contains the star button)
      if (e.target === lightbox) {
        hideLightbox();
      }
    });
    
    // Keyboard navigation and close
    document.addEventListener('keydown', function(e) {
      if (lightbox.classList.contains('active')) {
        if (e.key === 'Escape') {
          hideLightbox();
        } else if (e.key === 'ArrowLeft') {
          navigateLightbox('prev');
        } else if (e.key === 'ArrowRight') {
          navigateLightbox('next');
        }
        return;
      }

      if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
      const target = e.target;
      const tagName = target && target.tagName ? target.tagName.toLowerCase() : '';
      if (target && (target.isContentEditable || tagName === 'input' || tagName === 'textarea' || tagName === 'select')) {
        return;
      }

      e.preventDefault();
      if (e.key === 'ArrowLeft') {
        stepImageSizeByPixels(-50);
      } else {
        stepImageSizeByPixels(50);
      }
    });
    
    // Navigation button click handlers - use capture phase to fire first
    const prevBtn = document.getElementById('lightboxPrev');
    const nextBtn = document.getElementById('lightboxNext');
    
    // Handle navigation clicks - must fire before lightbox click handler
    function handleNavClick(direction, e) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      
      // Navigate
      navigateLightbox(direction);
      
      return false;
    }
    
    // Use capture phase so these fire BEFORE the lightbox click handler
    prevBtn.addEventListener('mousedown', function(e) {
      handleNavClick('prev', e);
    }, true);

    prevBtn.addEventListener('click', function(e) {
      handleNavClick('prev', e);
    }, true);

    nextBtn.addEventListener('mousedown', function(e) {
      handleNavClick('next', e);
    }, true);

    nextBtn.addEventListener('click', function(e) {
      handleNavClick('next', e);
    }, true);
    
    // Arrows are now always visible when navigation is possible
    // No need for mouse position tracking
    
    // Scroll wheel zoom - only when lightbox is active
    lightboxImg.addEventListener('wheel', function(e) {
      if (!lightbox.classList.contains('active')) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      // Determine zoom direction
      const delta = e.deltaY > 0 ? -ZOOM_STEP : ZOOM_STEP;
      const newScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, currentZoomScale + delta));
      
      // Only update if scale actually changed
      if (newScale === currentZoomScale) return;
      
      // Get mouse position relative to image
      const rect = lightboxImg.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      // Calculate zoom origin as percentage
      const originX = (mouseX / rect.width) * 100;
      const originY = (mouseY / rect.height) * 100;
      
      // Update zoom scale
      currentZoomScale = newScale;
      
      // If zooming in, activate zoom state
      if (currentZoomScale > 1 && !zoomActive) {
        zoomActive = true;
        lightboxImg.classList.add('zoomed');
      }
      
      // If zooming back to 1x, deactivate zoom state
      if (currentZoomScale <= 1 && zoomActive) {
        zoomActive = false;
        lightboxImg.classList.remove('zoomed');
        lightboxImg.style.transformOrigin = 'center center';
        panOffsetX = 0;
        panOffsetY = 0;
        resetImageSize();
        return;
      }
      
      // Apply zoom with transform origin at mouse cursor
      lightboxImg.style.transformOrigin = `${originX}% ${originY}%`;
      lightboxImg.style.transform = `scale(${currentZoomScale}) translate(${panOffsetX}px, ${panOffsetY}px)`;
    });

    // --- PNG Metadata Extraction for Stable Diffusion ---
    async function getPngMetadata(url){
      // Check cache first
      if (imageMetadataCache.has(url)) {
        return imageMetadataCache.get(url);
      }
      
      // Use fetch (works with http:// protocol from local server)
      // Fallback to XMLHttpRequest if fetch fails
      let buf;
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        buf = await response.arrayBuffer();
      } catch (err) {
        // Fallback to XMLHttpRequest
        buf = await new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.responseType = 'arraybuffer';
          xhr.onload = function() {
            if (xhr.status === 0 || xhr.status === 200) {
              resolve(xhr.response);
            } else {
              reject(new Error(`Failed to load: ${xhr.status}`));
            }
          };
          xhr.onerror = function() {
            reject(new Error('Network error'));
          };
          xhr.ontimeout = function() {
            reject(new Error('Request timeout'));
          };
          xhr.timeout = 10000; // 10 second timeout
          xhr.send();
        });
      }
      
      const bytes = new Uint8Array(buf);
      let i = 8;
      let metadata = {};
      while(i < bytes.length){
        let length = (
          (bytes[i]<<24) |
          (bytes[i+1]<<16) |
          (bytes[i+2]<<8 ) |
          (bytes[i+3])
        )>>>0;
        let type = String.fromCharCode(...bytes.slice(i+4,i+8));
        if(['tEXt','iTXt','zTXt'].includes(type)){
          let chunkData = bytes.slice(i+8, i+8+length);
          let text = "";
          try {
            text = new TextDecoder("utf-8").decode(chunkData);
          } catch(e) {
            text = String.fromCharCode(...chunkData);
          }
          let keyword, value;
          if(type==="iTXt"){
            let nul = text.indexOf('\x00',9);
            keyword = text.slice(0, nul);
            value = text.slice(nul+1);
          } else {
            let nul = text.indexOf('\x00');
            keyword = text.slice(0, nul);
            value = text.slice(nul+1);
          }
          if (keyword && value) metadata[keyword] = value;
        }
        i += 8+length+4;
      }
      // Cache the metadata for future use
      imageMetadataCache.set(url, metadata);
      return metadata;
    }

    // --- AI Image Generation Parameters Parser ---
    // This function parses the "parameters" field from PNG metadata
    // It handles inconsistent formatting with commas in prompts
    function parseAIParameters(parametersText) {
      if (!parametersText) return {};
      
      const result = {};
      
      // List of parameter names we're looking for (in order of appearance, case-insensitive)
      // Longer names first to avoid partial matches
      const parameterNames = [
        'Hires Distilled CFG Scale',
        'Distilled CFG Scale',
        'Hires CFG Scale',
        'Schedule type',
        'Negative prompt',
        'Hires upscaler',
        'Hires upscale',
        'Hires steps',
        'Hires prompt',
        'Model hash',
        'Denoising strength',
        'CFG scale',
        'Clip skip',
        'Sampler',
        'Steps',
        'Seed',
        'Size',
        'Model',
        'Version',
        'RNG',
        'Lora hashes'
      ];
      
      // Remove "parameters" keyword if present at the start
      let text = parametersText.replace(/^parameters\s*/i, '').trim();
      
      // Find the position of "Negative prompt:" to separate positive prompt
      // IMPORTANT: Only match "Negative prompt:" (not "ADetailer negative prompt" or other variants)
      // Match "Negative prompt:" but NOT "ADetailer negative prompt" or "ADetailer X negative prompt"
      let negativePromptMatch = text.match(/\n\s*Negative prompt\s*:?\s*/i);
      if (!negativePromptMatch) {
        negativePromptMatch = text.match(/(?:^|,\s*)Negative prompt\s*:?\s*/i);
      }
      // Verify it's not part of "ADetailer negative prompt" - check text before the match
      if (negativePromptMatch) {
        const matchIndex = negativePromptMatch.index;
        // Check a reasonable amount of text before the match (up to 30 chars should be enough)
        const checkStart = Math.max(0, matchIndex - 30);
        const beforeMatch = text.substring(checkStart, matchIndex).toLowerCase();
        // Check if "adetailer" appears before "negative prompt" (within reasonable distance)
        if (beforeMatch.includes('adetailer')) {
          negativePromptMatch = null;
        }
      }
      const negativePromptIndex = negativePromptMatch ? negativePromptMatch.index : -1;
      
      if (negativePromptIndex > 0) {
        // Extract positive prompt (everything before "Negative prompt:")
        let positivePrompt = text.substring(0, negativePromptIndex).trim();
        
        // If prompt contains Loras, ensure it ends at the last Lora '>'
        const loraMatches = positivePrompt.match(/<lora:[^>]+>/gi);
        if (loraMatches && loraMatches.length > 0) {
          // Find the position of the last Lora tag
          const lastLoraIndex = positivePrompt.lastIndexOf('>');
          if (lastLoraIndex >= 0) {
            // Extract prompt up to and including the last Lora '>'
            positivePrompt = positivePrompt.substring(0, lastLoraIndex + 1).trim();
          }
        }
        
        if (positivePrompt) {
          result['Prompt'] = positivePrompt;
        }
        
        // Extract negative prompt value (everything after "Negative prompt:" until next parameter or end)
        let negativePromptStart = negativePromptIndex + negativePromptMatch[0].length;
        // Find where negative prompt ends (either at newline before next parameter, or comma before next parameter, or end of text)
        let negativePromptEnd = text.length;
        
        // Look for next parameter after negative prompt (like "Steps:", "Sampler:", etc.)
        // Also check for ADetailer parameters and stop there
        const nextParamMatch = text.substring(negativePromptStart).match(/\n\s*(Steps|Sampler|CFG|Seed|Size|Model|Schedule|Denoising|Hires|Version|Clip|RNG|Lora|ADetailer)\s*:/i);
        if (nextParamMatch) {
          negativePromptEnd = negativePromptStart + nextParamMatch.index;
        } else {
          // Check for comma-separated parameters (including ADetailer)
          const commaParamMatch = text.substring(negativePromptStart).match(/,\s*(Steps|Sampler|CFG|Seed|Size|Model|Schedule|Denoising|Hires|Version|Clip|RNG|Lora|ADetailer)\s*:/i);
          if (commaParamMatch) {
            negativePromptEnd = negativePromptStart + commaParamMatch.index;
          }
        }
        
        let negativePromptValue = text.substring(negativePromptStart, negativePromptEnd).trim();
        // Remove trailing comma or newline if present
        negativePromptValue = negativePromptValue.replace(/,\s*$/, '').replace(/\n\s*$/, '').trim();
        if (negativePromptValue) {
          result['Negative Prompt'] = negativePromptValue;
        }
      } else {
        // Check if text starts directly with a known parameter
        let startsWithParam = false;
        for (const param of parameterNames) {
          const regex = new RegExp(`^${param.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*:`, 'i');
          if (regex.test(text)) {
            startsWithParam = true;
            break;
          }
        }
        // If it doesn't start with a parameter, it's likely the positive prompt
        if (!startsWithParam && text) {
          // But check if there's a parameter later - if so, only take text up to first parameter
          let firstParamIndex = text.length;
          for (const param of parameterNames) {
            const regex = new RegExp(`\\b${param.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*:`, 'i');
            const match = text.match(regex);
            if (match && match.index < firstParamIndex) {
              firstParamIndex = match.index;
            }
          }
          
          let promptText = '';
          if (firstParamIndex < text.length) {
            promptText = text.substring(0, firstParamIndex).trim();
          } else {
            promptText = text;
          }
          
          // If prompt contains Loras, ensure it ends at the last Lora '>'
          const loraMatches = promptText.match(/<lora:[^>]+>/gi);
          if (loraMatches && loraMatches.length > 0) {
            // Find the position of the last Lora tag
            const lastLoraIndex = promptText.lastIndexOf('>');
            if (lastLoraIndex >= 0) {
              // Extract prompt up to and including the last Lora '>'
              promptText = promptText.substring(0, lastLoraIndex + 1).trim();
            }
          }
          
          if (promptText) {
            result['Prompt'] = promptText;
          }
        }
      }
      
      // Extract Loras from the entire text (format: <lora:name:weight>)
      // Deduplicate to avoid showing the same lora multiple times
      const loraMatches = text.match(/<lora:[^>]+>/gi);
      if (loraMatches && loraMatches.length > 0) {
        // Remove duplicates by converting to Set and back to array
        const uniqueLoras = [...new Set(loraMatches)];
        result['Loras'] = uniqueLoras.join(' ');
      }
      
      // Parse parameter: value pairs
      // Strategy: Find ALL parameter-like patterns (any text followed by colon, possibly preceded by comma, newline, or >)
      // This helps us identify boundaries even for parameters we don't care about
      const allParamMatches = [];
      
      // Find all patterns that look like parameters: ", ParameterName:" or "ParameterName:" at start
      // Also matches after newlines or > (for parameters after Loras)
      // Pattern: optional comma+whitespace, newline+whitespace, or >+whitespace, then parameter name, then colon
      // Updated to better handle newlines and ensure we catch all parameters
      // Use a more robust pattern that handles start of line, commas, newlines, and > characters
      const paramPattern = /(?:^|,\s*|\n\s*|>\s*)([A-Za-z][^:\n,]*?)\s*:/g;
      let match;
      while ((match = paramPattern.exec(text)) !== null) {
        const paramName = match[1].trim();
        const fullMatch = match[0];
        // Adjust index to skip leading comma, newline, or >
        let indexOffset = 0;
        if (fullMatch.startsWith(',')) {
          indexOffset = 1;
        } else if (fullMatch.startsWith('\n') || fullMatch.startsWith('>')) {
          // Find where the actual parameter name starts (after whitespace)
          const nameStart = fullMatch.search(/\S/);
          indexOffset = nameStart >= 0 ? nameStart : 0;
        }
        const index = match.index + indexOffset;
        
        allParamMatches.push({
          name: paramName,
          index: index,
          colonIndex: match.index + match[0].length - 1, // Position of the colon
          fullMatch: fullMatch
        });
      }
      
      // Now extract values for parameters we care about
      for (const paramName of parameterNames) {
        // Find all occurrences of this parameter (case-insensitive)
        for (let i = 0; i < allParamMatches.length; i++) {
          const match = allParamMatches[i];
          
          // Check if this match is our parameter (case-insensitive)
          if (match.name.toLowerCase() !== paramName.toLowerCase()) {
            continue;
          }
          
          // Find the start of the value (after the colon)
          let valueStart = match.colonIndex + 1;
          // Skip whitespace after colon
          while (valueStart < text.length && /\s/.test(text[valueStart])) {
            valueStart++;
          }
          
          // Find the end of the value
          // The value ends at the comma before the next parameter, newline before next parameter, or at the end of text
          let valueEnd = text.length;
          
          // Look for the next parameter match (any parameter, not just ones we care about)
          for (let j = i + 1; j < allParamMatches.length; j++) {
            const nextMatch = allParamMatches[j];
            
            // Skip ADetailer parameters - stop value extraction before them
            if (nextMatch.name.toLowerCase().includes('adetailer')) {
              // Find the comma or newline before the ADetailer parameter
              const commaBeforeADetailer = text.lastIndexOf(',', nextMatch.index);
              const newlineBeforeADetailer = text.lastIndexOf('\n', nextMatch.index);
              
              if (commaBeforeADetailer > valueStart && commaBeforeADetailer < nextMatch.index) {
                valueEnd = commaBeforeADetailer;
                break;
              } else if (newlineBeforeADetailer > valueStart && newlineBeforeADetailer < nextMatch.index) {
                valueEnd = newlineBeforeADetailer;
                break;
              } else if (nextMatch.index > valueStart) {
                valueEnd = nextMatch.index;
                break;
              }
              continue; // Skip ADetailer parameters entirely
            }
            
            // For comma-separated parameters (most common), find the comma before the next parameter
            // This handles cases like "Steps: 42, Sampler: ..."
            const commaBeforeNext = text.lastIndexOf(',', nextMatch.index);
            if (commaBeforeNext > valueStart && commaBeforeNext < nextMatch.index) {
              valueEnd = commaBeforeNext;
              break;
            }
            
            // Check if there's a newline before the next parameter (newline-separated format)
            // Only use this if no comma was found, or if newline is closer to the value start
            const newlineBeforeNext = text.lastIndexOf('\n', nextMatch.index);
            if (newlineBeforeNext > valueStart && newlineBeforeNext < nextMatch.index) {
              // Check if there's minimal text between newline and parameter (likely a newline-separated parameter)
              const textBetween = text.substring(newlineBeforeNext + 1, nextMatch.index).trim();
              // If text between is short (just whitespace and parameter name), use newline as boundary
              if (textBetween.length < 50 && (commaBeforeNext <= valueStart || newlineBeforeNext < commaBeforeNext)) {
                valueEnd = newlineBeforeNext;
                break;
              }
            }
            
            // If no comma or newline found, the value might extend to the next parameter start
            if (nextMatch.index > valueStart) {
              valueEnd = nextMatch.index;
              break;
            }
          }
          
          let value = text.substring(valueStart, valueEnd).trim();
          // Remove trailing comma or newline if present
          value = value.replace(/,\s*$/, '').replace(/\n\s*$/, '').trim();
          
          if (value) {
            // Map parameter name to display name
            const displayKey = paramName === 'Negative prompt' ? 'Negative Prompt' : 
                             paramName === 'CFG scale' ? 'CFG Scale' :
                             paramName === 'Distilled CFG Scale' ? 'Distilled CFG Scale' :
                             paramName === 'Schedule type' ? 'Schedule Type' :
                             paramName === 'Hires CFG Scale' ? 'Hires CFG Scale' :
                             paramName === 'Hires upscaler' ? 'Hires Upscaler' :
                             paramName === 'Denoising strength' ? 'Denoising Strength' :
                             paramName === 'Clip skip' ? 'Clip Skip' :
                             paramName;
            
            // Skip ADetailer parameters
            if (!displayKey.toLowerCase().includes('adetailer') && 
                !paramName.toLowerCase().includes('adetailer')) {
              // Store the value (overwrite if already exists - take the first occurrence)
              if (!result[displayKey]) {
                result[displayKey] = value;
              }
            }
          }
        }
      }
      
      return result;
    }

    // --- Format and Display Metadata ---
    function formatMetadataForDisplay(rawMetadata) {
      const displayData = {};
      
      // Parse parameters if present
      if (rawMetadata.parameters) {
        const parsed = parseAIParameters(rawMetadata.parameters);
        Object.assign(displayData, parsed);
      }
      
      // The parser already returns properly formatted keys, so we can use them directly
      // Just filter to only the fields we want to display
      const allowedFields = [
        'Prompt', 'Negative Prompt', 'Model', 'Sampler', 'Schedule Type', 
        'Size', 'Steps', 'Hires steps', 'CFG Scale', 'Distilled CFG Scale', 'Denoising Strength',
        'Hires CFG Scale', 'Hires Upscaler', 'Seed', 'Clip Skip', 'Loras', 'Created Date'
      ];
      
      const finalData = {};
      for (const key of allowedFields) {
        if (displayData[key] !== undefined) {
          finalData[key] = displayData[key];
        }
      }
      
      return finalData;
    }

    async function showMetaTable(metadata, imageSrc){
      const modal = document.getElementById('metaModal');
      const container = document.getElementById('metaTableContent');
      
      if(!metadata || Object.keys(metadata).length==0){
        container.innerHTML = "<b>No metadata found.</b>";
      } else {
        // Parse and format the metadata
        const displayData = formatMetadataForDisplay(metadata);
        
        // Add created date if we have image source
        if (imageSrc) {
          try {
            // Extract filename from URL - imageSrc might be a full URL like "http://localhost:8000/path/to/image.png"
            // We need just the path part for getFileDate
            let filenameForDate = imageSrc;
            try {
              const url = new URL(imageSrc);
              filenameForDate = url.pathname; // Get just the path part
              // Remove leading slash if present
              if (filenameForDate.startsWith('/')) {
                filenameForDate = filenameForDate.substring(1);
              }
            } catch (e) {
              // If it's not a valid URL, use as-is (might already be a filename)
            }
            const date = await getFileDate(filenameForDate);
            displayData['Created Date'] = date.toLocaleString();
          } catch (err) {
            // If date fetch fails, skip it
          }
        }
        
        if (Object.keys(displayData).length === 0) {
          container.innerHTML = "<b>No AI generation parameters found.</b>";
        } else {
          let rows = "";
          // Display in a specific order
          const displayOrder = [
            'Prompt', 'Negative Prompt', 'Model', 'Sampler', 'Schedule Type', 
            'Size', 'Steps', 'CFG Scale', 'Distilled CFG Scale', 'Seed',
            'Hires Upscaler', 'Denoising Strength', 'Hires steps',
            'Hires CFG Scale', 'Clip Skip', 'Loras', 'Created Date'
          ];
          
          for (const key of displayOrder) {
            if (displayData[key] !== undefined) {
              const value = String(displayData[key]);
              const escapedValue = escapeHtml(value);
              // Store raw value in data attribute, properly escaped for HTML attribute
              const dataValue = value.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
              rows += `<tr><th>${escapeHtml(key)}</th><td><div class="meta-value-wrapper">${escapedValue}<button class="meta-copy-btn" data-value="${dataValue}">copy</button></div></td></tr>`;
            }
          }
          
          container.innerHTML = `<table class="meta-table">${rows}</table>`;
          
          // Add copy button handlers
          container.querySelectorAll('.meta-copy-btn').forEach(btn => {
            btn.addEventListener('click', function(e) {
              e.stopPropagation(); // Prevent closing the modal
              let value = this.getAttribute('data-value');
              // Decode HTML entities
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = value;
              value = tempDiv.textContent || tempDiv.innerText || value;
              copyTextRobust(value).then((ok) => {
                if (!ok) return;
                // Visual feedback
                const originalText = this.textContent;
                this.textContent = 'copied!';
                setTimeout(() => {
                  this.textContent = originalText;
                }, 1000);
              }).catch(() => {});
            });
          });
        }
      }
      modal.classList.add('active');
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML.replace(/\n/g, '<br>');
    }
    // Close modal on any click (including inside the table)
    document.getElementById('metaModal').onclick = function(e){
      this.classList.remove('active');
    };
    document.addEventListener('contextmenu', async function(e){
      const img = e.target.closest('img');
      if(!img) return;
      e.preventDefault();
      try {
        const metadata = await getPngMetadata(img.src);
        showMetaTable(metadata, img.src);
      } catch (err) {
        console.error('Failed to load metadata:', err);
        // Show error message in modal
        const modal = document.getElementById('metaModal');
        const container = document.getElementById('metaTableContent');
        container.innerHTML = "<b>Failed to load metadata. The image may not be accessible or may not contain metadata.</b>";
        modal.classList.add('active');
      }
    });
    
    // Click-and-hold scrolling for main gallery
    let galleryScrolling = false;
    let galleryScrollStartY = 0;
    let galleryScrollStartScroll = 0;
    let galleryHasScrolled = false;
    // Global flag to prevent clicks after drag-scroll
    window.galleryHasScrolled = false;
    
    function setupGalleryScrolling() {
      const gallery = document.getElementById('gallery');
      if (!gallery) {
        debugLog('Gallery not found for scrolling setup');
        return;
      }
      
      debugLog('Setting up gallery scrolling');
      
      gallery.addEventListener('mousedown', function(e) {
        // Only handle left clicks
        if (e.button !== 0) return;
        
        // Ignore clicks on buttons and links only
        if (e.target.closest('button') || e.target.closest('a')) {
          return;
        }
        
        debugLog('Gallery mousedown - starting scroll');
        
        // Start scrolling - works on images and empty space
        galleryScrolling = true;
        galleryHasScrolled = false;
        galleryScrollStartY = e.clientY;
        // Get current scroll position - try multiple methods
        galleryScrollStartScroll = window.pageYOffset || 
                                   window.scrollY || 
                                   document.documentElement.scrollTop || 
                                   document.body.scrollTop || 
                                   0;
        debugLog('Starting scroll position:', galleryScrollStartScroll);
        gallery.classList.add('scrolling');
        e.preventDefault();
        e.stopPropagation();
      });
      
      document.addEventListener('mousemove', function(e) {
        if (!galleryScrolling) return;
        
        e.preventDefault();
        e.stopPropagation();
        
        const deltaY = e.clientY - galleryScrollStartY;
        debugLog('Gallery mousemove, deltaY:', deltaY);
        
        // Only scroll if mouse moved more than 3 pixels (to avoid accidental scrolling)
        if (Math.abs(deltaY) > 3) {
          galleryHasScrolled = true;
          // Reversed: drag down = scroll up (decrease scrollTop), drag up = scroll down (increase scrollTop)
          // Note: deltaY is positive when dragging down, negative when dragging up
          // Multiply by 3 for 3x faster scrolling, and negate to reverse direction
          const newScroll = Math.max(0, galleryScrollStartScroll - (deltaY * 3));
          const maxScroll = Math.max(
            document.documentElement.scrollHeight - window.innerHeight,
            document.body.scrollHeight - window.innerHeight,
            0
          );
          const clampedScroll = Math.min(newScroll, maxScroll);
          
          debugLog('Scrolling to:', clampedScroll, 'from:', galleryScrollStartScroll, 'deltaY:', deltaY, 'maxScroll:', maxScroll);
          
          // Try multiple scroll methods for compatibility
          window.scrollTo(0, clampedScroll);
          if (document.documentElement.scrollTop !== undefined) {
            document.documentElement.scrollTop = clampedScroll;
          }
          if (document.body.scrollTop !== undefined) {
            document.body.scrollTop = clampedScroll;
          }
        }
      });
      
      document.addEventListener('mouseup', function(e) {
        if (galleryScrolling) {
          // If we scrolled, prevent image click from firing
          if (galleryHasScrolled) {
            const imgContainer = e.target.closest('.img-container');
            if (imgContainer) {
              // Set a flag to prevent click for a short time
              window.galleryHasScrolled = true;
              setTimeout(() => {
                window.galleryHasScrolled = false;
              }, 100);
            }
          }
          galleryScrolling = false;
          galleryHasScrolled = false; // Reset for next drag
          gallery.classList.remove('scrolling');
        }
      });
      
      gallery.addEventListener('mouseleave', function(e) {
        if (galleryScrolling) {
          galleryScrolling = false;
          gallery.classList.remove('scrolling');
        }
      });
    }
    
    // Initialize gallery scrolling when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupGalleryScrolling);
    } else {
      setupGalleryScrolling();
    }
  </script>
</body>
</html>
