<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Diffusion Darkroom Gallery</title>
  <link rel="icon" type="image/png" href="darkroom.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  
  <!-- ============================================
       USER SETTINGS - Edit these values to customize the gallery
       ============================================ -->
  <script>
    // Model Filter Settings
    // Each model filter has a label (display name) and a containsText (case-insensitive search string)
    const MODEL_FILTERS = [
      { label: 'Flux', containsText: 'flux' },
      { label: 'Qwen', containsText: 'qwen' },
      { label: 'ZIT', containsText: 'z_image' },
      { label: 'Wan', containsText: 'wan' },
      { label: 'XL', containsText: 'xl' },
      { label: 'Pony', containsText: 'pony' }
    ];
    
    // Image Size Slider Settings
    const IMAGE_SIZE_SETTINGS = {
      min: 300,        // Minimum image width in pixels
      max: 1800,       // Maximum image width in pixels
      default: 400,    // Default image width in pixels
      step: 0.1        // Step size for slider (multiplier increment)
    };
    
    // Paging Settings
    const PAGING_SETTINGS = {
      options: [50, 100, 250, 500],  // Available page sizes
      default: 100                    // Default images per page
    };
  </script>
  
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      min-height: 100vh;
      font-family: 'Roboto', sans-serif;
      background: #000;
      box-sizing: border-box;
      overflow-x: hidden;
    }
    .gallery {
      width: 100%;
      min-height: 100vh;
      padding: 25px 10px 84px 10px;
      margin-top: 0;
      box-sizing: border-box;
      background: #000;
      position: relative;
      transition: padding-top 0.3s ease, margin-top 0.3s ease;
      text-align: center;
    }
    .gallery.top-bar-visible {
      margin-top: 45px;
      padding-top: 15px;
    }
    .gallery.scrolling {
      cursor: none !important;
    }
    .gallery-column {
      display: inline-block;
      vertical-align: top;
      width: 600px;
      margin-right: 10px;
    }
    .no-images-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: gray;
      font-size: 14pt;
      text-align: center;
    }
    .img-container {
      display: block;
      position: relative;
      margin-bottom: 9px;
      background: transparent;
      border-radius: 5px;
      cursor: pointer;
      break-inside: avoid-column;
    }
    .img-container.deleted {
      cursor: default;
      opacity: 0.4;
      pointer-events: none;
    }
    .img-container.deleted .image-wrapper {
      position: relative;
    }
    .img-container.deleted .image-wrapper::after {
      content: 'Deleted';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 8px 16px;
      border-radius: 4px;
      font-size: 12pt;
      font-weight: 500;
      z-index: 10;
      pointer-events: none;
      white-space: nowrap;
    }
    .img-container.deleted img {
      opacity: 0.3;
      filter: grayscale(100%);
    }
    .img-container.deleted .star-button,
    .img-container.deleted .delete-button,
    .img-container.deleted .image-buttons {
      display: none;
    }
    .image-wrapper {
      position: relative;
      display: block;
      max-width: 600px;
      width: 100%;
      /* Reserve space to prevent layout shift */
      min-height: 200px;
      background: rgba(30, 30, 30, 0.5);
    }
    .image-wrapper img {
      width: 100%;
      max-width: 600px;
      display: block;
      height: auto;
      border-radius: 4px;
      background: #fff;
      border: 1px solid #515151;
      box-shadow: 0 2px 8px rgba(0,0,0,0.18);
      object-fit: contain;
      position: relative;
      z-index: 1;
      opacity: 0;
      transition: opacity 0.3s ease;
      will-change: opacity;
    }
    .image-wrapper img.loaded {
      opacity: 1;
    }
    .image-placeholder {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, rgba(30,30,30,0.5) 0%, rgba(40,40,40,0.5) 50%, rgba(30,30,30,0.5) 100%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
      border-radius: 4px;
      z-index: 0;
    }
    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }
    .filename-label {
      position: absolute;
      left: 1px;
      right: 1px;
      bottom: 1px;
      font-size: 8pt;
      color: #fff;
      background: rgba(0, 0, 0, 0.4);
      padding: 4px 4px 2px 5px;
      border-radius: 0 0 5px 5px;
      pointer-events: none;
      font-family: 'Roboto', sans-serif;
      text-overflow: ellipsis;
      white-space: nowrap;
      overflow: hidden;
      z-index: 1;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .img-container:hover .filename-label {
      opacity: 1;
    }
    .image-buttons {
      position: absolute;
      top: 12px;
      left: 7px;
      display: flex;
      gap: 4px;
      z-index: 3;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .img-container:hover .image-buttons {
      opacity: 1;
    }
    .image-button {
      position: relative;
      width: 22px;
      height: 22px;
      background: rgba(0, 0, 0, 0.2);
      border: none;
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.9;
      transition: opacity 0.2s, background 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      border:1px solid #4f4f4f;
      padding: 0;
    }
    .image-button:hover {
      opacity: 1;
      background: rgba(0, 0, 0, 0.85);
    }
    .image-button.copied {
      background: rgba(60, 138, 255, 0.8);
      opacity: 1;
    }
    .image-button svg {
      width: 14px;
      height: 14px;
      fill: #fff;
    }
    .image-button::after {
      content: attr(data-label);
      position: absolute;
      bottom: calc(100% + 5px);
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      font-size: 11px;
      white-space: nowrap;
      border-radius: 4px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      font-family: 'Roboto', sans-serif;
      z-index: 10;
    }
    .image-button:hover::after {
      opacity: 1;
    }
    .star-button {
      position: absolute;
      top: 12px;
      right: 7px;
      width: 22px;
      height: 22px;
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid #4f4f4f;
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s ease, background 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      z-index: 3;
      padding: 0;
    }
    /* Always show star if favorited, only show on hover if not favorited */
    .star-button.favorited {
      opacity: 0.9;
    }
    .img-container:hover .star-button {
      opacity: 0.9;
    }
    .star-button:hover {
      opacity: 1;
      background: rgba(0, 0, 0, 0.85);
    }
    .star-button.favorited {
      background: rgba(255, 193, 7, 0.3);
      border-color: rgba(255, 193, 7, 0.6);
    }
    .star-button.favorited svg {
      fill: #ffc107;
    }
    .star-button svg {
      width: 14px;
      height: 14px;
      fill: #fff;
      transition: fill 0.2s;
    }
    .delete-button {
      position: absolute;
      top: 38px;
      right: 7px;
      width: 22px;
      height: 22px;
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid #4f4f4f;
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s ease, background 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      z-index: 3;
      padding: 0;
    }
    .delete-button.favorited {
      opacity: 0.9;
    }
    .img-container:hover .delete-button {
      opacity: 0.9;
    }
    .delete-button:hover {
      opacity: 1;
      background: rgba(220, 53, 69, 0.85);
      border-color: rgba(220, 53, 69, 0.8);
    }
    .delete-button svg {
      width: 14px;
      height: 14px;
      fill: #fff;
      transition: fill 0.2s;
    }
    /* ---- Lightbox ---- */
    .lightbox-overlay {
      display: none;
      position: fixed;
      z-index: 99999;
      left: 0; top: 0;
      right: 0; bottom: 0;
      width: 100%; height: 100vh;
      background: rgba(0,0,0,0.97);
      justify-content: center;
      align-items: center;
      cursor: pointer;
    }
    .lightbox-overlay.active {
      display: flex;
    }
    .lightbox-overlay.hide-cursor {
      cursor: none !important;
    }
    .lightbox-image-container {
      position: relative;
      width: 100%;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
    }
    .lightbox-img {
      max-width: 100vw;
      max-height: 100vh;
      width: auto;
      height: auto;
      border-radius: 5px;
      background: #fff;
      border: 1px solid #fff;
      object-fit: contain;
      box-shadow: 0 2px 32px #000;
      z-index: 10;
      pointer-events: auto;
      transition: transform 0.2s ease-out;
    }
    .lightbox-img.zoomed {
      transition: none;
      transform-origin: center center;
    }
    .lightbox-img.panning {
      cursor: none;
    }
    .lightbox-filename {
      font-size: 9pt;
      color: #fff;
      background: rgba(0,0,0,.3);
      position: absolute;
      left: 18px;
      bottom: 18px;
      padding: 2px 8px;
      border-radius: 3px;
      max-width: 80%;
      white-space: nowrap;
      letter-spacing: 0.03em;
      pointer-events: none;
      box-shadow: 0 0 2px #111;
      opacity: 0.65;
      z-index: 20;
    }
    .lightbox-star-button {
      position: fixed;
      top: 18px;
      right: 18px;
      width: 32px;
      height: 32px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.7;
      transition: opacity 0.2s ease, background 0.2s;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      z-index: 100001;
      padding: 0;
      pointer-events: auto; /* Override parent's pointer-events: none */
    }
    .lightbox-star-button:hover {
      opacity: 1;
      background: rgba(0, 0, 0, 0.6);
    }
    .lightbox-star-button.favorited {
      background: rgba(255, 193, 7, 0.3);
      border-color: rgba(255, 193, 7, 0.6);
    }
    .lightbox-star-button.favorited svg {
      fill: #ffc107;
    }
    .lightbox-star-button svg {
      width: 18px;
      height: 18px;
      fill: #fff;
      transition: fill 0.2s;
      pointer-events: none; /* Prevent SVG from intercepting clicks */
    }
    /* ---- Lightbox Navigation Arrows ---- */
    .lightbox-nav-arrow {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(8px);
      border: 2px solid rgba(255, 255, 255, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100000;
      opacity: 0.6;
      transition: opacity 0.2s ease, background 0.2s ease, transform 0.2s ease;
      pointer-events: auto;
    }
    .lightbox-nav-arrow.visible {
      opacity: 0.6;
      pointer-events: auto;
    }
    .lightbox-nav-arrow.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .lightbox-nav-arrow:hover {
      background: rgba(255, 255, 255, 0.3);
      opacity: 1;
      transform: translateY(-50%) scale(1.1);
    }
    .lightbox-nav-arrow:active {
      transform: translateY(-50%) scale(0.95);
    }
    .lightbox-nav-arrow.left {
      left: 20px;
    }
    .lightbox-nav-arrow.right {
      right: 20px;
    }
    .lightbox-nav-arrow svg {
      width: 32px;
      height: 32px;
      fill: rgba(255, 255, 255, 0.9);
    }
    /* ---- Metadata Modal ---- */
    .meta-modal {
      display: none;
      position: fixed;
      left: 0; top: 0;
      right: 0; bottom: 0;
      width: 100%; height: 100vh;
      z-index: 999999;
      background: rgba(0,0,0,0.85);
      justify-content: center;
      align-items: center;
      cursor: pointer;
    }
    .meta-modal.active {
      display: flex;
    }
    .meta-table-container {
      background: #222;
      border-radius: 6px;
      box-shadow: 0 4px 32px #000;
      padding: 24px 32px;
      color: #fff;
      max-width: 70vw;
      max-height: 80vh;
      overflow: auto;
      position: relative;
      cursor: pointer;
      font-size: 13px;
      border: none;
    }
    .meta-table-container::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    .meta-table-container::-webkit-scrollbar-track {
      background: #111;
      border-radius: 4px;
    }
    .meta-table-container::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 4px;
    }
    .meta-table-container::-webkit-scrollbar-thumb:hover {
      background: #666;
    }
    table.meta-table {
      border-collapse: collapse;
      width: 100%;
      font-size: 13px;
      border: none;
    }
    table.meta-table td, table.meta-table th {
      border: none;
      padding: 6px 12px;
      vertical-align: top;
    }
    table.meta-table th {
      width: 20%;
      background: #222;
      color: #fff;
      text-align: left;
      white-space: nowrap;
      font-weight: normal;
      border-right: 1px solid #666;
    }
    table.meta-table tr {
      border-bottom: 1px solid #444;
    }
    table.meta-table td {
      width: 80%;
      word-break: break-word;
      overflow: hidden;
      position: relative;
      color: #7FD4CC; /* Light teal */
    }
    .meta-value-wrapper {
      position: relative;
      padding-right: 50px;
      min-height: 20px;
    }
    .meta-copy-btn {
      position: absolute;
      top: 50%;
      right: 0;
      transform: translateY(-50%);
      font-size: 8pt;
      color: rgba(255, 255, 255, 0.6);
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      padding: 1px 4px;
      cursor: pointer;
      font-family: 'Roboto', sans-serif;
      transition: all 0.2s;
      line-height: 1.2;
      text-transform: lowercase;
    }
    .meta-copy-btn:hover {
      color: rgba(255, 255, 255, 0.9);
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
    }
    /* ---- Search Bar ---- */
    .top-nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 48px;
      background: rgba(20, 20, 20, 0.95);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      padding: 0 20px;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      transform: translateY(-100%);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
      pointer-events: none;
      will-change: transform, opacity;
    }
    .top-nav.visible {
      transform: translateY(0);
      opacity: 1;
      pointer-events: auto;
    }
    .image-count {
      color: rgba(255, 255, 255, 0.7);
      font-size: 11px;
      font-family: 'Roboto', sans-serif;
      pointer-events: none;
      white-space: nowrap;
    }
    .image-count .count-number {
      font-weight: bold;
    }
    .search-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      width: 140px;
      max-width: 140px;
      flex-shrink: 0;
    }
    .search-input {
      width: 100%;
      height: 32px;
      padding: 0 30px 0 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      color: #fff;
      font-size: 12px;
      font-family: 'Roboto', sans-serif;
      outline: none;
      transition: all 0.2s;
      box-sizing: border-box;
    }
    .search-input:focus {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.4);
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
    }
    .search-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }
    .search-clear {
      position: absolute;
      right: 6px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: rgba(255, 255, 255, 0.7);
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      line-height: 1;
      padding: 0;
      transition: all 0.2s;
      z-index: 10;
      flex-shrink: 0;
    }
    .search-clear:hover {
      background: rgba(255, 255, 255, 0.3);
      color: rgba(255, 255, 255, 0.9);
    }
    .search-clear.visible {
      display: flex;
    }
    /* ---- Centered Search and Sort Container ---- */
    .search-sort-container {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 2;
    }
    /* ---- Sort Buttons ---- */
    .sort-buttons {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }
    /* ---- Right Buttons (Favorites & Reload) ---- */
    .right-buttons {
      position: absolute;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
      z-index: 2;
    }
    /* ---- Model Filter Buttons ---- */
    .model-filters {
      position: absolute;
      left: 20px;
      display: flex;
      align-items: center;
      gap: 5px;
      z-index: 2;
    }
    .model-filter-btn {
      padding: 3px 7px;
      border-radius: 4px;
      background: #2a2a2a;
      border: none;
      color: gray;
      cursor: pointer;
      font-family: 'Roboto', sans-serif;
      font-size: 11px;
      transition: all 0.2s;
    }
    .model-filter-btn:hover {
      background: #3a3a3a;
      color: #aaa;
    }
    .model-filter-btn.active {
      background: #404040;
      color: #fff;
    }
    .model-filter-btn:disabled {
      opacity: 0.6;
      cursor: wait;
    }
    .model-filter-btn.indexing {
      position: relative;
      overflow: hidden;
    }
    .model-filter-btn.indexing::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      height: 2px;
      background: #6a6;
      animation: indexing-progress 2s ease-in-out infinite;
    }
    @keyframes indexing-progress {
      0% { width: 0%; left: 0; }
      50% { width: 100%; left: 0; }
      100% { width: 0%; left: 100%; }
    }
    .model-filters-status {
      font-size: 10px;
      color: #666;
      margin-left: 6px;
      white-space: nowrap;
      display: flex;
      align-items: center;
    }
    .sort-btn {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.6);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      transition: all 0.2s;
      font-size: 10px;
    }
    .sort-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
      color: rgba(255, 255, 255, 0.9);
    }
    .sort-btn.active {
      background: rgba(255, 255, 255, 0.25);
      border-color: rgba(255, 255, 255, 0.5);
      color: rgba(255, 255, 255, 1);
    }
    .sort-btn.favorites-active {
      background: rgba(255, 193, 7, 0.3);
      border-color: rgba(255, 193, 7, 0.6);
    }
    .sort-btn.favorites-active svg {
      fill: #ffc107;
    }
    .sort-btn svg {
      width: 14px;
      height: 14px;
      fill: currentColor;
    }
    /* ---- Reload Button ---- */
    .reload-btn {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      background: rgba(60, 60, 60, 0.8);
      border: 1px solid rgba(80, 80, 80, 0.6);
      color: rgba(255, 255, 255, 0.6);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      transition: all 0.2s;
      flex-shrink: 0;
    }
    .reload-btn:hover {
      background: rgba(80, 80, 80, 0.9);
      border-color: rgba(100, 100, 100, 0.8);
      color: rgba(255, 255, 255, 0.9);
    }
    .reload-btn:active {
      transform: scale(0.95);
    }
    .reload-btn svg {
      width: 14px;
      height: 14px;
      fill: currentColor;
    }
    .reload-btn.loading svg {
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    /* ---- Size Control Slider ---- */
    .size-control {
      position: absolute;
      left: 30%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
      width: 126px;
      max-width: 126px;
      z-index: 2;
    }
    .size-slider-container {
      position: relative;
      flex: 1;
      display: flex;
      align-items: center;
    }
    .size-slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.15);
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
      transition: background 0.2s;
      border: none;
    }
    .size-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: rgba(100, 180, 255, 0.6);
      border: 2px solid rgba(100, 180, 255, 0.4);
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 8px rgba(100, 180, 255, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }
    .size-slider::-webkit-slider-thumb:hover {
      background: rgba(100, 180, 255, 0.75);
      border-color: rgba(100, 180, 255, 0.5);
      transform: scale(1.15);
      box-shadow: 0 3px 12px rgba(100, 180, 255, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }
    .size-slider::-webkit-slider-thumb:active {
      background: rgba(100, 180, 255, 0.85);
      transform: scale(1.1);
    }
    .size-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: rgba(100, 180, 255, 0.6);
      border: 2px solid rgba(100, 180, 255, 0.4);
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 8px rgba(100, 180, 255, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }
    .size-slider::-moz-range-thumb:hover {
      background: rgba(100, 180, 255, 0.75);
      border-color: rgba(100, 180, 255, 0.5);
      transform: scale(1.15);
      box-shadow: 0 3px 12px rgba(100, 180, 255, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }
    .size-slider::-moz-range-thumb:active {
      background: rgba(100, 180, 255, 0.85);
      transform: scale(1.1);
    }
    /* ---- Loading Bar ---- */
    .loading-bar-container {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      font-family: 'Roboto', sans-serif;
      color: rgba(255, 255, 255, 0.7);
    }
    .loading-bar-wrapper {
      width: 120px;
      height: 12px;
      border: 1px solid #4a4a4a;
      border-radius: 4px;
      background: transparent;
      overflow: hidden;
      position: relative;
    }
    .loading-bar-fill {
      height: 100%;
      background: #9EC5DB;
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }
    .loading-percentage {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.7);
      white-space: nowrap;
    }
    .loading-bar-container.hidden {
      display: none;
    }
    /* ---- Bottom Navigation ---- */
    .bottom-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 40px;
      background: rgba(20, 20, 20, 0.95);
      backdrop-filter: blur(8px);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 0 12px;
      z-index: 1000;
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.3);
      transform: translateY(100%);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
      pointer-events: none;
    }
    .bottom-nav.visible {
      transform: translateY(0);
      opacity: 1;
      pointer-events: auto;
    }
    .bottom-nav.hidden {
      display: none;
    }
    .bottom-nav-left {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-shrink: 0;
    }
    .bottom-nav-center {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
      justify-content: center;
      min-width: 0;
    }
    .bottom-nav-right {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }
    .pagination-arrow {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.7);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      padding: 0;
      flex-shrink: 0;
    }
    .pagination-arrow:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
      color: rgba(255, 255, 255, 0.9);
    }
    .pagination-arrow:active {
      transform: scale(0.95);
    }
    .pagination-arrow svg {
      width: 18px;
      height: 18px;
      fill: currentColor;
    }
    .pagination-numbers {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 100%;
      overflow-x: auto;
    }
    .pagination-numbers::-webkit-scrollbar {
      display: none;
    }
    .pagination-numbers {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    .pagination-number {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: rgba(40, 40, 40, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.6);
      font-size: 11px;
      font-family: 'Roboto', sans-serif;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }
    .pagination-number:hover {
      background: rgba(60, 60, 60, 0.8);
      border-color: rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.8);
    }
    .pagination-number.active {
      background: rgba(80, 80, 80, 0.9);
      border-color: rgba(255, 255, 255, 0.3);
      color: rgba(255, 255, 255, 0.9);
      font-weight: 500;
    }
    .pagination-page-size {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .pagination-page-size-item {
      font-size: 11px;
      font-family: 'Roboto', sans-serif;
      color: rgba(255, 255, 255, 0.6);
      cursor: pointer;
      padding: 2px 6px;
      border-radius: 3px;
      transition: all 0.2s;
      user-select: none;
    }
    .pagination-page-size-item:hover {
      color: rgba(255, 255, 255, 0.8);
      background: rgba(255, 255, 255, 0.1);
    }
    .pagination-page-size-item.active {
      color: rgba(255, 255, 255, 0.9);
      background: rgba(255, 255, 255, 0.15);
      font-weight: 500;
    }
    .pagination-page-size-separator {
      color: rgba(255, 255, 255, 0.3);
      font-size: 11px;
      margin: 0 2px;
    }
    .bottom-nav-page-size-standalone {
      position: fixed;
      bottom: 0;
      right: 0;
      height: 40px;
      background: rgba(20, 20, 20, 0.95);
      backdrop-filter: blur(8px);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding: 0 12px;
      z-index: 1000;
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.3);
      transform: translateY(100%);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
      pointer-events: none;
    }
    .bottom-nav-page-size-standalone.visible {
      transform: translateY(0);
      opacity: 1;
      pointer-events: auto;
    }
    .bottom-nav-page-size-standalone.hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="top-nav">
    <div class="model-filters" id="modelFilters">
      <!-- Model filter buttons will be generated from MODEL_FILTERS settings -->
      <span class="model-filters-status"></span>
    </div>
    <div class="size-control">
      <div class="size-slider-container">
        <input type="range" class="size-slider" id="sizeSlider" 
               min="1.0" 
               max="6.0" 
               step="0.1" 
               value="1.0" 
               title="Image Size">
      </div>
    </div>
    <div class="search-sort-container">
      <div class="search-wrapper">
        <input type="text" class="search-input" id="searchInput" />
        <button class="search-clear" id="searchClear" aria-label="Clear search">×</button>
      </div>
      <div class="sort-buttons">
        <button class="sort-btn" id="sortFilename" title="Sort by filename">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M7 10l5 5 5-5z"/>
          </svg>
        </button>
        <button class="sort-btn" id="sortDate" title="Sort by date">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M19 4h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V10h14v10zm0-12H5V6h14v2z"/>
          </svg>
        </button>
      </div>
    </div>
    <div class="right-buttons">
      <button class="sort-btn" id="favoritesFilter" title="Show favorites only">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/>
        </svg>
      </button>
      <button class="reload-btn" id="reloadBtn" title="Rescan folders and reload images">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
        </svg>
      </button>
    </div>
  </div>
  <div class="gallery" id="gallery"></div>
  <div class="bottom-nav hidden" id="bottomNav">
    <div class="bottom-nav-left">
      <div class="loading-bar-container" id="loadingBarContainer">
        <div class="loading-bar-wrapper">
          <div class="loading-bar-fill" id="loadingBarFill"></div>
        </div>
        <div class="loading-percentage" id="loadingPercentage">0%</div>
      </div>
      <div class="image-count" id="imageCount" style="display: none;">Total Images: <span class="count-number">0</span></div>
    </div>
    <div class="bottom-nav-center">
      <button class="pagination-arrow" id="paginationPrev" aria-label="Previous page">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
        </svg>
      </button>
      <div class="pagination-numbers" id="paginationNumbers"></div>
      <button class="pagination-arrow" id="paginationNext" aria-label="Next page">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
        </svg>
      </button>
    </div>
    <div class="bottom-nav-right">
      <div class="pagination-page-size" id="paginationPageSize">
        <span class="pagination-page-size-item" data-size="50">50</span>
        <span class="pagination-page-size-separator">·</span>
        <span class="pagination-page-size-item active" data-size="100">100</span>
        <span class="pagination-page-size-separator">·</span>
        <span class="pagination-page-size-item" data-size="250">250</span>
        <span class="pagination-page-size-separator">·</span>
        <span class="pagination-page-size-item" data-size="500">500</span>
      </div>
    </div>
  </div>
  <div class="bottom-nav-page-size-standalone hidden" id="bottomNavPageSizeStandalone">
    <div class="pagination-page-size">
      <span class="pagination-page-size-item" data-size="50">50</span>
      <span class="pagination-page-size-separator">·</span>
      <span class="pagination-page-size-item active" data-size="100">100</span>
      <span class="pagination-page-size-separator">·</span>
      <span class="pagination-page-size-item" data-size="250">250</span>
      <span class="pagination-page-size-separator">·</span>
      <span class="pagination-page-size-item" data-size="500">500</span>
    </div>
  </div>
  <div class="lightbox-overlay" id="lightbox">
    <div class="lightbox-image-container" id="lightboxContainer">
      <img class="lightbox-img" id="lightboxImg" src="" alt="" />
      <span class="lightbox-filename" id="lightboxFilename"></span>
      <button class="lightbox-star-button" id="lightboxStarButton" title="Add to favorites">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/>
        </svg>
      </button>
    </div>
    <button class="lightbox-nav-arrow left" id="lightboxPrev" aria-label="Previous image">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
      </svg>
    </button>
    <button class="lightbox-nav-arrow right" id="lightboxNext" aria-label="Next image">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
      </svg>
    </button>
  </div>
  <div class="meta-modal" id="metaModal">
    <div class="meta-table-container" id="metaTableContainer">
      <div id="metaTableContent"></div>
    </div>
  </div>
  <script>
    // Production debug flag - set to false to disable debug logging
    const DEBUG_MODE = false;
    
    // Debug logging helper
    function debugLog(...args) {
      if (DEBUG_MODE) {
        console.log(...args);
      }
    }
    
    // Calculate scrollbar width and adjust top nav
    function getScrollbarWidth() {
      const outer = document.createElement('div');
      outer.style.visibility = 'hidden';
      outer.style.overflow = 'scroll';
      outer.style.msOverflowStyle = 'scrollbar';
      outer.style.width = '100px';
      document.body.appendChild(outer);
      const inner = document.createElement('div');
      inner.style.width = '100%';
      outer.appendChild(inner);
      const scrollbarWidth = outer.offsetWidth - inner.offsetWidth;
      outer.parentNode.removeChild(outer);
      return scrollbarWidth;
    }
    
    // Apply scrollbar width to top nav and bottom nav bars
    window.addEventListener('DOMContentLoaded', function() {
      const scrollbarWidth = getScrollbarWidth();
      const topNav = document.querySelector('.top-nav');
      const bottomNav = document.querySelector('.bottom-nav');
      const pageSizeStandalone = document.getElementById('bottomNavPageSizeStandalone');
      if (topNav && scrollbarWidth > 0) {
        // Add 2px buffer to prevent bleeding into scrollbar
        topNav.style.right = `${scrollbarWidth + 2}px`;
      }
      if (bottomNav && scrollbarWidth > 0) {
        // Add 2px buffer to prevent bleeding into scrollbar
        bottomNav.style.right = `${scrollbarWidth + 2}px`;
      }
      if (pageSizeStandalone && scrollbarWidth > 0) {
        // Add 2px buffer to prevent bleeding into scrollbar
        pageSizeStandalone.style.right = `${scrollbarWidth + 2}px`;
      }
    });
    
    function escapeFilename(filename) {
      // For file:// protocol, we need to preserve path separators
      // Only encode the filename parts, not the path structure
      const trimmed = filename.trim();
      // Split by path separators, encode each part, then rejoin
      const parts = trimmed.split(/[/\\]/);
      return parts.map(part => encodeURIComponent(part)).join('/');
    }
    function removeExtension(filename) {
      return filename.replace(/\.[^/.]+$/, '');
    }
    function getFilenameOnly(path) {
      // Extract just the filename from a path (handles both / and \)
      return path.split(/[/\\]/).pop();
    }
    async function showLightbox(src, filename, index = -1) {
      // Store scroll position before opening lightbox
      scrollPositionBeforeLightbox = window.scrollY || window.pageYOffset || document.documentElement.scrollTop;
      
      const lightbox = document.getElementById('lightbox');
      const img = document.getElementById('lightboxImg');
      const label = document.getElementById('lightboxFilename');
      
      // Update current index (use filteredImageFiles for navigation)
      if (index >= 0) {
        // Find the index in filteredImageFiles
        currentLightboxIndex = filteredImageFiles.findIndex(f => f === filename);
        if (currentLightboxIndex === -1) {
          // Fallback to allImageFiles if not found in filtered
          currentLightboxIndex = allImageFiles.findIndex(f => f === filename);
        }
      } else {
        // Find index from filename if not provided
        currentLightboxIndex = filteredImageFiles.findIndex(f => f === filename);
        if (currentLightboxIndex === -1) {
          // Fallback to allImageFiles if not found in filtered
          currentLightboxIndex = allImageFiles.findIndex(f => f === filename);
        }
      }
      
      img.src = src;
      const baseFilename = removeExtension(getFilenameOnly(filename));
      label.textContent = baseFilename; // Will be updated when metadata loads
      lightbox.classList.add('active');
      
      // Update navigation arrows visibility
      updateNavArrows();
      
      // Reset zoom and pan state
      zoomActive = false;
      isPanning = false;
      currentZoomScale = 1;
      img.classList.remove('zoomed', 'panning');
      img.style.transform = '';
      img.style.transformOrigin = 'center center';
      
      // Update label with metadata
      try {
        const metadata = await getPngMetadata(src);
        const displayData = formatMetadataForDisplay(metadata);
        
        const parts = [baseFilename];
        if (displayData['Model']) parts.push(displayData['Model']);
        if (displayData['Sampler']) parts.push(displayData['Sampler']);
        if (displayData['Schedule Type']) parts.push(displayData['Schedule Type']);
        
        // Add size/dimensions at the end
        if (displayData['Size']) {
          parts.push(displayData['Size']);
        } else if (img.naturalWidth && img.naturalHeight) {
          // Fallback to actual image dimensions if Size not in metadata
          parts.push(`${img.naturalWidth}x${img.naturalHeight}`);
        }
        
        label.textContent = parts.join(' · ');
      } catch (err) {
        // If metadata extraction fails, keep the base filename
        label.textContent = baseFilename;
        // Try to get dimensions from image
        if (img.naturalWidth && img.naturalHeight) {
          label.textContent = `${baseFilename} · ${img.naturalWidth}x${img.naturalHeight}`;
        }
      }
      
      img.onload = function() {
        resetImageSize();
      };
      
      // Update lightbox star button
      const lightboxStarButton = document.getElementById('lightboxStarButton');
      if (lightboxStarButton) {
        const isFavorited = filename.startsWith('Favorites/') || 
                           filename.startsWith('Favorites\\') ||
                           filename.includes('/Favorites/') || 
                           filename.includes('\\Favorites\\');
        if (isFavorited) {
          lightboxStarButton.classList.add('favorited');
          lightboxStarButton.setAttribute('title', 'Remove from favorites');
        } else {
          lightboxStarButton.classList.remove('favorited');
          lightboxStarButton.setAttribute('title', 'Add to favorites');
        }
        lightboxStarButton.dataset.filename = filename;
      }
    }
    
    function resetImageSize() {
      const img = document.getElementById('lightboxImg');
      if (!img || !img.src) return;
      
      // Calculate size to fill viewport (height or width, maintaining aspect ratio)
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const imgAspect = img.naturalWidth / img.naturalHeight;
      const viewportAspect = viewportWidth / viewportHeight;
      
      if (imgAspect > viewportAspect) {
        // Image is wider - fit to width
        img.style.width = viewportWidth + 'px';
        img.style.height = 'auto';
      } else {
        // Image is taller - fit to height
        img.style.width = 'auto';
        img.style.height = viewportHeight + 'px';
      }
    }
    function hideLightbox() {
      const img = document.getElementById('lightboxImg');
      zoomActive = false;
      isPanning = false;
      currentZoomScale = 1;
      img.classList.remove('zoomed', 'panning');
      img.style.transform = '';
      img.style.transformOrigin = 'center center';
      img.style.width = '';
      img.style.height = '';
      img.src = '';
      document.getElementById('lightbox').classList.remove('active');
      document.getElementById('lightbox').classList.remove('hide-cursor');
      currentLightboxIndex = -1;
      
      // Restore scroll position after closing lightbox
      if (scrollPositionBeforeLightbox > 0) {
        requestAnimationFrame(() => {
          window.scrollTo(0, scrollPositionBeforeLightbox);
          if (document.documentElement.scrollTop !== undefined) {
            document.documentElement.scrollTop = scrollPositionBeforeLightbox;
          }
          if (document.body.scrollTop !== undefined) {
            document.body.scrollTop = scrollPositionBeforeLightbox;
          }
          // Also restore after a brief delay to ensure it sticks
          setTimeout(() => {
            window.scrollTo(0, scrollPositionBeforeLightbox);
            if (document.documentElement.scrollTop !== undefined) {
              document.documentElement.scrollTop = scrollPositionBeforeLightbox;
            }
            if (document.body.scrollTop !== undefined) {
              document.body.scrollTop = scrollPositionBeforeLightbox;
            }
          }, 10);
        });
      }
      
      // Hide navigation arrows
      const prevBtn = document.getElementById('lightboxPrev');
      const nextBtn = document.getElementById('lightboxNext');
      prevBtn.classList.remove('visible');
      prevBtn.classList.add('hidden');
      nextBtn.classList.remove('visible');
      nextBtn.classList.add('hidden');
    }
    
    // Navigation functions
    function updateNavArrows() {
      // Show/hide arrows based on whether navigation is possible
      const prevBtn = document.getElementById('lightboxPrev');
      const nextBtn = document.getElementById('lightboxNext');
      
      // Show previous arrow if there's a previous image
      if (currentLightboxIndex > 0) {
        prevBtn.classList.add('visible');
        prevBtn.classList.remove('hidden');
      } else {
        prevBtn.classList.remove('visible');
        prevBtn.classList.add('hidden');
      }
      
      // Show next arrow if there's a next image (use filteredImageFiles)
      if (currentLightboxIndex >= 0 && currentLightboxIndex < filteredImageFiles.length - 1) {
        nextBtn.classList.add('visible');
        nextBtn.classList.remove('hidden');
      } else {
        nextBtn.classList.remove('visible');
        nextBtn.classList.add('hidden');
      }
    }
    
    function navigateLightbox(direction) {
      if (currentLightboxIndex < 0) {
        return;
      }
      
      if (isNavigating) {
        return;
      }
      
      isNavigating = true; // Set flag to prevent other handlers from closing lightbox
      
      let newIndex;
      if (direction === 'prev') {
        newIndex = currentLightboxIndex - 1;
        if (newIndex < 0) {
          isNavigating = false;
          return;
        }
      } else if (direction === 'next') {
        newIndex = currentLightboxIndex + 1;
        if (newIndex >= filteredImageFiles.length) {
          isNavigating = false;
          return;
        }
      } else {
        isNavigating = false;
        return;
      }
      
      const filename = filteredImageFiles[newIndex];
      showLightbox(escapeFilename(filename), filename, newIndex);
      
      // Update lightbox star button after navigation
      setTimeout(() => {
        const lightboxStarButton = document.getElementById('lightboxStarButton');
        if (lightboxStarButton && filename) {
          const isFavorited = filename.startsWith('Favorites/') || 
                             filename.startsWith('Favorites\\') ||
                             filename.includes('/Favorites/') || 
                             filename.includes('\\Favorites\\');
          if (isFavorited) {
            lightboxStarButton.classList.add('favorited');
            lightboxStarButton.setAttribute('title', 'Remove from favorites');
          } else {
            lightboxStarButton.classList.remove('favorited');
            lightboxStarButton.setAttribute('title', 'Add to favorites');
          }
          lightboxStarButton.dataset.filename = filename;
        }
      }, 100);
      
      // Reset flag after a short delay to allow navigation to complete
      setTimeout(() => {
        isNavigating = false;
      }, 150);
    }
    let allImageContainers = [];
    let allImageFiles = [];
    let galleryColumns = [];
    // Initialize from settings
    const baseColumnWidth = IMAGE_SIZE_SETTINGS.min;
    const maxColumnWidth = IMAGE_SIZE_SETTINGS.max;
    const defaultSizeMultiplier = IMAGE_SIZE_SETTINGS.default / IMAGE_SIZE_SETTINGS.min;
    let currentSizeMultiplier = defaultSizeMultiplier;
    let currentLightboxIndex = -1; // Track current image index in lightbox
    let isNavigating = false; // Flag to prevent closing during navigation
    let scrollPositionBeforeLightbox = 0; // Store scroll position before opening lightbox
    let sortState = {
      filename: null, // null, 'asc', 'desc'
      date: null
    };
    let showFavoritesOnly = false; // Track favorites filter state
    let activeModelFilter = null; // Track active model filter: 'flux', 'xl', 'pony', or null
    let favoriteOriginalPaths = new Map(); // Track original paths of favorited images: filename -> originalPath (in-memory cache)
    const HISTORY_STORAGE_KEY = 'favoritesHistory'; // localStorage key for history
    
    // Load favorites history from localStorage
    function loadFavoritesHistory() {
      try {
        const historyJson = localStorage.getItem(HISTORY_STORAGE_KEY);
        if (historyJson) {
          const history = JSON.parse(historyJson);
          // Populate the in-memory map from localStorage
          Object.entries(history).forEach(([favoritesPath, originalPath]) => {
            favoriteOriginalPaths.set(favoritesPath, originalPath);
          });
          debugLog('Loaded favorites history:', Object.keys(history).length, 'entries');
          return true;
        }
      } catch (error) {
        console.error('Error loading favorites history:', error);
      }
      return false;
    }
    
    // Save favorites history to localStorage
    function saveFavoritesHistory() {
      try {
        // Convert Map to plain object for JSON storage
        const history = {};
        favoriteOriginalPaths.forEach((originalPath, favoritesPath) => {
          history[favoritesPath] = originalPath;
        });
        localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));
        return true;
      } catch (error) {
        console.error('Error saving favorites history:', error);
        return false;
      }
    }
    
    // Add an entry to history
    function addToHistory(favoritesPath, originalPath) {
      favoriteOriginalPaths.set(favoritesPath, originalPath);
      saveFavoritesHistory();
    }
    
    // Remove an entry from history
    function removeFromHistory(favoritesPath) {
      favoriteOriginalPaths.delete(favoritesPath);
      saveFavoritesHistory();
    }
    
    // Get original path from history, or return null if not found
    function getOriginalPathFromHistory(favoritesPath) {
      return favoriteOriginalPaths.get(favoritesPath) || null;
    }
    let imageDates = new Map(); // Cache file dates
    let imageMetadataCache = new Map(); // Cache PNG metadata to avoid re-fetching
    let imageSearchIndex = new Map(); // Index for search: filename -> {model, prompt}
    let imageDimensionsCache = new Map(); // Cache image dimensions: filename -> {width, height}
    let preloadQueue = []; // Queue for preloading next page images
    let allMetadataFetched = false; // Track if we've fetched metadata for all images
    let metadataFetchInProgress = false; // Track if fetch is currently running
    
    // Function to log actions to the server
    function logToServer(action, details) {
      fetch('/log-action', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action, details, timestamp: new Date().toISOString() })
      }).catch(() => {}); // Ignore errors for logging
    }
    
    // Update model filter buttons to show indexing state
    function updateModelFilterButtonsState(isIndexing, progress = null) {
      const btns = document.querySelectorAll('.model-filter-btn');
      const statusEl = document.querySelector('.model-filters-status');
      
      if (isIndexing) {
        btns.forEach(btn => btn.classList.add('indexing'));
        if (statusEl && progress !== null) {
          statusEl.textContent = `Loading Metadata: ${progress}%`;
        }
      } else {
        btns.forEach(btn => btn.classList.remove('indexing'));
        if (statusEl) {
          statusEl.textContent = '';
        }
      }
    }
    
    // Function to fetch metadata for all images (for model filtering)
    async function fetchAllImageMetadata(isBackground = false) {
      if (allMetadataFetched) {
        debugLog('[Model Filter] Metadata already fetched, skipping');
        return;
      }
      
      if (metadataFetchInProgress) {
        debugLog('[Model Filter] Fetch already in progress, waiting...');
        // Wait for existing fetch to complete
        while (metadataFetchInProgress) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        return;
      }
      
      metadataFetchInProgress = true;
      
      try {
        const unindexedFiles = allImageFiles.filter(f => !imageSearchIndex.has(f));
        const total = unindexedFiles.length;
        debugLog(`[Model Filter] ${isBackground ? 'Background indexing' : 'Fetching'} metadata for ${total} images...`);
        logToServer('metadata_fetch_start', { count: total, background: isBackground });
        
        if (total === 0) {
          allMetadataFetched = true;
          metadataFetchInProgress = false;
          updateModelFilterButtonsState(false);
          debugLog('[Model Filter] All images already indexed');
          return;
        }
        
        // Show indexing state
        updateModelFilterButtonsState(true, 0);
        
        // Fetch metadata in batches to avoid overwhelming the browser
        const BATCH_SIZE = isBackground ? 10 : 20; // Smaller batches for background
        let processed = 0;
        let errors = 0;
        
        for (let i = 0; i < unindexedFiles.length; i += BATCH_SIZE) {
          const batch = unindexedFiles.slice(i, i + BATCH_SIZE);
          
          const results = await Promise.allSettled(batch.map(async (filename) => {
            if (imageSearchIndex.has(filename)) return { skipped: true };
            
            const url = escapeFilename(filename);
            const metadata = await getPngMetadata(url);
            const displayData = formatMetadataForDisplay(metadata);
            
            const model = (displayData['Model'] || '').toLowerCase();
            imageSearchIndex.set(filename, {
              model: model,
              prompt: (displayData['Prompt'] || '').toLowerCase()
            });
            
            return { filename, model };
          }));
          
          // Process results
          results.forEach((result, idx) => {
            if (result.status === 'fulfilled') {
              if (!result.value?.skipped) processed++;
            } else {
              errors++;
              const filename = batch[idx];
              // Store empty data for failed extractions
              if (!imageSearchIndex.has(filename)) {
                imageSearchIndex.set(filename, { model: '', prompt: '' });
              }
            }
          });
          
          // Update progress
          const progressPct = Math.round(((i + batch.length) / total) * 100);
          updateModelFilterButtonsState(true, progressPct);
          
          if ((i + BATCH_SIZE) % 100 === 0 || i + BATCH_SIZE >= total) {
            debugLog(`[Model Filter] Processed ${Math.min(i + BATCH_SIZE, total)}/${total} (${errors} errors)`);
          }
          
          // Yield to browser for background processing
          if (isBackground) {
            await new Promise(resolve => setTimeout(resolve, 10));
          }
        }
        
        allMetadataFetched = true;
        updateModelFilterButtonsState(false);
        debugLog(`[Model Filter] Complete: ${processed} indexed, ${errors} errors`);
        logToServer('metadata_fetch_complete', { indexed: processed, errors, background: isBackground });
        
      } catch (err) {
        console.error('[Model Filter] Fatal error during metadata fetch:', err);
        logToServer('metadata_fetch_error', { error: err.message });
        updateModelFilterButtonsState(false);
        // Still mark as fetched to avoid infinite retries
        allMetadataFetched = true;
      } finally {
        metadataFetchInProgress = false;
      }
    }
    
    let initialPageLoaded = false; // Track if first page has finished loading
    let backgroundIndexingScheduled = false; // Prevent multiple scheduling
    
    // Start background metadata indexing after images are loaded
    function startBackgroundMetadataIndexing() {
      if (backgroundIndexingScheduled) return;
      backgroundIndexingScheduled = true;
      
      // Will be called when initial page finishes loading
      debugLog('[Model Filter] Background indexing scheduled, waiting for images to load...');
    }
    
    // Actually start the background indexing (called when page images finish loading)
    function triggerBackgroundMetadataIndexing() {
      if (!backgroundIndexingScheduled) return;
      if (allMetadataFetched || metadataFetchInProgress) return;
      
      // Wait a bit after images load to let the browser settle
      setTimeout(() => {
        if (!allMetadataFetched && !metadataFetchInProgress) {
          debugLog('[Model Filter] Images loaded, starting background metadata indexing...');
          logToServer('metadata_background_start', { trigger: 'images_loaded' });
          fetchAllImageMetadata(true);
        }
      }, 500);
    }
    let intersectionObserver = null; // Observer for visible images
    let layoutCache = null; // Cache for layout calculations
    let resizeThrottle = null; // Throttle for resize events
    let searchDebounce = null; // Debounce for search input
    
    // Helper: Get image dimensions (cached or fetch)
    async function getImageDimensions(filename) {
      if (imageDimensionsCache.has(filename)) {
        return imageDimensionsCache.get(filename);
      }
      
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const dims = { width: img.naturalWidth, height: img.naturalHeight };
          imageDimensionsCache.set(filename, dims);
          resolve(dims);
        };
        img.onerror = () => {
          // Default dimensions if can't load
          const dims = { width: 600, height: 600 };
          imageDimensionsCache.set(filename, dims);
          resolve(dims);
        };
        img.src = escapeFilename(filename);
      });
    }
    
    // Helper: Calculate placeholder height from dimensions
    function calculatePlaceholderHeight(dims, maxWidth) {
      if (!dims || !dims.width || !dims.height) return 200;
      const aspectRatio = dims.height / dims.width;
      return Math.max(150, Math.min(800, maxWidth * aspectRatio));
    }
    
    // Helper: Setup Intersection Observer for priority loading
    function setupIntersectionObserver() {
      if (intersectionObserver) {
        intersectionObserver.disconnect();
      }
      
      intersectionObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            if (img.dataset.src && !img.src) {
              img.src = img.dataset.src;
              img.removeAttribute('data-src');
              intersectionObserver.unobserve(img);
              
              // Image will load - handlers are already set up in loadCurrentPage
              // The load event will trigger handleImageLoad which removes placeholder
            }
          }
        });
      }, {
        rootMargin: '200px' // Start loading 200px before visible
      });
    }
    
    // Helper: Preload next page images
    function preloadNextPage() {
      if (preloadQueue.length > 0) return; // Already preloading
      
      const totalPages = Math.max(1, Math.ceil(filteredImageFiles.length / imagesPerPage));
      if (currentPage >= totalPages) return;
      
      const nextPageStart = currentPage * imagesPerPage;
      const nextPageEnd = Math.min(nextPageStart + imagesPerPage, filteredImageFiles.length);
      const nextPageFiles = filteredImageFiles.slice(nextPageStart, nextPageEnd);
      
      // Preload first 20 images of next page
      nextPageFiles.slice(0, 20).forEach(filename => {
        const link = document.createElement('link');
        link.rel = 'preload';
        link.as = 'image';
        link.href = escapeFilename(filename);
        document.head.appendChild(link);
        preloadQueue.push(link);
      });
    }
    
    // Helper: Cleanup preload queue
    function cleanupPreloadQueue() {
      preloadQueue.forEach(link => {
        if (link.parentNode) {
          link.parentNode.removeChild(link);
        }
      });
      preloadQueue = [];
    }
    
    // Pagination state
    let currentPage = 1;
    let imagesPerPage = PAGING_SETTINGS.default;
    let filteredImageFiles = []; // Images after filtering
    
    // Favorite functionality
    function getFavoritesFolderPath(filename) {
      // Always put Favorites in the root of the gallery folder
      const pathParts = filename.split(/[/\\]/);
      const fileName = pathParts.pop();
      // Return just "Favorites/filename" (root level)
      return 'Favorites/' + fileName;
    }
    
    function getOriginalPathFromFavorites(favoritesPath) {
      // First check if we have it in history (localStorage)
      const historyPath = getOriginalPathFromHistory(favoritesPath);
      if (historyPath) {
        return historyPath;
      }
      
      // If no history exists, use 'Images' folder as fallback
      const pathParts = favoritesPath.split(/[/\\]/);
      const fileName = pathParts.pop();
      // Remove 'Favorites' from path
      const favoritesIndex = pathParts.indexOf('Favorites');
      if (favoritesIndex !== -1) {
        pathParts.splice(favoritesIndex, 1);
      }
      
      // Check if history exists in localStorage
      const hasHistory = localStorage.getItem(HISTORY_STORAGE_KEY) !== null;
      
      if (hasHistory) {
        // History exists but this entry is missing - try to reconstruct
        if (pathParts.length > 0) {
          return pathParts.join('/') + '/' + fileName;
        } else {
          return fileName;
        }
      } else {
        // No history exists - use 'Images' folder as default
        return 'Images/' + fileName;
      }
    }
    
    async function toggleFavorite(filename, starButton) {
      try {
        // Normalize the filename path (handle both / and \)
        filename = filename.replace(/\\/g, '/');
        
        const isCurrentlyFavorited = filename.startsWith('Favorites/') || 
                                     filename.includes('/Favorites/');
        let newPath, oldPath;
        
        if (isCurrentlyFavorited) {
          // Remove from favorites - move back to original location
          // The file is currently at: filename (e.g., "Favorites/image.jpg")
          oldPath = filename;
          
          // Get original path from history (localStorage) or construct it
          const historyPath = getOriginalPathFromHistory(filename);
          if (historyPath) {
            newPath = historyPath.replace(/\\/g, '/');
            debugLog('Unfavoriting: Using history path', oldPath, '->', newPath);
          } else {
            newPath = getOriginalPathFromFavorites(filename).replace(/\\/g, '/');
            debugLog('Unfavoriting: Using fallback path', oldPath, '->', newPath);
          }
          // Remove from history
          removeFromHistory(filename);
        } else {
          // Add to favorites
          // The file is currently at: filename (e.g., "2025-11-17/image.jpg")
          oldPath = filename;
          newPath = getFavoritesFolderPath(filename).replace(/\\/g, '/');
          debugLog('Favoriting: Moving', oldPath, '->', newPath);
          // Store original path in history (localStorage)
          addToHistory(newPath, oldPath);
        }
        
        debugLog('Moving file:', { oldPath, newPath });
        
        // Use fetch to move the file (this is a server-side operation)
        // Note: This requires server support for file operations
        const response = await fetch('/move-file', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            oldPath: oldPath,
            newPath: newPath
          })
        });
        
        if (response.ok) {
          // Update the star button state immediately
          if (isCurrentlyFavorited) {
            starButton.classList.remove('favorited');
            starButton.setAttribute('data-label', 'Add to favorites');
          } else {
            starButton.classList.add('favorited');
            starButton.setAttribute('data-label', 'Remove from favorites');
          }
          
          // Also update lightbox star button if it exists and shows the same file
          const lightboxStarButton = document.getElementById('lightboxStarButton');
          if (lightboxStarButton && lightboxStarButton.dataset.filename === oldPath) {
            if (isCurrentlyFavorited) {
              lightboxStarButton.classList.remove('favorited');
              lightboxStarButton.setAttribute('title', 'Add to favorites');
            } else {
              lightboxStarButton.classList.add('favorited');
              lightboxStarButton.setAttribute('title', 'Remove from favorites');
            }
            lightboxStarButton.dataset.filename = newPath;
          }
          
          // Update filename in arrays
          const oldIndex = allImageFiles.indexOf(oldPath);
          if (oldIndex !== -1) {
            allImageFiles[oldIndex] = newPath;
          }
          
          const filteredIndex = filteredImageFiles.indexOf(oldPath);
          if (filteredIndex !== -1) {
            filteredImageFiles[filteredIndex] = newPath;
          }
          
          // Update container dataset - DO NOT update image src to avoid reload/flash/scroll
          // The file is moved on the server, but the image content is identical
          // The browser already has the image loaded, so we don't need to change the src
          starButton.dataset.filename = newPath;
          const container = starButton.closest('.img-container');
          if (container) {
            container.dataset.filename = newPath;
            // DO NOT update img.src - this causes reload, white flash, and scroll issues
            // The image is already loaded and displayed correctly
            // Only update data attributes for future reference
          }
          
          // Update lightbox image if it's showing this file
          const lightboxImg = document.getElementById('lightboxImg');
          if (lightboxImg && lightboxImg.src && lightboxImg.src.includes(escapeFilename(oldPath))) {
            const newImageUrl = escapeFilename(newPath);
            lightboxImg.src = newImageUrl;
            // Update the lightbox filename display
            const lightboxFilename = document.getElementById('lightboxFilename');
            if (lightboxFilename) {
              const baseFilename = removeExtension(getFilenameOnly(newPath));
              lightboxFilename.textContent = baseFilename;
            }
          }
          
          // Don't reload - we've updated everything dynamically
        } else {
          // Get the error message from the server
          let errorMessage = 'Failed to update favorite.';
          try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorMessage;
          } catch (e) {
            const errorText = await response.text();
            errorMessage = errorText || errorMessage;
          }
          console.error('Failed to move file:', errorMessage);
          alert('Failed to update favorite: ' + errorMessage);
        }
      } catch (error) {
        console.error('Error toggling favorite:', error);
        alert('Error updating favorite: ' + error.message);
      }
    }
    
    // Delete image function
    async function deleteImage(filename, container) {
      // Show confirmation dialog
      const confirmed = confirm(`Are you sure you want to delete this image?\n\n${filename}\n\nThis action cannot be undone.`);
      if (!confirmed) {
        return;
      }
      
      try {
        // Normalize the filename path
        filename = filename.replace(/\\/g, '/');
        
        // Mark container as deleted immediately (visual feedback)
        container.classList.add('deleted');
        container.style.pointerEvents = 'none';
        
        // Call delete endpoint
        const response = await fetch('/delete-file', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            filePath: filename
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          
          // Remove from arrays so it doesn't show in filters/search
          const indexInAll = allImageFiles.indexOf(filename);
          if (indexInAll !== -1) {
            allImageFiles.splice(indexInAll, 1);
          }
          
          const indexInFiltered = filteredImageFiles.indexOf(filename);
          if (indexInFiltered !== -1) {
            filteredImageFiles.splice(indexInFiltered, 1);
          }
          
          // Keep container in allImageContainers to preserve layout position
          // Just mark it as deleted so it's visually distinct but doesn't affect layout
          container.dataset.deleted = 'true';
          
          // Remove from search index
          imageSearchIndex.delete(filename);
          imageDimensionsCache.delete(filename);
          
          // Remove click handler to prevent lightbox opening
          // Clone the container to remove all event listeners
          const newContainer = container.cloneNode(true);
          container.parentNode.replaceChild(newContainer, container);
          newContainer.classList.add('deleted');
          newContainer.style.pointerEvents = 'none';
          newContainer.dataset.deleted = 'true';
          
          // Update the container reference in allImageContainers
          const containerIndex = allImageContainers.indexOf(container);
          if (containerIndex !== -1) {
            allImageContainers[containerIndex] = newContainer;
          }
          
          // Update image count (layout stays the same, so no need to recalculate)
          updateImageCount();
          
          // If lightbox is showing this image, close it
          const lightbox = document.getElementById('lightbox');
          if (lightbox && lightbox.style.display !== 'none') {
            const lightboxImg = document.getElementById('lightboxImg');
            if (lightboxImg && lightboxImg.src && lightboxImg.src.includes(escapeFilename(filename))) {
              closeLightbox();
            }
          }
          
          logToServer('image_deleted', { filename });
        } else {
          // Revert visual state on error
          container.classList.remove('deleted');
          container.style.pointerEvents = '';
          
          let errorMessage = 'Failed to delete image.';
          try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorMessage;
          } catch (e) {
            const errorText = await response.text();
            errorMessage = errorText || errorMessage;
          }
          console.error('Failed to delete file:', errorMessage);
          alert('Failed to delete image: ' + errorMessage);
        }
      } catch (error) {
        // Revert visual state on error
        container.classList.remove('deleted');
        container.style.pointerEvents = '';
        
        console.error('Error deleting image:', error);
        alert('Error deleting image: ' + error.message);
      }
    }
    
    function isFavorited(filename) {
      return filename.startsWith('Favorites/') || 
             filename.startsWith('Favorites\\') ||
             filename.includes('/Favorites/') || 
             filename.includes('\\Favorites\\');
    }

    function layoutMasonry() {
      const gallery = document.getElementById('gallery');
      if (!gallery) return;
      
      // Validate containers exist
      if (!allImageContainers || allImageContainers.length === 0) {
        return;
      }
      
      const galleryWidth = gallery.offsetWidth;
      if (galleryWidth === 0) {
        // Gallery not visible yet, retry after a short delay
        setTimeout(layoutMasonry, 100);
        return;
      }
      
      const columnWidth = baseColumnWidth * currentSizeMultiplier;
      const columnGap = 10;
      const numColumns = Math.max(1, Math.floor((galleryWidth + columnGap) / (columnWidth + columnGap)));
      
      // Use cached layout if dimensions haven't changed
      // Include container count and actual container references to detect changes
      const layoutKey = `${galleryWidth}-${columnWidth}-${numColumns}-${allImageContainers.length}`;
      // Check if layout cache is still valid (same key AND same container array reference)
      if (layoutCache && layoutCache.key === layoutKey && layoutCache.containers === allImageContainers) {
        return; // Skip if layout is the same
      }
      // Update cache with new layout key and container reference
      layoutCache = { key: layoutKey, containers: allImageContainers };
      
      // Clear existing columns but preserve containers
      // Remove containers from columns first to avoid DOM issues
      // This is critical when sizes change - ensures clean slate
      allImageContainers.forEach(container => {
        if (container.parentNode) {
          container.parentNode.removeChild(container);
        }
      });
      
      // Completely clear gallery and reset column heights
      // First, explicitly reset any height styles on existing columns
      galleryColumns.forEach(col => {
        if (col.element && col.element.parentNode) {
          col.element.style.height = 'auto';
          col.element.style.minHeight = '0';
        }
      });
      
      gallery.innerHTML = '';
      galleryColumns = [];
      
      // Force a reflow to ensure DOM is cleared before rebuilding
      void gallery.offsetHeight;
      
      // Also reset gallery container height if it was set
      gallery.style.height = 'auto';
      gallery.style.minHeight = '0';
      
      // Create columns
      for (let i = 0; i < numColumns; i++) {
        const column = document.createElement('div');
        column.className = 'gallery-column';
        column.style.width = columnWidth + 'px';
        column.style.marginRight = (i < numColumns - 1) ? columnGap + 'px' : '0';
        // Explicitly reset height to ensure clean slate
        column.style.height = 'auto';
        column.style.minHeight = '0';
        gallery.appendChild(column);
        galleryColumns.push({
          element: column,
          height: 0
        });
      }
      
      // Distribute all containers into columns (all containers are visible for current page)
      // Optimized: batch DOM operations and minimize reflows
      const marginBottom = 9; // Match CSS margin-bottom
      
      for (let i = 0; i < allImageContainers.length; i++) {
        const container = allImageContainers[i];
        
        // Find the shortest column (optimized with early exit)
        let shortestIndex = 0;
        let shortestHeight = galleryColumns[0].height;
        for (let j = 1; j < galleryColumns.length; j++) {
          if (galleryColumns[j].height < shortestHeight) {
            shortestIndex = j;
            shortestHeight = galleryColumns[j].height;
          }
        }
        
        const shortestColumn = galleryColumns[shortestIndex];
        
        // Add container to shortest column
        shortestColumn.element.appendChild(container);
        
        // Force a single reflow to ensure layout is calculated
        const containerHeight = container.offsetHeight || container.getBoundingClientRect().height;
        const totalHeight = containerHeight + marginBottom;
        
        if (totalHeight > 0) {
          galleryColumns[shortestIndex].height += totalHeight;
        }
        
        // Ensure column element doesn't have a fixed height that would prevent shrinking
        shortestColumn.element.style.height = 'auto';
      }
    }

    function updateImageCount() {
      const imageCountEl = document.getElementById('imageCount');
      if (!imageCountEl) return;
      
      // Count total visible images (for pagination, this is filteredImageFiles length)
      const totalVisible = filteredImageFiles.length;
      
      const countNumber = imageCountEl.querySelector('.count-number');
      if (countNumber) {
        countNumber.textContent = totalVisible;
      } else {
        imageCountEl.innerHTML = `Total Images: <span class="count-number">${totalVisible}</span>`;
      }
    }
    
    function getTotalPages() {
      return Math.max(1, Math.ceil(filteredImageFiles.length / imagesPerPage));
    }
    
    function updatePaginationUI() {
      const bottomNav = document.getElementById('bottomNav');
      const paginationNumbers = document.getElementById('paginationNumbers');
      const paginationPrev = document.getElementById('paginationPrev');
      const paginationNext = document.getElementById('paginationNext');
      const pageSizeStandalone = document.getElementById('bottomNavPageSizeStandalone');
      if (!bottomNav || !paginationNumbers) return;
      
      const totalPages = getTotalPages();
      
      // Always show bottom nav (even with single page)
      bottomNav.classList.remove('hidden');
      // Don't add 'visible' class here - let mouse proximity handler manage it
      if (pageSizeStandalone) {
        pageSizeStandalone.classList.add('hidden');
      }
      
      // Show/hide pagination arrows and page numbers based on page count
      if (totalPages > 1) {
        // Show arrows and page numbers when there are multiple pages
        if (paginationPrev) {
          paginationPrev.style.display = 'flex';
        }
        if (paginationNext) {
          paginationNext.style.display = 'flex';
        }
        paginationNumbers.style.display = 'flex';
        
        // Clear existing page numbers
        paginationNumbers.innerHTML = '';
        
        // Create page number buttons
        for (let i = 1; i <= totalPages; i++) {
          const pageBtn = document.createElement('button');
          pageBtn.className = 'pagination-number';
          if (i === currentPage) {
            pageBtn.classList.add('active');
          }
          pageBtn.textContent = i;
          pageBtn.addEventListener('click', () => goToPage(i));
          paginationNumbers.appendChild(pageBtn);
        }
      } else {
        // Hide arrows and page numbers when there's only one page
        if (paginationPrev) {
          paginationPrev.style.display = 'none';
        }
        if (paginationNext) {
          paginationNext.style.display = 'none';
        }
        paginationNumbers.style.display = 'none';
        paginationNumbers.innerHTML = '';
      }
    }
    
    function goToPage(page) {
      const totalPages = getTotalPages();
      if (page < 1 || page > totalPages) return;
      
      debugLog(`[Page] Going to page ${page}/${totalPages}`);
      logToServer('page_change', { page, totalPages, imagesPerPage });
      
      // Invalidate layout cache when changing pages
      layoutCache = null;
      
      // Scroll to top immediately before any content changes
      window.scrollTo(0, 0);
      document.documentElement.scrollTop = 0;
      document.body.scrollTop = 0;
      
      currentPage = page;
      updatePaginationUI();
      loadCurrentPage();
      
      // Scroll again after a brief delay to ensure it sticks
      setTimeout(() => {
        window.scrollTo(0, 0);
        document.documentElement.scrollTop = 0;
        document.body.scrollTop = 0;
      }, 10);
    }
    
    function goToPreviousPage() {
      const totalPages = getTotalPages();
      if (currentPage === 1) {
        goToPage(totalPages); // Wrap to last page
      } else {
        goToPage(currentPage - 1);
      }
    }
    
    function goToNextPage() {
      const totalPages = getTotalPages();
      if (currentPage === totalPages) {
        goToPage(1); // Wrap to first page
      } else {
        goToPage(currentPage + 1);
      }
    }
    
    function loadCurrentPage(preserveScroll = false) {
      const gallery = document.getElementById('gallery');
      if (!gallery) return;
      
      // Calculate which images to show for current page
      const startIndex = (currentPage - 1) * imagesPerPage;
      const endIndex = Math.min(startIndex + imagesPerPage, filteredImageFiles.length);
      const pageFiles = filteredImageFiles.slice(startIndex, endIndex);
      
      // Show loading bar for page loading
      const loadingBarContainer = document.getElementById('loadingBarContainer');
      const loadingBarFill = document.getElementById('loadingBarFill');
      const loadingPercentage = document.getElementById('loadingPercentage');
      const imageCountEl = document.getElementById('imageCount');
      
      if (loadingBarContainer && pageFiles.length > 0) {
        loadingBarContainer.classList.remove('hidden');
        // Force bars to show during loading
        if (typeof window.updateBarsVisibility === 'function') {
          window.updateBarsVisibility();
        }
        if (imageCountEl) {
          imageCountEl.style.display = 'none';
        }
        // Initialize loading bar to 0%
        if (loadingBarFill) {
          loadingBarFill.style.width = '0%';
        }
        if (loadingPercentage) {
          loadingPercentage.textContent = '0%';
        }
      }
      
      // Track loading progress for this page
      let pageImagesLoaded = 0;
      let pageImagesErrored = 0;
      const totalPageImages = pageFiles.length;
      
      function updatePageLoadingProgress() {
        if (!loadingBarFill || !loadingPercentage) return;
        const total = pageImagesLoaded + pageImagesErrored;
        const percentage = totalPageImages > 0 ? Math.round((total / totalPageImages) * 100) : 0;
        
        loadingBarFill.style.width = percentage + '%';
        loadingPercentage.textContent = percentage + '%';
        
        // Hide loading bar and show image count when all images are loaded
        if (total >= totalPageImages && totalPageImages > 0) {
          setTimeout(() => {
            if (loadingBarContainer) {
              loadingBarContainer.classList.add('hidden');
            }
            // Update bars after loading completes
            if (typeof window.updateBarsVisibility === 'function') {
              window.updateBarsVisibility();
            }
            if (imageCountEl) {
              imageCountEl.style.display = '';
            }
            
            // Final layout recalculation after all images are loaded
            // Use a debounced call to avoid conflicts
            if (typeof window.finalLayoutTimeout === 'undefined') {
              window.finalLayoutTimeout = null;
            }
            clearTimeout(window.finalLayoutTimeout);
            // Invalidate cache before final layout to ensure fresh calculation
            layoutCache = null;
            window.finalLayoutTimeout = setTimeout(() => {
              layoutMasonry();
              
              // Start background metadata indexing after first page loads
              if (!initialPageLoaded) {
                initialPageLoaded = true;
                triggerBackgroundMetadataIndexing();
              }
            }, 200);
          }, 300);
        }
      }
      
      // Cleanup previous page
      cleanupPreloadQueue();
      if (intersectionObserver) {
        intersectionObserver.disconnect();
        intersectionObserver = null;
      }
      
      // Clear gallery and containers completely
      // Reset any pending layout timeouts to prevent conflicts
      if (typeof window.finalLayoutTimeout !== 'undefined' && window.finalLayoutTimeout) {
        clearTimeout(window.finalLayoutTimeout);
        window.finalLayoutTimeout = null;
      }
      
      // Preserve deleted containers before clearing
      const deletedContainers = Array.from(document.querySelectorAll('.img-container.deleted'));
      
      gallery.innerHTML = '';
      galleryColumns = [];
      allImageContainers = [];
      
      // Show "No Images Found" message if there are no images
      if (pageFiles.length === 0) {
        const noImagesMsg = document.createElement('div');
        noImagesMsg.className = 'no-images-message';
        noImagesMsg.textContent = 'No Images Found';
        gallery.appendChild(noImagesMsg);
        
        // Hide loading bar and show image count
        if (loadingBarContainer) {
          loadingBarContainer.classList.add('hidden');
        }
        if (imageCountEl) {
          imageCountEl.style.display = '';
        }
        return;
      }
      
      // No intersection observer needed - we load all images immediately
      
      const maxWidth = baseColumnWidth * currentSizeMultiplier;
      
      // Create containers immediately (don't wait for dimensions)
      // This allows visible images to show right away
      pageFiles.forEach((filename, pageIndex) => {
        // Create new container for this image
        const container = document.createElement('div');
        container.className = 'img-container';
        container.dataset.filename = filename; // Store filename for intersection observer

        const wrapper = document.createElement('div');
        wrapper.className = 'image-wrapper';
        wrapper.style.maxWidth = maxWidth + 'px';
        
        // Use default placeholder height initially (will be updated when dimensions load)
        wrapper.style.minHeight = '200px';
        
        // Add placeholder shimmer
        const placeholder = document.createElement('div');
        placeholder.className = 'image-placeholder';
        wrapper.appendChild(placeholder);
        
        // Fetch dimensions in background and update placeholder height
        getImageDimensions(filename).then(dims => {
          const placeholderHeight = calculatePlaceholderHeight(dims, maxWidth);
          wrapper.style.minHeight = placeholderHeight + 'px';
        }).catch(() => {
          // Keep default height on error
        });

        const img = document.createElement('img');
        img.style.maxWidth = maxWidth + 'px';
        img.decoding = 'async';
        // No lazy loading - we load all images immediately with priority
        
        const baseFilename = removeExtension(getFilenameOnly(filename));
        const label = document.createElement('span');
        label.className = 'filename-label';
        label.textContent = baseFilename;

        // Queue metadata extraction
        let imageLoadHandled = false; // Prevent double-counting
        let loadTimeoutId = null; // Store timeout ID for cleanup
        
        const handleImageLoad = () => {
          if (imageLoadHandled) return; // Prevent double-counting
          imageLoadHandled = true;
          
          // Clear any pending timeout
          if (loadTimeoutId) {
            clearTimeout(loadTimeoutId);
            loadTimeoutId = null;
          }
          
          pageImagesLoaded++;
          updatePageLoadingProgress();
          
          // Remove placeholder and show image
          if (placeholder.parentNode) {
            placeholder.parentNode.removeChild(placeholder);
          }
          img.classList.add('loaded');
          
          // Update wrapper height to actual image height
          if (img.naturalHeight && img.naturalWidth) {
            const aspectRatio = img.naturalHeight / img.naturalWidth;
            wrapper.style.minHeight = (maxWidth * aspectRatio) + 'px';
            
            // Debounced layout recalculation as images load
            // This ensures the masonry grid updates smoothly
            if (!window.imageLoadLayoutTimeout) {
              window.imageLoadLayoutTimeout = null;
            }
            clearTimeout(window.imageLoadLayoutTimeout);
            window.imageLoadLayoutTimeout = setTimeout(() => {
              layoutCache = null;
              layoutMasonry();
            }, 50);
          }
          
          metadataQueue.push({ img, label, baseFilename, copyPromptBtn, container, filename });
          processMetadataQueue();
        };
        
        const handleImageError = function() {
          if (imageLoadHandled) return; // Prevent double-counting
          imageLoadHandled = true;
          
          // Clear any pending timeout
          if (loadTimeoutId) {
            clearTimeout(loadTimeoutId);
            loadTimeoutId = null;
          }
          
          pageImagesErrored++;
          updatePageLoadingProgress();
          
          // Only show error if image actually failed (has src and is in error state)
          if (img.src && img.complete && img.naturalWidth === 0) {
            container.innerHTML =
              '<div style="padding:12px;color:#c00;">Failed to load: ' + filename + '</div>';
          }
        };

        // Create button container
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'image-buttons';

        // 1st button: Copy Prompt
        const copyPromptBtn = document.createElement('button');
        copyPromptBtn.className = 'image-button';
        copyPromptBtn.setAttribute('data-label', 'Copy Prompt');
        copyPromptBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>';
        copyPromptBtn.style.display = 'none';
        copyPromptBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          const prompt = this.dataset.prompt;
          if (prompt) {
            navigator.clipboard.writeText(prompt).then(() => {
              this.classList.add('copied');
              setTimeout(() => {
                this.classList.remove('copied');
              }, 2000);
            }).catch(err => {
              console.error('Failed to copy:', err);
            });
          }
        });

        // 2nd button: Download
        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'image-button';
        downloadBtn.setAttribute('data-label', 'Download');
        downloadBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2v9.67z"/></svg>';
        downloadBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          const a = document.createElement('a');
          a.href = img.src;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        });

        // 3rd button: Open in new window
        const openButton = document.createElement('button');
        openButton.className = 'image-button';
        openButton.setAttribute('data-label', 'Open');
        openButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 19H6c-.55 0-1-.45-1-1V6c0-.55.45-1 1-1h5c.55 0 1-.45 1-1s-.45-1-1-1H6c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-5c0-.55-.45-1-1-1s-1 .45-1 1v5c0 .55-.45 1-1 1zM14 4c0 .55.45 1 1 1h2.59l-9.13 9.13c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0L19 6.41V9c0 .55.45 1 1 1s1-.45 1-1V4c0-.55-.45-1-1-1h-5c-.55 0-1 .45-1 1z"/></svg>';
        openButton.addEventListener('click', function(e) {
          e.stopPropagation();
          window.open(img.src, '_blank');
        });

        buttonContainer.appendChild(copyPromptBtn);
        buttonContainer.appendChild(downloadBtn);
        buttonContainer.appendChild(openButton);

        // Load ALL images immediately - no lazy loading
        // Priority: Load first 30 images first, then rest in batches
        const imageUrl = escapeFilename(filename);
        
        // Always set up load and error handlers first
        img.addEventListener('load', handleImageLoad, { once: true });
        img.addEventListener('error', handleImageError, { once: true });
        
        // Load images with priority: first 30 immediately, rest in small delays
        if (pageIndex < 30) {
          // Top images load immediately
          img.src = imageUrl;
        } else {
          // Load rest of images with small staggered delays to prioritize visible ones
          // This allows browser to prioritize the first 30 while still loading all
          setTimeout(() => {
            img.src = imageUrl;
          }, (pageIndex - 30) * 10); // 10ms delay between each image after first 30
        }
        
        // Check if image is already loaded (for cached images)
        setTimeout(() => {
          if (img.complete && img.naturalWidth > 0) {
            // Image already loaded (cached) - show immediately
            img.removeEventListener('load', handleImageLoad);
            img.removeEventListener('error', handleImageError);
            handleImageLoad();
          }
        }, 0);
        
        // Add a timeout fallback only for truly stuck images (60 seconds)
        loadTimeoutId = setTimeout(() => {
          if (!imageLoadHandled && img.src) {
            // Only mark as error if image is actually in error state
            if (img.complete && img.naturalWidth === 0) {
              if (DEBUG_MODE) console.warn('Image load timeout (60s):', filename);
              img.removeEventListener('load', handleImageLoad);
              img.removeEventListener('error', handleImageError);
              handleImageError();
            }
            // If still loading, don't mark as error - just clear timeout
            else if (!img.complete) {
              // Image still loading after 60s - clear timeout but don't mark as error
              // It will eventually load or error naturally
            }
          }
        }, 60000); // 60 seconds for very large images

        // Create star button (upper right corner)
        const starButton = document.createElement('button');
        starButton.className = 'star-button';
        starButton.setAttribute('data-label', 'Add to favorites');
        starButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>';
        starButton.dataset.filename = filename;
        
        // Check if image is in Favorites folder (check for Favorites at start or anywhere in path)
        const isFavorited = filename.startsWith('Favorites/') || 
                           filename.startsWith('Favorites\\') ||
                           filename.includes('/Favorites/') || 
                           filename.includes('\\Favorites\\');
        if (isFavorited) {
          starButton.classList.add('favorited');
          starButton.setAttribute('data-label', 'Remove from favorites');
        }
        
        starButton.addEventListener('click', function(e) {
          e.preventDefault(); // Prevent any default button behavior
          e.stopPropagation(); // Prevent event bubbling to parent elements
          e.stopImmediatePropagation(); // Prevent other handlers on the same element
          // Use the dataset filename which should reflect the current path
          // This is important if the file was moved in a previous session
          const currentFilename = this.dataset.filename || filename;
          toggleFavorite(currentFilename, starButton);
        });

        // Create delete button (underneath star button)
        const deleteButton = document.createElement('button');
        deleteButton.className = 'delete-button';
        deleteButton.setAttribute('data-label', 'Delete image');
        deleteButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>';
        deleteButton.dataset.filename = filename;
        
        deleteButton.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          const currentFilename = this.dataset.filename || filename;
          deleteImage(currentFilename, container);
        });

        wrapper.appendChild(img);
        wrapper.appendChild(label);
        wrapper.appendChild(buttonContainer);
        wrapper.appendChild(starButton);
        wrapper.appendChild(deleteButton);
        container.appendChild(wrapper);

        container.addEventListener('click', function(e) {
          const index = startIndex + pageIndex; // Index in filteredImageFiles
          showLightbox(img.src || img.dataset.src, filename, index);
          e.stopPropagation();
        });

        // Add to containers array immediately
        allImageContainers.push(container);
      });
      
      // Re-add deleted containers after new containers (they'll be positioned by masonry)
      // Note: deletedContainers was preserved before clearing gallery at the start of this function
      deletedContainers.forEach(deletedContainer => {
        allImageContainers.push(deletedContainer);
      });
      
      // Layout masonry immediately with containers (don't wait for dimensions)
      // This allows visible images to show right away
      // Invalidate cache to force fresh layout when new containers are created
      layoutCache = null;
      requestAnimationFrame(() => {
        layoutMasonry();
      });
    }

    function filterImages(searchQuery) {
      const searchInput = document.getElementById('searchInput');
      const currentQuery = searchQuery || (searchInput ? searchInput.value : '');
      
      // Reset to page 1 when filtering
      currentPage = 1;
      
      let filtered = [];
      
      // First apply favorites filter if enabled
      if (showFavoritesOnly) {
        filtered = allImageFiles.filter(filename => isFavorited(filename));
      } else {
        filtered = [...allImageFiles];
      }
      
      // Apply model filter if active
      if (activeModelFilter) {
        // Get the contains text from the active button
        const activeButton = document.querySelector(`.model-filter-btn[data-model="${activeModelFilter}"]`);
        const containsText = activeButton ? (activeButton.getAttribute('data-contains') || activeModelFilter).toLowerCase() : activeModelFilter.toLowerCase();
        
        filtered = filtered.filter(filename => {
          // Check global metadata index
          const metadata = imageSearchIndex.get(filename);
          if (metadata && metadata.model) {
            return metadata.model.toLowerCase().includes(containsText);
          }
          // Check container data for images not yet indexed
          const container = allImageContainers.find(c => c.dataset.filename === filename);
          if (container && container.dataset.modelName) {
            return container.dataset.modelName.toLowerCase().includes(containsText);
          }
          // If no metadata available yet, exclude from filtered results
          return false;
        });
      }
      
      if (currentQuery.length < 2) {
        // Show all images (or favorites if filter is on) if search is less than 2 characters
        filteredImageFiles = filtered;
      } else {
        const query = currentQuery.toLowerCase();
        const filteredSet = new Set(); // Use Set for O(1) lookups instead of array includes
        
        // Filter based on filenames (optimized with Set) - use filtered array
        filtered.forEach((filename) => {
          const filenameOnly = getFilenameOnly(filename).toLowerCase();
          if (filenameOnly.includes(query)) {
            filteredSet.add(filename);
          }
        });
        
        // Search through global metadata index (works for all images, not just current page)
        imageSearchIndex.forEach((metadata, filename) => {
          // Only include if it's in our filtered list
          if (filtered.includes(filename) && (metadata.model.includes(query) || metadata.prompt.includes(query))) {
            filteredSet.add(filename);
          }
        });
        
        // Also check currently loaded containers (for images that just loaded but not yet indexed)
        allImageContainers.forEach((container) => {
          const modelName = (container.dataset.modelName || '').toLowerCase();
          const prompt = (container.dataset.prompt || '').toLowerCase();
          
          // Check if query matches model name or prompt
          if (modelName.includes(query) || prompt.includes(query)) {
            // Use stored filename from dataset for faster lookup
            const filename = container.dataset.filename;
            if (filename && filtered.includes(filename)) {
              filteredSet.add(filename);
            } else {
              // Fallback: Extract filename from img src
              const img = container.querySelector('img');
              if (img && img.src) {
                const srcPath = decodeURIComponent(img.src);
                const foundFilename = filtered.find(f => srcPath.includes(f));
                if (foundFilename) {
                  filteredSet.add(foundFilename);
                }
              }
            }
          }
        });
        
        filteredImageFiles = Array.from(filteredSet);
      }
      
      // Invalidate layout cache and clear columns when filtering
      layoutCache = null;
      galleryColumns = [];
      
      // Clear any pending layout timeouts
      if (window.imageLoadLayoutTimeout) {
        clearTimeout(window.imageLoadLayoutTimeout);
        window.imageLoadLayoutTimeout = null;
      }
      if (window.finalLayoutTimeout) {
        clearTimeout(window.finalLayoutTimeout);
        window.finalLayoutTimeout = null;
      }
      
      // Update pagination UI
      updatePaginationUI();
      
      // Update image count
      updateImageCount();
      
      // Log filter results
      if (currentQuery.length >= 2 || activeModelFilter || showFavoritesOnly) {
        debugLog(`[Filter] Results: ${filteredImageFiles.length} images (search: "${currentQuery}", model: ${activeModelFilter || 'none'}, favorites: ${showFavoritesOnly})`);
        logToServer('filter_applied', { 
          resultCount: filteredImageFiles.length, 
          searchQuery: currentQuery.length >= 2 ? currentQuery : '',
          modelFilter: activeModelFilter,
          favoritesOnly: showFavoritesOnly
        });
      }
      
      // Load current page (will create containers for filtered images)
      loadCurrentPage();
    }

    // Metadata extraction queue with concurrency limit
    let metadataQueue = [];
    let activeMetadataExtractions = 0;
    const MAX_CONCURRENT_METADATA = 5; // Limit concurrent metadata fetches
    
    function processMetadataQueue() {
      if (metadataQueue.length === 0 || activeMetadataExtractions >= MAX_CONCURRENT_METADATA) {
        return;
      }
      
      const { img, label, baseFilename, copyPromptBtn, container, filename } = metadataQueue.shift();
      activeMetadataExtractions++;
      
      getPngMetadata(img.src)
        .then(metadata => {
          const displayData = formatMetadataForDisplay(metadata);
          const parts = [baseFilename];
          if (displayData['Model']) parts.push(displayData['Model']);
          if (displayData['Sampler']) parts.push(displayData['Sampler']);
          if (displayData['Schedule Type']) parts.push(displayData['Schedule Type']);
          
          // Add size/dimensions at the end
          if (displayData['Size']) {
            parts.push(displayData['Size']);
          } else if (img.naturalWidth && img.naturalHeight) {
            // Fallback to actual image dimensions if Size not in metadata
            parts.push(`${img.naturalWidth}x${img.naturalHeight}`);
          }
          
          label.textContent = parts.join(' · ');
          
          // Store model name in container for search
          if (container && displayData['Model']) {
            container.dataset.modelName = displayData['Model'];
          }
          
          // Store prompt in container for search
          if (container && displayData['Prompt']) {
            container.dataset.prompt = displayData['Prompt'].toLowerCase();
          }
          
          // Store prompt for copy button
          if (displayData['Prompt'] && copyPromptBtn) {
            copyPromptBtn.dataset.prompt = displayData['Prompt'];
            copyPromptBtn.style.display = 'flex';
          }
          
          // Store in global search index (for searching across all pages)
          if (filename) {
            imageSearchIndex.set(filename, {
              model: (displayData['Model'] || '').toLowerCase(),
              prompt: (displayData['Prompt'] || '').toLowerCase()
            });
          }
          
          // Don't auto-refresh search during metadata extraction - it causes too many reloads
          // The search will work on the next manual search or when user types
        })
        .catch(err => {
          // If metadata extraction fails, keep the base filename
          label.textContent = baseFilename;
          // Try to get dimensions from image
          if (img.naturalWidth && img.naturalHeight) {
            label.textContent = `${baseFilename} · ${img.naturalWidth}x${img.naturalHeight}`;
          }
        })
        .finally(() => {
          activeMetadataExtractions--;
          // Process next item in queue
          if (metadataQueue.length > 0) {
            setTimeout(processMetadataQueue, 0);
          }
        });
    }

    // Embedded image list - injected by inject_image_list.py
    // IMAGE_LIST_PLACEHOLDER
    const embeddedImageList = [
  "2025-11-25/00000-3326279137.png",
  "2025-11-25/00001-3326279137-swapped.png",
  "2025-11-25/00002-3104822491.png",
  "2025-11-25/00003-3104822491-swapped.png",
  "2025-11-25/00004-2725376216.png",
  "2025-11-25/00005-2725376216-swapped.png",
  "2025-11-25/00006-1460379678.png",
  "2025-11-25/00007-1460379678-swapped.png",
  "2025-11-25/00008-3025396646.png",
  "2025-11-25/00009-3025396646-swapped.png",
  "2025-11-25/00010-1208407017.png",
  "2025-11-25/00011-1208407017-swapped.png",
  "2025-11-25/00012-548204485.png",
  "2025-11-25/00013-548204485-swapped.png",
  "2025-11-25/00014-2516089774.png",
  "2025-11-25/00015-2516089774-swapped.png",
  "2025-11-25/00016-4186161600-swapped.png",
  "2025-11-25/00017-4186161600-swapped.png",
  "2025-11-25/00018-4186161600-swapped.png",
  "2025-11-25/00019-4186161600-swapped.png",
  "2025-11-25/00020-4186161600-swapped.png",
  "2025-11-25/00021-4186161600-swapped.png",
  "2025-11-25/00022-4186161600-swapped.png",
  "2025-11-25/00023-4186161600-swapped.png",
  "2025-11-25/00024-4186161600-swapped.png",
  "2025-11-25/00025-4186161600-swapped.png",
  "2025-11-25/00026-4186161600-swapped.png",
  "2025-11-25/00027-4186161600-swapped.png",
  "2025-11-25/00028-4186161600-swapped.png",
  "2025-11-25/00029-4186161600-swapped.png",
  "2025-11-25/00030-4186161600-swapped.png",
  "Favorites/00014-2585734268-swapped.png",
  "Favorites/00030-1676778117-swapped.png",
  "Favorites/00044-159259098-swapped.png"
];
    
    // Function to initialize/reinitialize the gallery
    function initializeGallery(imageList) {
      // Load favorites history from localStorage on init
      loadFavoritesHistory();
      
      allImageFiles = imageList;
      const gallery = document.getElementById('gallery');
      gallery.innerHTML = '';
      allImageContainers = [];
      
      // Reset metadata index for fresh scan
      imageSearchIndex.clear();
      allMetadataFetched = false;
      metadataFetchInProgress = false;
      initialPageLoaded = false;
      backgroundIndexingScheduled = false;
      
      // Reset pagination
      currentPage = 1;
      
      // Initialize image count
      updateImageCount();
      
      // Initialize pagination - don't create all images upfront
      const totalImages = allImageFiles.length;
      
      // Initialize filtered arrays (all images initially)
      filteredImageFiles = [...allImageFiles];
      
      // Initialize pagination UI
      updatePaginationUI();
      
      // Load first page (this will create images for first page only and show loading bar)
      // The loadCurrentPage function will handle showing/hiding the loading bar
      loadCurrentPage();
      
      // Update image count
      setTimeout(updateImageCount, 100);
    }
    
    // Function to reload images by calling the rescan API endpoint
    async function reloadImages() {
      const reloadBtn = document.getElementById('reloadBtn');
      if (!reloadBtn) return;
      
      // Show loading state
      reloadBtn.classList.add('loading');
      reloadBtn.disabled = true;
      
      try {
        // Call the rescan endpoint to get updated image list
        const response = await fetch('/rescan-images', {
          cache: 'no-store',
          headers: {
            'Cache-Control': 'no-cache'
          }
        });
        
        if (!response.ok) {
          throw new Error(`Failed to rescan images: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data.error) {
          throw new Error(data.error);
        }
        
        if (!data.images || !Array.isArray(data.images)) {
          throw new Error('Invalid response format from server');
        }
        
        // Reinitialize gallery with new image list
        initializeGallery(data.images);
        
        // Restart background metadata indexing
        startBackgroundMetadataIndexing();
        
        debugLog(`[Reload] Reloaded ${data.count} images`);
        logToServer('reload_complete', { count: data.count });
        
      } catch (error) {
        console.error('Error reloading images:', error);
        alert(`Failed to reload images: ${error.message}\n\nPlease make sure the Python server is running.`);
      } finally {
        // Remove loading state
        reloadBtn.classList.remove('loading');
        reloadBtn.disabled = false;
      }
    }
    
    // Use embedded image list directly
    (function() {
      // Initialize UI from settings (must happen before gallery initialization)
      initializeModelFilters();
      initializeSizeSlider();
      initializePaging();
      
      // Re-attach model filter button event listeners after generating buttons
      function attachModelFilterListeners() {
        const modelFilterBtns = document.querySelectorAll('.model-filter-btn');
        console.log(`[Model Filter] Found ${modelFilterBtns.length} buttons to attach listeners to`);
        
        if (modelFilterBtns.length === 0) {
          console.error('[Model Filter] No buttons found!');
          return;
        }
        
        modelFilterBtns.forEach((btn, index) => {
          // Remove any existing listeners by cloning
          const newBtn = btn.cloneNode(true);
          btn.parentNode.replaceChild(newBtn, btn);
          
          const model = newBtn.dataset.model;
          const containsText = newBtn.getAttribute('data-contains');
          
          console.log(`[Model Filter] Attaching listener to button ${index}: ${model} (contains: ${containsText})`);
          
          newBtn.addEventListener('click', async function(e) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            const clickedModel = this.dataset.model;
            const clickedBtn = this;
            
            console.log(`[Model Filter] Button clicked: ${clickedModel}`);
            debugLog(`[Model Filter] Button clicked: ${clickedModel}`);
            
            // Toggle: if already active, deactivate; otherwise activate this one
            if (activeModelFilter === clickedModel) {
              activeModelFilter = null;
              clickedBtn.classList.remove('active');
              console.log(`[Model Filter] Deactivated ${clickedModel} filter`);
              debugLog(`[Model Filter] Deactivated ${clickedModel} filter`);
              logToServer('model_filter', { model: null, action: 'deactivate' });
              // Re-apply filter immediately when deactivating
              const searchInput = document.getElementById('searchInput');
              filterImages(searchInput ? searchInput.value : '');
            } else {
              // Deactivate all buttons first
              document.querySelectorAll('.model-filter-btn').forEach(b => b.classList.remove('active'));
              // Activate this button
              activeModelFilter = clickedModel;
              clickedBtn.classList.add('active');
              
              console.log(`[Model Filter] Activating ${clickedModel} filter...`);
              debugLog(`[Model Filter] Activating ${clickedModel} filter...`);
              logToServer('model_filter', { model: clickedModel, action: 'activate' });
              
              // If metadata is already fetched, apply filter immediately
              if (allMetadataFetched) {
                console.log(`[Model Filter] Metadata ready, applying ${clickedModel} filter...`);
                debugLog(`[Model Filter] Metadata ready, applying ${clickedModel} filter...`);
                const searchInput = document.getElementById('searchInput');
                filterImages(searchInput ? searchInput.value : '');
                console.log(`[Model Filter] Filter applied. Showing ${filteredImageFiles.length} images.`);
                debugLog(`[Model Filter] Filter applied. Showing ${filteredImageFiles.length} images.`);
                logToServer('model_filter_result', { model: clickedModel, resultCount: filteredImageFiles.length });
              } else {
                // Need to fetch metadata first
                try {
                  clickedBtn.classList.add('indexing');
                  updateModelFilterButtonsState(true, 0);
                  
                  console.log(`[Model Filter] Applying ${clickedModel} filter...`);
                  debugLog(`[Model Filter] Applying ${clickedModel} filter...`);
                  
                  await fetchAllImageMetadata(false);
                  
                  // Re-apply current search filter (which will also apply model filter)
                  const searchInput = document.getElementById('searchInput');
                  filterImages(searchInput ? searchInput.value : '');
                  
                  // Log results
                  console.log(`[Model Filter] Filter applied. Showing ${filteredImageFiles.length} images.`);
                  debugLog(`[Model Filter] Filter applied. Showing ${filteredImageFiles.length} images.`);
                  logToServer('model_filter_result', { model: clickedModel, resultCount: filteredImageFiles.length });
                } catch (err) {
                  console.error('[Model Filter] Error:', err);
                } finally {
                  clickedBtn.classList.remove('indexing');
                  updateModelFilterButtonsState(false);
                }
              }
            }
          });
        });
        
        console.log(`[Model Filter] Successfully attached listeners to ${modelFilterBtns.length} buttons`);
      }
      
      // Attach listeners after a brief delay to ensure DOM is ready
      setTimeout(() => {
        attachModelFilterListeners();
      }, 100);
      
      initializeGallery(embeddedImageList);
      
      // Start background metadata indexing for model filters
      startBackgroundMetadataIndexing();

        // Set up pagination arrow handlers
        const paginationPrev = document.getElementById('paginationPrev');
        const paginationNext = document.getElementById('paginationNext');
        if (paginationPrev) {
          paginationPrev.addEventListener('click', goToPreviousPage);
        }
        if (paginationNext) {
          paginationNext.addEventListener('click', goToNextPage);
        }
        
        // Set up reload button
        const reloadBtn = document.getElementById('reloadBtn');
        if (reloadBtn) {
          reloadBtn.addEventListener('click', reloadImages);
        }
        
        // Set up page size selector (both in pagination bar and standalone)
        function setupPageSizeSelector(container) {
          const pageSizeItems = container.querySelectorAll('.pagination-page-size-item');
          pageSizeItems.forEach(item => {
            item.addEventListener('click', function() {
              const newSize = parseInt(this.getAttribute('data-size'));
              if (newSize !== imagesPerPage) {
                debugLog(`[Page Size] Changed to ${newSize} images per page`);
                logToServer('page_size_change', { size: newSize });
                imagesPerPage = newSize;
                // Update active state in both containers
                document.querySelectorAll('.pagination-page-size-item').forEach(i => {
                  if (parseInt(i.getAttribute('data-size')) === newSize) {
                    i.classList.add('active');
                  } else {
                    i.classList.remove('active');
                  }
                });
                // Invalidate layout cache before reloading
                layoutCache = null;
                // Reset to page 1
                currentPage = 1;
                // Update pagination UI first (this updates page count)
                updatePaginationUI();
                // Then reload images with new page size
                loadCurrentPage();
                
                // Force scroll to top - use multiple methods to ensure it works
                window.scrollTo(0, 0);
                document.documentElement.scrollTop = 0;
                document.body.scrollTop = 0;
              }
            });
          });
        }
        
        // Set up page size selectors
        const paginationPageSize = document.getElementById('paginationPageSize');
        const paginationPageSizeStandalone = document.getElementById('bottomNavPageSizeStandalone');
        if (paginationPageSize) {
          setupPageSizeSelector(paginationPageSize.parentElement);
        }
        if (paginationPageSizeStandalone) {
          setupPageSizeSelector(paginationPageSizeStandalone);
        }
        
        // Set up auto-hide/show for top and bottom bars based on mouse proximity
        const topNav = document.querySelector('.top-nav');
        const bottomNav = document.getElementById('bottomNav');
        const pageSizeStandalone = document.getElementById('bottomNavPageSizeStandalone');
        const PROXIMITY_THRESHOLD = 45; // pixels from top/bottom edge (reduced for smaller activation area)
        
        let mouseY = -1; // Initialize to -1 so we know it hasn't been set yet
        let showBarsTimeout = null;
        
        // Make updateBarsVisibility accessible from loadCurrentPage
        window.updateBarsVisibility = function() {
          const windowHeight = window.innerHeight;
          // If mouseY hasn't been set yet, assume middle of screen (bars hidden)
          const currentMouseY = mouseY < 0 ? windowHeight / 2 : mouseY;
          const nearTop = currentMouseY <= PROXIMITY_THRESHOLD;
          const nearBottom = currentMouseY >= windowHeight - PROXIMITY_THRESHOLD;
          const gallery = document.getElementById('gallery');
          const loadingBarContainer = document.getElementById('loadingBarContainer');
          
          // Check if loading is in progress
          const isCurrentlyLoading = loadingBarContainer && !loadingBarContainer.classList.contains('hidden');
          
          // Show/hide top nav (always show if loading, or mouse near top)
          let topBarVisible = false;
          if (topNav) {
            if (nearTop || isCurrentlyLoading) {
              topNav.classList.add('visible');
              topBarVisible = true;
            } else {
              topNav.classList.remove('visible');
            }
          }
          
          // Show/hide bottom nav - show when:
          // 1. Loading is in progress, OR
          // 2. Mouse is within threshold of bottom edge (nearBottom)
          let bottomBarVisible = false;
          if (bottomNav && !bottomNav.classList.contains('hidden')) {
            // Show if:
            // - Loading, OR
            // - Mouse near bottom edge
            const shouldShow = isCurrentlyLoading || nearBottom;
            
            // Always explicitly set visibility - don't rely on default state
            if (shouldShow) {
              bottomNav.classList.add('visible');
              bottomBarVisible = true;
            } else {
              // Explicitly hide if conditions not met
              bottomNav.classList.remove('visible');
            }
          }
          
          if (pageSizeStandalone && !pageSizeStandalone.classList.contains('hidden')) {
            // Same logic for standalone page size selector
            const shouldShow = isCurrentlyLoading || nearBottom;
            if (shouldShow) {
              pageSizeStandalone.classList.add('visible');
              bottomBarVisible = true;
            } else {
              // Explicitly hide if conditions not met
              pageSizeStandalone.classList.remove('visible');
            }
          }
          
          // Update gallery spacing - only add margin-top when top bar is visible
          if (gallery) {
            if (topBarVisible) {
              gallery.classList.add('top-bar-visible');
            } else {
              gallery.classList.remove('top-bar-visible');
            }
          }
        }
        
        // Track mouse position - only update when mouse actually moves
        let lastMouseY = -1;
        document.addEventListener('mousemove', function(e) {
          mouseY = e.clientY;
          // Only update visibility if mouse position actually changed significantly
          // This prevents constant updates when mouse is stationary
          if (Math.abs(mouseY - lastMouseY) > 5) {
            lastMouseY = mouseY;
            updateBarsVisibility();
          }
          
          // Clear any existing timeout
          if (showBarsTimeout) {
            clearTimeout(showBarsTimeout);
          }
        });
        
        
        // Hide bars when mouse leaves window (with delay)
        document.addEventListener('mouseleave', function() {
          showBarsTimeout = setTimeout(() => {
            if (topNav) {
              topNav.classList.remove('visible');
            }
            if (bottomNav) {
              bottomNav.classList.remove('visible');
            }
            if (pageSizeStandalone) {
              pageSizeStandalone.classList.remove('visible');
            }
          }, 1000); // Hide after 1 second of mouse leaving
        });
        
        // Show bars when mouse enters window
        document.addEventListener('mouseenter', function() {
          if (showBarsTimeout) {
            clearTimeout(showBarsTimeout);
            showBarsTimeout = null;
          }
          // Only update visibility, don't force show
          updateBarsVisibility();
        });
        
        // Initial check on page load - ensure bars start hidden
        // Bottom bar should ALWAYS start hidden, only show when mouse is near bottom
        setTimeout(() => {
          // If mouseY hasn't been set by mousemove, set it to middle so bars don't show by default
          if (mouseY < 0) {
            mouseY = window.innerHeight / 2;
          }
          // Explicitly hide bottom bar on initial load - it should only show when mouse is near bottom
          if (bottomNav && !bottomNav.classList.contains('hidden')) {
            bottomNav.classList.remove('visible');
          }
          if (pageSizeStandalone && !pageSizeStandalone.classList.contains('hidden')) {
            pageSizeStandalone.classList.remove('visible');
          }
          // Then update visibility based on actual conditions (will hide bottom bar since mouse is in middle)
          updateBarsVisibility();
        }, 100);
        
        // Also ensure bottom bar is hidden immediately on page load
        if (bottomNav && !bottomNav.classList.contains('hidden')) {
          bottomNav.classList.remove('visible');
        }
        if (pageSizeStandalone && !pageSizeStandalone.classList.contains('hidden')) {
          pageSizeStandalone.classList.remove('visible');
        }
        
        // Set up search input listener
        const searchInput = document.getElementById('searchInput');
        const searchClear = document.getElementById('searchClear');
        
        function updateClearButton() {
          if (searchInput.value.length > 0) {
            searchClear.classList.add('visible');
          } else {
            searchClear.classList.remove('visible');
          }
        }
        
        searchInput.addEventListener('input', function(e) {
          const query = e.target.value;
          updateClearButton();
          
          // Debounce search filtering for better performance
          if (searchDebounce) {
            clearTimeout(searchDebounce);
          }
          searchDebounce = setTimeout(() => {
            filterImages(query);
            searchDebounce = null;
          }, 150);
        });
        
        // Clear button click handler
        searchClear.addEventListener('click', function(e) {
          e.preventDefault();
          searchInput.value = '';
          filterImages('');
          updateClearButton();
          searchInput.focus();
        });
        
        // Handle window resize with throttling
        window.addEventListener('resize', function() {
          if (resizeThrottle) {
            clearTimeout(resizeThrottle);
          }
          resizeThrottle = setTimeout(() => {
            layoutCache = null; // Invalidate cache on resize
            layoutMasonry();
            resizeThrottle = null;
          }, 150);
        });
    })();

    // Size control handlers
    function updateImageSizes() {
      // Cancel any pending layout operations to prevent conflicts
      if (typeof window.finalLayoutTimeout !== 'undefined' && window.finalLayoutTimeout) {
        clearTimeout(window.finalLayoutTimeout);
        window.finalLayoutTimeout = null;
      }
      
      const newMaxWidth = baseColumnWidth * currentSizeMultiplier;
      
      // Update all image sizes and recalculate wrapper heights
      // Single loop to minimize DOM queries and operations
      allImageContainers.forEach(container => {
        const wrapper = container.querySelector('.image-wrapper');
        const img = container.querySelector('img');
        
        if (wrapper) {
          wrapper.style.maxWidth = newMaxWidth + 'px';
          // Reset minHeight to allow recalculation
          wrapper.style.minHeight = 'auto';
        }
        
        if (img) {
          img.style.maxWidth = newMaxWidth + 'px';
          
          // Recalculate wrapper height based on actual image dimensions
          // This is critical when shrinking - ensures wrapper shrinks with image
          if (img.complete && img.naturalWidth > 0 && img.naturalHeight > 0) {
            const aspectRatio = img.naturalHeight / img.naturalWidth;
            const newHeight = newMaxWidth * aspectRatio;
            if (wrapper) {
              wrapper.style.minHeight = newHeight + 'px';
            }
          }
        }
      });
      
      // Invalidate layout cache on size change
      layoutCache = null;
      
      // Force layout recalculation with a delay to allow browser to recalculate image dimensions
      // This is especially important when going from larger to smaller sizes
      // Need more time for browser to recalculate when shrinking
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          // Additional delay to ensure dimensions are fully recalculated
          // Longer delay when shrinking to allow browser to properly resize images
          setTimeout(() => {
            // Double-check containers still exist before layout
            if (allImageContainers && allImageContainers.length > 0) {
              // Verify and fix wrapper heights in a single pass
              const expectedMultiplier = baseColumnWidth * currentSizeMultiplier;
              let needsRecalc = false;
              
              for (let i = 0; i < allImageContainers.length; i++) {
                const container = allImageContainers[i];
                const wrapper = container.querySelector('.image-wrapper');
                const img = container.querySelector('img');
                
                // Double-check wrapper height is correct
                if (wrapper && img && img.complete && img.naturalWidth > 0) {
                  const aspectRatio = img.naturalHeight / img.naturalWidth;
                  const expectedHeight = expectedMultiplier * aspectRatio;
                  const currentMinHeight = parseFloat(wrapper.style.minHeight) || 0;
                  
                  // If height is significantly off, recalculate
                  if (Math.abs(currentMinHeight - expectedHeight) > 10) {
                    wrapper.style.minHeight = expectedHeight + 'px';
                    needsRecalc = true;
                  }
                }
              }
              
              // Only force reflow if we made changes
              if (needsRecalc) {
                allImageContainers[0] && void allImageContainers[0].offsetHeight;
              }
              
              layoutMasonry();
            }
          }, 100); // Increased delay to ensure browser has fully recalculated dimensions
        });
      });
    }

    // Size slider functionality with smooth updates
    // Initialize from settings - generate model filter buttons
    function initializeModelFilters() {
      const modelFiltersContainer = document.getElementById('modelFilters');
      if (!modelFiltersContainer) return;
      
      // Clear existing buttons (except status)
      const statusEl = modelFiltersContainer.querySelector('.model-filters-status');
      modelFiltersContainer.innerHTML = '';
      if (statusEl) {
        modelFiltersContainer.appendChild(statusEl);
      }
      
      // Generate buttons from settings
      MODEL_FILTERS.forEach(filter => {
        const btn = document.createElement('button');
        btn.className = 'model-filter-btn';
        btn.setAttribute('data-model', filter.containsText.toLowerCase());
        btn.setAttribute('data-contains', filter.containsText);
        btn.textContent = filter.label;
        modelFiltersContainer.insertBefore(btn, statusEl);
      });
    }
    
    // Initialize size slider from settings
    function initializeSizeSlider() {
      const sizeSlider = document.getElementById('sizeSlider');
      if (!sizeSlider) return;
      
      const minMultiplier = IMAGE_SIZE_SETTINGS.min / IMAGE_SIZE_SETTINGS.min; // Always 1.0
      const maxMultiplier = IMAGE_SIZE_SETTINGS.max / IMAGE_SIZE_SETTINGS.min;
      const defaultMultiplier = IMAGE_SIZE_SETTINGS.default / IMAGE_SIZE_SETTINGS.min;
      
      sizeSlider.min = minMultiplier.toString();
      sizeSlider.max = maxMultiplier.toString();
      sizeSlider.step = IMAGE_SIZE_SETTINGS.step.toString();
      sizeSlider.value = defaultMultiplier.toString();
      
      // Update current multiplier
      currentSizeMultiplier = defaultMultiplier;
    }
    
    // Initialize paging from settings
    function initializePaging() {
      const containers = [
        document.getElementById('paginationPageSize')?.parentElement,
        document.getElementById('bottomNavPageSizeStandalone')
      ].filter(Boolean);
      
      containers.forEach(container => {
        if (!container) return;
        
        // Find the page size container
        const pageSizeContainer = container.querySelector('.bottom-nav-center') || 
                                  container.querySelector('.pagination-page-size');
        if (!pageSizeContainer) return;
        
        // Clear existing items
        pageSizeContainer.innerHTML = '';
        
        // Generate from settings
        PAGING_SETTINGS.options.forEach((size, index) => {
          const item = document.createElement('span');
          item.className = 'pagination-page-size-item';
          if (size === PAGING_SETTINGS.default) {
            item.classList.add('active');
          }
          item.setAttribute('data-size', size.toString());
          item.textContent = size.toString();
          pageSizeContainer.appendChild(item);
          
          // Add separator (except after last item)
          if (index < PAGING_SETTINGS.options.length - 1) {
            const separator = document.createElement('span');
            separator.className = 'pagination-page-size-separator';
            separator.textContent = '·';
            pageSizeContainer.appendChild(separator);
          }
        });
      });
    }
    
    // Initialize everything from settings
    initializeModelFilters();
    initializeSizeSlider();
    initializePaging();
    
    const sizeSlider = document.getElementById('sizeSlider');
    let sizeUpdatePending = false;
    let sizeUpdateRafId = null;
    
    if (sizeSlider) {
      // Smooth size update using requestAnimationFrame
      function scheduleSizeUpdate() {
        if (sizeUpdatePending) return;
        sizeUpdatePending = true;
        
        if (sizeUpdateRafId) {
          cancelAnimationFrame(sizeUpdateRafId);
        }
        
        sizeUpdateRafId = requestAnimationFrame(() => {
          updateImageSizes();
          sizeUpdatePending = false;
          sizeUpdateRafId = null;
        });
      }
      
      // Handle slider input (real-time updates with throttling)
      sizeSlider.addEventListener('input', function() {
        currentSizeMultiplier = parseFloat(this.value);
        // Schedule smooth update
        scheduleSizeUpdate();
      });
      
      // Handle slider change (when released)
      sizeSlider.addEventListener('change', function() {
        currentSizeMultiplier = parseFloat(this.value);
        // Ensure final update is applied
        if (sizeUpdateRafId) {
          cancelAnimationFrame(sizeUpdateRafId);
        }
        updateImageSizes();
        debugLog(`[Size] Changed to ${currentSizeMultiplier}x (${Math.round(baseColumnWidth * currentSizeMultiplier)}px)`);
        logToServer('size_change', { multiplier: currentSizeMultiplier, width: Math.round(baseColumnWidth * currentSizeMultiplier) });
      });
    }

    // Sort functionality
    async function getFileDate(filename) {
      if (imageDates.has(filename)) {
        return imageDates.get(filename);
      }
      
      try {
        // Use fetch with HEAD request (works with http:// protocol)
        const response = await fetch(escapeFilename(filename), { method: 'HEAD' });
        const lastModified = response.headers.get('Last-Modified');
        if (lastModified) {
          const date = new Date(lastModified);
          imageDates.set(filename, date);
          return date;
        }
      } catch (err) {
        // Fallback on error
      }
      
      // Fallback to current date if we can't get the file date
      const date = new Date();
      imageDates.set(filename, date);
      return date;
    }

    function updateSortButtonIcons() {
      const filenameBtn = document.getElementById('sortFilename');
      const dateBtn = document.getElementById('sortDate');
      
      // Update filename button
      if (sortState.filename) {
        filenameBtn.classList.add('active');
        const svg = filenameBtn.querySelector('svg');
        if (sortState.filename === 'asc') {
          svg.innerHTML = '<path d="M7 10l5 5 5-5z"/>'; // Down arrow
        } else {
          svg.innerHTML = '<path d="M7 14l5-5 5 5z"/>'; // Up arrow
        }
      } else {
        filenameBtn.classList.remove('active');
        filenameBtn.querySelector('svg').innerHTML = '<path d="M7 10l5 5 5-5z"/>';
      }
      
      // Update date button
      if (sortState.date) {
        dateBtn.classList.add('active');
        const svg = dateBtn.querySelector('svg');
        // Calendar icon with arrow overlay
        if (sortState.date === 'asc') {
          svg.innerHTML = '<path d="M19 4h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V10h14v10zm0-12H5V6h14v2z"/><path d="M7 10l5 5 5-5z" transform="translate(5,12)"/>';
        } else {
          svg.innerHTML = '<path d="M19 4h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V10h14v10zm0-12H5V6h14v2z"/><path d="M7 14l5-5 5 5z" transform="translate(5,12)"/>';
        }
      } else {
        dateBtn.classList.remove('active');
        dateBtn.querySelector('svg').innerHTML = '<path d="M19 4h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V10h14v10zm0-12H5V6h14v2z"/>';
      }
    }

    async function sortByFilename() {
      // Toggle sort direction
      if (sortState.filename === null || sortState.filename === 'desc') {
        sortState.filename = 'asc';
        sortState.date = null; // Clear other sort
      } else {
        sortState.filename = 'desc';
      }
      
      debugLog(`[Sort] Sorting by filename: ${sortState.filename}`);
      logToServer('sort', { by: 'filename', direction: sortState.filename });
      
      // Optimized sorting: Use Intl.Collator for better performance with numeric sorting
      const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });
      const sorted = [...allImageFiles].sort((a, b) => {
        const aName = getFilenameOnly(a).toLowerCase();
        const bName = getFilenameOnly(b).toLowerCase();
        const result = collator.compare(aName, bName);
        return sortState.filename === 'asc' ? result : -result;
      });
      
      allImageFiles = sorted;
      
      // Re-apply all active filters (model, favorites, search) after sorting
      const searchInput = document.getElementById('searchInput');
      const searchQuery = searchInput ? searchInput.value : '';
      filterImages(searchQuery);
      
      // Update sort button icons
      updateSortButtonIcons();
    }

    async function sortByDate() {
      // Toggle sort direction
      if (sortState.date === null || sortState.date === 'desc') {
        sortState.date = 'asc';
        sortState.filename = null; // Clear other sort
      } else {
        sortState.date = 'desc';
      }
      
      debugLog(`[Sort] Sorting by date: ${sortState.date}`);
      logToServer('sort', { by: 'date', direction: sortState.date });
      
      updateSortButtonIcons();
      
      // Fetch dates for all images (with optimized batching)
      const BATCH_SIZE = 20; // Increased batch size for better performance
      const indices = allImageFiles.map((filename, index) => ({ index, filename }));
      
      // Fetch dates in batches with requestIdleCallback for non-blocking
      for (let i = 0; i < indices.length; i += BATCH_SIZE) {
        const batch = indices.slice(i, i + BATCH_SIZE);
        await Promise.all(batch.map(async (item) => {
          item.date = await getFileDate(item.filename);
        }));
        
        // Yield to browser between batches
        if (i + BATCH_SIZE < indices.length) {
          await new Promise(resolve => {
            if ('requestIdleCallback' in window) {
              requestIdleCallback(resolve, { timeout: 100 });
            } else {
              setTimeout(resolve, 0);
            }
          });
        }
      }
      
      // Sort by date (optimized)
      indices.sort((a, b) => {
        const dateA = a.date.getTime();
        const dateB = b.date.getTime();
        return sortState.date === 'asc' ? dateA - dateB : dateB - dateA;
      });
      
      // Reorder arrays
      const newFiles = indices.map(item => allImageFiles[item.index]);
      
      allImageFiles = newFiles;
      
      // Re-apply all active filters (model, favorites, search) after sorting
      const searchInput = document.getElementById('searchInput');
      const searchQuery = searchInput ? searchInput.value : '';
      filterImages(searchQuery);
      
      // Update sort button icons
      updateSortButtonIcons();
    }

    // Set up sort button handlers
    document.getElementById('sortFilename').addEventListener('click', sortByFilename);
    document.getElementById('sortDate').addEventListener('click', sortByDate);
    
    // Favorites filter button
    const favoritesFilterBtn = document.getElementById('favoritesFilter');
    if (favoritesFilterBtn) {
      favoritesFilterBtn.addEventListener('click', function() {
        showFavoritesOnly = !showFavoritesOnly;
        debugLog(`[Filter] Favorites filter: ${showFavoritesOnly ? 'on' : 'off'}`);
        logToServer('favorites_filter', { enabled: showFavoritesOnly });
        if (showFavoritesOnly) {
          this.classList.add('favorites-active');
        } else {
          this.classList.remove('favorites-active');
        }
        
        // Clear layout cache and columns to force fresh rebuild
        layoutCache = null;
        galleryColumns = [];
        
        // Re-apply current search filter (which will also apply favorites filter)
        const searchInput = document.getElementById('searchInput');
        filterImages(searchInput ? searchInput.value : '');
      });
    }
    
    // Model filter buttons are set up in initialization function above
    
    // Lightbox star button - use capture phase to handle before lightbox click
    const lightboxStarButton = document.getElementById('lightboxStarButton');
    if (lightboxStarButton) {
      // Add handler in capture phase to catch it before lightbox handler
      lightboxStarButton.addEventListener('click', async function(e) {
        e.stopPropagation();
        e.preventDefault();
        e.stopImmediatePropagation();
        
        const filename = this.dataset.filename;
        if (!filename) {
          if (DEBUG_MODE) console.warn('Lightbox star button: no filename');
          return;
        }
        
        debugLog('Lightbox star clicked for:', filename);
        
        // Find the corresponding gallery star button
        const galleryStarButton = document.querySelector(`.star-button[data-filename="${filename}"]`);
        // Use the lightbox button itself if no gallery button found
        const buttonToUpdate = galleryStarButton || this;
        
        try {
          // Use the dataset filename which should reflect the current path
          await toggleFavorite(filename, buttonToUpdate);
          // Note: toggleFavorite will update both buttons dynamically
        } catch (error) {
          console.error('Error toggling favorite from lightbox:', error);
          alert('Error updating favorite: ' + error.message);
        }
      }, true); // Use capture phase
    }

    // --- Click-and-Hold Zoom with Panning ---
    let zoomActive = false;
    let isPanning = false;
    let mouseDownTime = 0;
    let mouseDownTimer = null;
    let initialClickX = 0;
    let initialClickY = 0;
    let panStartX = 0;
    let panStartY = 0;
    let panOffsetX = 0;
    let panOffsetY = 0;
    let currentZoomScale = 1; // Track current zoom scale
    const HOLD_THRESHOLD = 200; // milliseconds to trigger zoom
    const MIN_ZOOM = 1; // Minimum zoom (100%)
    const MAX_ZOOM = 5; // Maximum zoom (500%)
    const ZOOM_STEP = 0.1; // Zoom increment per wheel step
    
    const lightbox = document.getElementById('lightbox');
    const lightboxImg = document.getElementById('lightboxImg');
    
    // Handle mouse down - start click-and-hold detection
    lightboxImg.addEventListener('mousedown', function(e) {
      if (!lightbox.classList.contains('active')) return;
      
      // Ignore right-clicks (button 2) - let contextmenu handle it
      if (e.button === 2) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      mouseDownTime = Date.now();
      initialClickX = e.clientX;
      initialClickY = e.clientY;
      panStartX = e.clientX;
      panStartY = e.clientY;
      
      // If already zoomed, start panning immediately
      if (zoomActive) {
        isPanning = true;
        lightboxImg.classList.add('panning');
        lightbox.classList.add('hide-cursor');
        return;
      }
      
      // Otherwise, start timer for click-and-hold zoom
      mouseDownTimer = setTimeout(function() {
        if (!zoomActive) {
          zoomActive = true;
          isPanning = true;
          lightboxImg.classList.add('zoomed', 'panning');
          lightbox.classList.add('hide-cursor');
          
          // Zoom to 200% centered on initial click position
          // Recalculate rect to ensure accuracy
          const rect = lightboxImg.getBoundingClientRect();
          const imgX = initialClickX - rect.left;
          const imgY = initialClickY - rect.top;
          const originX = Math.max(0, Math.min(100, (imgX / rect.width) * 100));
          const originY = Math.max(0, Math.min(100, (imgY / rect.height) * 100));
          
          lightboxImg.style.transformOrigin = `${originX}% ${originY}%`;
          currentZoomScale = 3.0;
          lightboxImg.style.transform = `scale(${currentZoomScale})`;
          
          // Initialize pan offset
          panOffsetX = 0;
          panOffsetY = 0;
          panStartX = initialClickX;
          panStartY = initialClickY;
        }
      }, HOLD_THRESHOLD);
    });
    
    // Handle mouse move - pan when zoomed
    lightboxImg.addEventListener('mousemove', function(e) {
      if (!zoomActive || !isPanning) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      const deltaX = e.clientX - panStartX;
      const deltaY = e.clientY - panStartY;
      
      // Accumulate pan offset
      panOffsetX += deltaX;
      panOffsetY += deltaY;
      
      // Apply transform with pan using current zoom scale
      lightboxImg.style.transform = `scale(${currentZoomScale}) translate(${panOffsetX}px, ${panOffsetY}px)`;
      
      panStartX = e.clientX;
      panStartY = e.clientY;
    });
    
    // Handle mouse up - end panning or trigger click-to-close
    lightboxImg.addEventListener('mouseup', function(e) {
      // Ignore right-clicks (button 2)
      if (e.button === 2) return;
      
      // Don't close if clicking on navigation arrows
      if (e.target.closest('.lightbox-nav-arrow')) {
        return;
      }
      
      e.stopPropagation();
      
      if (mouseDownTimer) {
        clearTimeout(mouseDownTimer);
        mouseDownTimer = null;
      }
      
      const clickDuration = Date.now() - mouseDownTime;
      
      if (isPanning && zoomActive) {
        // End panning and unzoom - return to full size
        isPanning = false;
        zoomActive = false;
        currentZoomScale = 1;
        lightboxImg.classList.remove('panning', 'zoomed');
        lightbox.classList.remove('hide-cursor');
        lightboxImg.style.transform = '';
        lightboxImg.style.transformOrigin = 'center center';
        panOffsetX = 0;
        panOffsetY = 0;
        resetImageSize();
      } else if (clickDuration < HOLD_THRESHOLD && !isNavigating) {
        // Quick click - close lightbox (works for both zoomed and unzoomed)
        // But only if we're not in the middle of rapid navigation
        hideLightbox();
      }
    });
    
    // Handle mouse leave - end panning and unzoom if zoomed
    lightboxImg.addEventListener('mouseleave', function() {
      if (mouseDownTimer) {
        clearTimeout(mouseDownTimer);
        mouseDownTimer = null;
      }
      if (isPanning && zoomActive) {
        // End panning and unzoom - return to full size
        isPanning = false;
        zoomActive = false;
        currentZoomScale = 1;
        lightboxImg.classList.remove('panning', 'zoomed');
        lightbox.classList.remove('hide-cursor');
        lightboxImg.style.transform = '';
        lightboxImg.style.transformOrigin = 'center center';
        panOffsetX = 0;
        panOffsetY = 0;
        resetImageSize();
      } else if (isPanning) {
        isPanning = false;
        lightboxImg.classList.remove('panning');
        lightbox.classList.remove('hide-cursor');
      }
    });
    
    // Click on overlay (not image) to close
    lightbox.addEventListener('click', function(e) {
      // Don't close if navigating, clicking on navigation arrows, or star button
      // Check both the target and if the click originated from within these elements
      const clickedStarButton = e.target.closest('.lightbox-star-button') || 
                                 e.target.classList.contains('lightbox-star-button') ||
                                 e.target.closest('#lightboxStarButton');
      const clickedNavArrow = e.target.closest('.lightbox-nav-arrow');
      
      if (isNavigating || clickedNavArrow || clickedStarButton) {
        e.stopPropagation();
        return;
      }
      
      // Only close if clicking directly on the overlay itself
      // Don't close if clicking on the image container (it contains the star button)
      if (e.target === lightbox) {
        hideLightbox();
      }
    });
    
    // Keyboard navigation and close
    document.addEventListener('keydown', function(e) {
      if (lightbox.classList.contains('active')) {
        if (e.key === 'Escape') {
          hideLightbox();
        } else if (e.key === 'ArrowLeft') {
          navigateLightbox('prev');
        } else if (e.key === 'ArrowRight') {
          navigateLightbox('next');
        }
      }
    });
    
    // Navigation button click handlers - use capture phase to fire first
    const prevBtn = document.getElementById('lightboxPrev');
    const nextBtn = document.getElementById('lightboxNext');
    
    // Handle navigation clicks - must fire before lightbox click handler
    function handleNavClick(direction, e) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      
      // Navigate
      navigateLightbox(direction);
      
      return false;
    }
    
    // Use capture phase so these fire BEFORE the lightbox click handler
    prevBtn.addEventListener('click', function(e) {
      handleNavClick('prev', e);
    }, true);
    
    nextBtn.addEventListener('click', function(e) {
      handleNavClick('next', e);
    }, true);
    
    // Arrows are now always visible when navigation is possible
    // No need for mouse position tracking
    
    // Scroll wheel zoom - only when lightbox is active
    lightboxImg.addEventListener('wheel', function(e) {
      if (!lightbox.classList.contains('active')) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      // Determine zoom direction
      const delta = e.deltaY > 0 ? -ZOOM_STEP : ZOOM_STEP;
      const newScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, currentZoomScale + delta));
      
      // Only update if scale actually changed
      if (newScale === currentZoomScale) return;
      
      // Get mouse position relative to image
      const rect = lightboxImg.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      // Calculate zoom origin as percentage
      const originX = (mouseX / rect.width) * 100;
      const originY = (mouseY / rect.height) * 100;
      
      // Update zoom scale
      currentZoomScale = newScale;
      
      // If zooming in, activate zoom state
      if (currentZoomScale > 1 && !zoomActive) {
        zoomActive = true;
        lightboxImg.classList.add('zoomed');
      }
      
      // If zooming back to 1x, deactivate zoom state
      if (currentZoomScale <= 1 && zoomActive) {
        zoomActive = false;
        lightboxImg.classList.remove('zoomed');
        lightboxImg.style.transformOrigin = 'center center';
        panOffsetX = 0;
        panOffsetY = 0;
        resetImageSize();
        return;
      }
      
      // Apply zoom with transform origin at mouse cursor
      lightboxImg.style.transformOrigin = `${originX}% ${originY}%`;
      lightboxImg.style.transform = `scale(${currentZoomScale}) translate(${panOffsetX}px, ${panOffsetY}px)`;
    });

    // --- PNG Metadata Extraction for Stable Diffusion ---
    async function getPngMetadata(url){
      // Check cache first
      if (imageMetadataCache.has(url)) {
        return imageMetadataCache.get(url);
      }
      
      // Use fetch (works with http:// protocol from local server)
      // Fallback to XMLHttpRequest if fetch fails
      let buf;
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        buf = await response.arrayBuffer();
      } catch (err) {
        // Fallback to XMLHttpRequest
        buf = await new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.responseType = 'arraybuffer';
          xhr.onload = function() {
            if (xhr.status === 0 || xhr.status === 200) {
              resolve(xhr.response);
            } else {
              reject(new Error(`Failed to load: ${xhr.status}`));
            }
          };
          xhr.onerror = function() {
            reject(new Error('Network error'));
          };
          xhr.ontimeout = function() {
            reject(new Error('Request timeout'));
          };
          xhr.timeout = 10000; // 10 second timeout
          xhr.send();
        });
      }
      
      const bytes = new Uint8Array(buf);
      let i = 8;
      let metadata = {};
      while(i < bytes.length){
        let length = (
          (bytes[i]<<24) |
          (bytes[i+1]<<16) |
          (bytes[i+2]<<8 ) |
          (bytes[i+3])
        )>>>0;
        let type = String.fromCharCode(...bytes.slice(i+4,i+8));
        if(['tEXt','iTXt','zTXt'].includes(type)){
          let chunkData = bytes.slice(i+8, i+8+length);
          let text = "";
          try {
            text = new TextDecoder("utf-8").decode(chunkData);
          } catch(e) {
            text = String.fromCharCode(...chunkData);
          }
          let keyword, value;
          if(type==="iTXt"){
            let nul = text.indexOf('\x00',9);
            keyword = text.slice(0, nul);
            value = text.slice(nul+1);
          } else {
            let nul = text.indexOf('\x00');
            keyword = text.slice(0, nul);
            value = text.slice(nul+1);
          }
          if (keyword && value) metadata[keyword] = value;
        }
        i += 8+length+4;
      }
      // Cache the metadata for future use
      imageMetadataCache.set(url, metadata);
      return metadata;
    }

    // --- AI Image Generation Parameters Parser ---
    // This function parses the "parameters" field from PNG metadata
    // It handles inconsistent formatting with commas in prompts
    function parseAIParameters(parametersText) {
      if (!parametersText) return {};
      
      const result = {};
      
      // List of parameter names we're looking for (in order of appearance, case-insensitive)
      // Longer names first to avoid partial matches
      const parameterNames = [
        'Hires Distilled CFG Scale',
        'Distilled CFG Scale',
        'Hires CFG Scale',
        'Schedule type',
        'Negative prompt',
        'Hires upscaler',
        'Hires upscale',
        'Hires steps',
        'Hires prompt',
        'Model hash',
        'Denoising strength',
        'CFG scale',
        'Clip skip',
        'Sampler',
        'Steps',
        'Seed',
        'Size',
        'Model',
        'Version',
        'RNG',
        'Lora hashes'
      ];
      
      // Remove "parameters" keyword if present at the start
      let text = parametersText.replace(/^parameters\s*/i, '').trim();
      
      // Find the position of "Negative prompt:" to separate positive prompt
      // IMPORTANT: Only match "Negative prompt:" (not "ADetailer negative prompt" or other variants)
      // Match "Negative prompt:" but NOT "ADetailer negative prompt" or "ADetailer X negative prompt"
      let negativePromptMatch = text.match(/\n\s*Negative prompt\s*:?\s*/i);
      if (!negativePromptMatch) {
        negativePromptMatch = text.match(/(?:^|,\s*)Negative prompt\s*:?\s*/i);
      }
      // Verify it's not part of "ADetailer negative prompt" - check text before the match
      if (negativePromptMatch) {
        const matchIndex = negativePromptMatch.index;
        // Check a reasonable amount of text before the match (up to 30 chars should be enough)
        const checkStart = Math.max(0, matchIndex - 30);
        const beforeMatch = text.substring(checkStart, matchIndex).toLowerCase();
        // Check if "adetailer" appears before "negative prompt" (within reasonable distance)
        if (beforeMatch.includes('adetailer')) {
          negativePromptMatch = null;
        }
      }
      const negativePromptIndex = negativePromptMatch ? negativePromptMatch.index : -1;
      
      if (negativePromptIndex > 0) {
        // Extract positive prompt (everything before "Negative prompt:")
        let positivePrompt = text.substring(0, negativePromptIndex).trim();
        
        // If prompt contains Loras, ensure it ends at the last Lora '>'
        const loraMatches = positivePrompt.match(/<lora:[^>]+>/gi);
        if (loraMatches && loraMatches.length > 0) {
          // Find the position of the last Lora tag
          const lastLoraIndex = positivePrompt.lastIndexOf('>');
          if (lastLoraIndex >= 0) {
            // Extract prompt up to and including the last Lora '>'
            positivePrompt = positivePrompt.substring(0, lastLoraIndex + 1).trim();
          }
        }
        
        if (positivePrompt) {
          result['Prompt'] = positivePrompt;
        }
        
        // Extract negative prompt value (everything after "Negative prompt:" until next parameter or end)
        let negativePromptStart = negativePromptIndex + negativePromptMatch[0].length;
        // Find where negative prompt ends (either at newline before next parameter, or comma before next parameter, or end of text)
        let negativePromptEnd = text.length;
        
        // Look for next parameter after negative prompt (like "Steps:", "Sampler:", etc.)
        // Also check for ADetailer parameters and stop there
        const nextParamMatch = text.substring(negativePromptStart).match(/\n\s*(Steps|Sampler|CFG|Seed|Size|Model|Schedule|Denoising|Hires|Version|Clip|RNG|Lora|ADetailer)\s*:/i);
        if (nextParamMatch) {
          negativePromptEnd = negativePromptStart + nextParamMatch.index;
        } else {
          // Check for comma-separated parameters (including ADetailer)
          const commaParamMatch = text.substring(negativePromptStart).match(/,\s*(Steps|Sampler|CFG|Seed|Size|Model|Schedule|Denoising|Hires|Version|Clip|RNG|Lora|ADetailer)\s*:/i);
          if (commaParamMatch) {
            negativePromptEnd = negativePromptStart + commaParamMatch.index;
          }
        }
        
        let negativePromptValue = text.substring(negativePromptStart, negativePromptEnd).trim();
        // Remove trailing comma or newline if present
        negativePromptValue = negativePromptValue.replace(/,\s*$/, '').replace(/\n\s*$/, '').trim();
        if (negativePromptValue) {
          result['Negative Prompt'] = negativePromptValue;
        }
      } else {
        // Check if text starts directly with a known parameter
        let startsWithParam = false;
        for (const param of parameterNames) {
          const regex = new RegExp(`^${param.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*:`, 'i');
          if (regex.test(text)) {
            startsWithParam = true;
            break;
          }
        }
        // If it doesn't start with a parameter, it's likely the positive prompt
        if (!startsWithParam && text) {
          // But check if there's a parameter later - if so, only take text up to first parameter
          let firstParamIndex = text.length;
          for (const param of parameterNames) {
            const regex = new RegExp(`\\b${param.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*:`, 'i');
            const match = text.match(regex);
            if (match && match.index < firstParamIndex) {
              firstParamIndex = match.index;
            }
          }
          
          let promptText = '';
          if (firstParamIndex < text.length) {
            promptText = text.substring(0, firstParamIndex).trim();
          } else {
            promptText = text;
          }
          
          // If prompt contains Loras, ensure it ends at the last Lora '>'
          const loraMatches = promptText.match(/<lora:[^>]+>/gi);
          if (loraMatches && loraMatches.length > 0) {
            // Find the position of the last Lora tag
            const lastLoraIndex = promptText.lastIndexOf('>');
            if (lastLoraIndex >= 0) {
              // Extract prompt up to and including the last Lora '>'
              promptText = promptText.substring(0, lastLoraIndex + 1).trim();
            }
          }
          
          if (promptText) {
            result['Prompt'] = promptText;
          }
        }
      }
      
      // Extract Loras from the entire text (format: <lora:name:weight>)
      // Deduplicate to avoid showing the same lora multiple times
      const loraMatches = text.match(/<lora:[^>]+>/gi);
      if (loraMatches && loraMatches.length > 0) {
        // Remove duplicates by converting to Set and back to array
        const uniqueLoras = [...new Set(loraMatches)];
        result['Loras'] = uniqueLoras.join(' ');
      }
      
      // Parse parameter: value pairs
      // Strategy: Find ALL parameter-like patterns (any text followed by colon, possibly preceded by comma, newline, or >)
      // This helps us identify boundaries even for parameters we don't care about
      const allParamMatches = [];
      
      // Find all patterns that look like parameters: ", ParameterName:" or "ParameterName:" at start
      // Also matches after newlines or > (for parameters after Loras)
      // Pattern: optional comma+whitespace, newline+whitespace, or >+whitespace, then parameter name, then colon
      // Updated to better handle newlines and ensure we catch all parameters
      // Use a more robust pattern that handles start of line, commas, newlines, and > characters
      const paramPattern = /(?:^|,\s*|\n\s*|>\s*)([A-Za-z][^:\n,]*?)\s*:/g;
      let match;
      while ((match = paramPattern.exec(text)) !== null) {
        const paramName = match[1].trim();
        const fullMatch = match[0];
        // Adjust index to skip leading comma, newline, or >
        let indexOffset = 0;
        if (fullMatch.startsWith(',')) {
          indexOffset = 1;
        } else if (fullMatch.startsWith('\n') || fullMatch.startsWith('>')) {
          // Find where the actual parameter name starts (after whitespace)
          const nameStart = fullMatch.search(/\S/);
          indexOffset = nameStart >= 0 ? nameStart : 0;
        }
        const index = match.index + indexOffset;
        
        allParamMatches.push({
          name: paramName,
          index: index,
          colonIndex: match.index + match[0].length - 1, // Position of the colon
          fullMatch: fullMatch
        });
      }
      
      // Now extract values for parameters we care about
      for (const paramName of parameterNames) {
        // Find all occurrences of this parameter (case-insensitive)
        for (let i = 0; i < allParamMatches.length; i++) {
          const match = allParamMatches[i];
          
          // Check if this match is our parameter (case-insensitive)
          if (match.name.toLowerCase() !== paramName.toLowerCase()) {
            continue;
          }
          
          // Find the start of the value (after the colon)
          let valueStart = match.colonIndex + 1;
          // Skip whitespace after colon
          while (valueStart < text.length && /\s/.test(text[valueStart])) {
            valueStart++;
          }
          
          // Find the end of the value
          // The value ends at the comma before the next parameter, newline before next parameter, or at the end of text
          let valueEnd = text.length;
          
          // Look for the next parameter match (any parameter, not just ones we care about)
          for (let j = i + 1; j < allParamMatches.length; j++) {
            const nextMatch = allParamMatches[j];
            
            // Skip ADetailer parameters - stop value extraction before them
            if (nextMatch.name.toLowerCase().includes('adetailer')) {
              // Find the comma or newline before the ADetailer parameter
              const commaBeforeADetailer = text.lastIndexOf(',', nextMatch.index);
              const newlineBeforeADetailer = text.lastIndexOf('\n', nextMatch.index);
              
              if (commaBeforeADetailer > valueStart && commaBeforeADetailer < nextMatch.index) {
                valueEnd = commaBeforeADetailer;
                break;
              } else if (newlineBeforeADetailer > valueStart && newlineBeforeADetailer < nextMatch.index) {
                valueEnd = newlineBeforeADetailer;
                break;
              } else if (nextMatch.index > valueStart) {
                valueEnd = nextMatch.index;
                break;
              }
              continue; // Skip ADetailer parameters entirely
            }
            
            // For comma-separated parameters (most common), find the comma before the next parameter
            // This handles cases like "Steps: 42, Sampler: ..."
            const commaBeforeNext = text.lastIndexOf(',', nextMatch.index);
            if (commaBeforeNext > valueStart && commaBeforeNext < nextMatch.index) {
              valueEnd = commaBeforeNext;
              break;
            }
            
            // Check if there's a newline before the next parameter (newline-separated format)
            // Only use this if no comma was found, or if newline is closer to the value start
            const newlineBeforeNext = text.lastIndexOf('\n', nextMatch.index);
            if (newlineBeforeNext > valueStart && newlineBeforeNext < nextMatch.index) {
              // Check if there's minimal text between newline and parameter (likely a newline-separated parameter)
              const textBetween = text.substring(newlineBeforeNext + 1, nextMatch.index).trim();
              // If text between is short (just whitespace and parameter name), use newline as boundary
              if (textBetween.length < 50 && (commaBeforeNext <= valueStart || newlineBeforeNext < commaBeforeNext)) {
                valueEnd = newlineBeforeNext;
                break;
              }
            }
            
            // If no comma or newline found, the value might extend to the next parameter start
            if (nextMatch.index > valueStart) {
              valueEnd = nextMatch.index;
              break;
            }
          }
          
          let value = text.substring(valueStart, valueEnd).trim();
          // Remove trailing comma or newline if present
          value = value.replace(/,\s*$/, '').replace(/\n\s*$/, '').trim();
          
          if (value) {
            // Map parameter name to display name
            const displayKey = paramName === 'Negative prompt' ? 'Negative Prompt' : 
                             paramName === 'CFG scale' ? 'CFG Scale' :
                             paramName === 'Distilled CFG Scale' ? 'Distilled CFG Scale' :
                             paramName === 'Schedule type' ? 'Schedule Type' :
                             paramName === 'Hires CFG Scale' ? 'Hires CFG Scale' :
                             paramName === 'Hires upscaler' ? 'Hires Upscaler' :
                             paramName === 'Denoising strength' ? 'Denoising Strength' :
                             paramName === 'Clip skip' ? 'Clip Skip' :
                             paramName;
            
            // Skip ADetailer parameters
            if (!displayKey.toLowerCase().includes('adetailer') && 
                !paramName.toLowerCase().includes('adetailer')) {
              // Store the value (overwrite if already exists - take the first occurrence)
              if (!result[displayKey]) {
                result[displayKey] = value;
              }
            }
          }
        }
      }
      
      return result;
    }

    // --- Format and Display Metadata ---
    function formatMetadataForDisplay(rawMetadata) {
      const displayData = {};
      
      // Parse parameters if present
      if (rawMetadata.parameters) {
        const parsed = parseAIParameters(rawMetadata.parameters);
        Object.assign(displayData, parsed);
      }
      
      // The parser already returns properly formatted keys, so we can use them directly
      // Just filter to only the fields we want to display
      const allowedFields = [
        'Prompt', 'Negative Prompt', 'Model', 'Sampler', 'Schedule Type', 
        'Size', 'Steps', 'Hires steps', 'CFG Scale', 'Distilled CFG Scale', 'Denoising Strength',
        'Hires CFG Scale', 'Hires Upscaler', 'Seed', 'Clip Skip', 'Loras', 'Created Date'
      ];
      
      const finalData = {};
      for (const key of allowedFields) {
        if (displayData[key] !== undefined) {
          finalData[key] = displayData[key];
        }
      }
      
      return finalData;
    }

    async function showMetaTable(metadata, imageSrc){
      const modal = document.getElementById('metaModal');
      const container = document.getElementById('metaTableContent');
      
      if(!metadata || Object.keys(metadata).length==0){
        container.innerHTML = "<b>No metadata found.</b>";
      } else {
        // Parse and format the metadata
        const displayData = formatMetadataForDisplay(metadata);
        
        // Add created date if we have image source
        if (imageSrc) {
          try {
            const date = await getFileDate(imageSrc);
            displayData['Created Date'] = date.toLocaleString();
          } catch (err) {
            // If date fetch fails, skip it
          }
        }
        
        if (Object.keys(displayData).length === 0) {
          container.innerHTML = "<b>No AI generation parameters found.</b>";
        } else {
          let rows = "";
          // Display in a specific order
          const displayOrder = [
            'Prompt', 'Negative Prompt', 'Model', 'Sampler', 'Schedule Type', 
            'Size', 'Steps', 'CFG Scale', 'Distilled CFG Scale', 'Seed',
            'Hires Upscaler', 'Denoising Strength', 'Hires steps',
            'Hires CFG Scale', 'Clip Skip', 'Loras', 'Created Date'
          ];
          
          for (const key of displayOrder) {
            if (displayData[key] !== undefined) {
              const value = String(displayData[key]);
              const escapedValue = escapeHtml(value);
              // Store raw value in data attribute, properly escaped for HTML attribute
              const dataValue = value.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
              rows += `<tr><th>${escapeHtml(key)}</th><td><div class="meta-value-wrapper">${escapedValue}<button class="meta-copy-btn" data-value="${dataValue}">copy</button></div></td></tr>`;
            }
          }
          
          container.innerHTML = `<table class="meta-table">${rows}</table>`;
          
          // Add copy button handlers
          container.querySelectorAll('.meta-copy-btn').forEach(btn => {
            btn.addEventListener('click', function(e) {
              e.stopPropagation(); // Prevent closing the modal
              let value = this.getAttribute('data-value');
              // Decode HTML entities
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = value;
              value = tempDiv.textContent || tempDiv.innerText || value;
              navigator.clipboard.writeText(value).then(() => {
                // Visual feedback
                const originalText = this.textContent;
                this.textContent = 'copied!';
                setTimeout(() => {
                  this.textContent = originalText;
                }, 1000);
              }).catch(err => {
                console.error('Failed to copy:', err);
              });
            });
          });
        }
      }
      modal.classList.add('active');
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML.replace(/\n/g, '<br>');
    }
    // Close modal on any click (including inside the table)
    document.getElementById('metaModal').onclick = function(e){
      this.classList.remove('active');
    };
    document.addEventListener('contextmenu', async function(e){
      const img = e.target.closest('img');
      if(!img) return;
      e.preventDefault();
      try {
        const metadata = await getPngMetadata(img.src);
        showMetaTable(metadata, img.src);
      } catch (err) {
        console.error('Failed to load metadata:', err);
        // Show error message in modal
        const modal = document.getElementById('metaModal');
        const container = document.getElementById('metaTableContent');
        container.innerHTML = "<b>Failed to load metadata. The image may not be accessible or may not contain metadata.</b>";
        modal.classList.add('active');
      }
    });
    
    // Click-and-hold scrolling for main gallery
    let galleryScrolling = false;
    let galleryScrollStartY = 0;
    let galleryScrollStartScroll = 0;
    let galleryHasScrolled = false;
    
    function setupGalleryScrolling() {
      const gallery = document.getElementById('gallery');
      if (!gallery) {
        debugLog('Gallery not found for scrolling setup');
        return;
      }
      
      debugLog('Setting up gallery scrolling');
      
      gallery.addEventListener('mousedown', function(e) {
        // Only handle left clicks
        if (e.button !== 0) return;
        
        // Ignore clicks on buttons and links only
        if (e.target.closest('button') || e.target.closest('a')) {
          return;
        }
        
        debugLog('Gallery mousedown - starting scroll');
        
        // Start scrolling - works on images and empty space
        galleryScrolling = true;
        galleryHasScrolled = false;
        galleryScrollStartY = e.clientY;
        // Get current scroll position - try multiple methods
        galleryScrollStartScroll = window.pageYOffset || 
                                   window.scrollY || 
                                   document.documentElement.scrollTop || 
                                   document.body.scrollTop || 
                                   0;
        debugLog('Starting scroll position:', galleryScrollStartScroll);
        gallery.classList.add('scrolling');
        e.preventDefault();
        e.stopPropagation();
      });
      
      document.addEventListener('mousemove', function(e) {
        if (!galleryScrolling) return;
        
        e.preventDefault();
        e.stopPropagation();
        
        const deltaY = e.clientY - galleryScrollStartY;
        debugLog('Gallery mousemove, deltaY:', deltaY);
        
        // Only scroll if mouse moved more than 3 pixels (to avoid accidental scrolling)
        if (Math.abs(deltaY) > 3) {
          galleryHasScrolled = true;
          // Reversed: drag down = scroll up (decrease scrollTop), drag up = scroll down (increase scrollTop)
          // Note: deltaY is positive when dragging down, negative when dragging up
          // Multiply by 3 for 3x faster scrolling, and negate to reverse direction
          const newScroll = Math.max(0, galleryScrollStartScroll - (deltaY * 3));
          const maxScroll = Math.max(
            document.documentElement.scrollHeight - window.innerHeight,
            document.body.scrollHeight - window.innerHeight,
            0
          );
          const clampedScroll = Math.min(newScroll, maxScroll);
          
          debugLog('Scrolling to:', clampedScroll, 'from:', galleryScrollStartScroll, 'deltaY:', deltaY, 'maxScroll:', maxScroll);
          
          // Try multiple scroll methods for compatibility
          window.scrollTo(0, clampedScroll);
          if (document.documentElement.scrollTop !== undefined) {
            document.documentElement.scrollTop = clampedScroll;
          }
          if (document.body.scrollTop !== undefined) {
            document.body.scrollTop = clampedScroll;
          }
        }
      });
      
      document.addEventListener('mouseup', function(e) {
        if (galleryScrolling) {
          // If we scrolled, prevent image click from firing
          if (galleryHasScrolled) {
            const imgContainer = e.target.closest('.img-container');
            if (imgContainer) {
              // Cancel the click event on the image to prevent lightbox from opening
              e.preventDefault();
              e.stopPropagation();
              // Also stop the click event that might fire after mouseup
              imgContainer.addEventListener('click', function cancelClick(evt) {
                evt.preventDefault();
                evt.stopPropagation();
                evt.stopImmediatePropagation();
                imgContainer.removeEventListener('click', cancelClick, true);
              }, true);
            }
          }
          galleryScrolling = false;
          gallery.classList.remove('scrolling');
        }
      });
      
      gallery.addEventListener('mouseleave', function(e) {
        if (galleryScrolling) {
          galleryScrolling = false;
          gallery.classList.remove('scrolling');
        }
      });
    }
    
    // Initialize gallery scrolling when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupGalleryScrolling);
    } else {
      setupGalleryScrolling();
    }
  </script>
</body>
</html>
